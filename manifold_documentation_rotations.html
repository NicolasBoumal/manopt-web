<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Manopt, group of rotations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Nicolas Boumal">
    <link href="favicon.ico" rel="icon" type="image/x-icon">
    <!-- Le styles -->
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
body {
        padding-top: 80px;
        padding-bottom: 40px;
}
      thead {
        font-weight: bold;
      }
    </style>
    <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet">
    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>    <![endif]-->
    <link href="bootstrap/css/prettify.css" type="text/css" rel="stylesheet">
    <link href="bootstrap/css/lang-matlab.css" type="text/css" rel="stylesheet">
  </head>
  <body onload="prettyPrint()">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner"> <a class="btn btn-navbar" data-toggle="collapse"
          data-target=".nav-collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span>
          <span class="icon-bar"></span> </a>
        <div class="container"> <a class="brand" href="index.html">Manopt</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a href="index.html"><i class="icon-home"></i> Home</a></li>
              <li><a href="tutorial.html"><i class="icon-road"></i> Tutorial</a></li>
              <li><a href="downloads.html"><i class="icon-download-alt"></i>
                  Downloads</a></li>
              <li><a href="forum.html"><i class="icon-edit"></i> Forum</a></li>
              <li><a href="about.html"><i class="icon-user"></i> About</a></li>
              <li><a href="#contactmodal" data-toggle="modal"><i class="icon-envelope"></i>
                  Contact</a></li>
            </ul>
          </div>
          <!--/.nav-collapse --> </div>
      </div>
    </div>
    <!-- Contact modal Begin -->
    <div id="contactmodal" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"
      aria-hidden="true">
      <div class="modal-header"> <button type="button" class="close" data-dismiss="modal"
          aria-hidden="true">Ã—</button>
        <h3 id="myModalLabel">To contact us</h3>
      </div>
      <div class="modal-body">
        <p>To discuss code, it is best to use the <a href="forum.html">forum</a>.</p>
        <p>For things not suitable for the forum, e-mail us at <a href="mailto:manopttoolbox@gmail.com">manopttoolbox@gmail.com</a>.</p>
        <p>We are happy to receive feedback and bug reports or requests for more
          features, to discuss the toolbox in general as well as its
          documentation and to help you use it.</p>
        <p>We would also love to know how you use the toolbox, and if you built
          nice manifold factories, solvers or tools that could benefit others.</p>
      </div>
      <div class="modal-footer"> <button class="btn" data-dismiss="modal" aria-hidden="true">Close</button>
      </div>
    </div>
    <!-- Contact modal End -->
    <div class="container">
      <div class="row">
        <div class="span12">
          <!--Body content-->
          <section id="geometry">
            <div class="page-header">
              <h1>A Riemannian geometry for the special orthogonal group (the
                set of rotations)</h1>
            </div>
            <p>The special orthogonal group $\mathrm{SO}(n)$ (the set of
              rotations in $\mathbb{R}^n$) is endowed with a Riemannian manifold
              structure by considering it as a Riemannian submanifold of the
              embedding Euclidean space $\mathbb{R}^{n\times n}$ endowed with
              the usual inner product $\langle H_1, H_2 \rangle =
              \operatorname{trace}(H_1^T H_2)$. Proper rotation matrices are
              orthogonal with determinant +1, as opposed to -1, that is:
              reflections are not allowed. The present factory allows working
              with several rotation matrices simultaneously and efficiently
              using 3D arrays of size <span style="font-family: monospace;">nxnxk</span>
              in Matlab. The geometry of $\mathrm{SO}(n)^k$ is obtained from the
              geometry of $\mathrm{SO}(n)$ in the obvious way by element-wise
              extension.</p>
            <p>Factory call: <code>M = rotationsfactory(n, k)</code>. By
              default, <code>k</code> equals 1.</p>
            <table style="width: 100%;" class="table table-striped table-bordered">
              <thead>
                <tr>
                  <td>Name </td>
                  <td>Formula and numerical representation </td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Set</td>
                  <td>$\mathrm{SO}(n)^k = \{ X = (X_1, \ldots, X_k) \in
                    (\mathbb{R}^{n\times n})^k : X_i^T X_i = I_n \textrm{ and }
                    \det(X_i) = +1, i = 1:k \}$</td>
                </tr>
                <tr>
                  <td> <br>
                  </td>
                  <td>$X$ is represented as a 3D array <code>X</code> of size <span
                      style="font-family: monospace;">nxnxk</span> whose slices
                    are proper rotation matrices, i.e., <code>X(:, :, i).'*X(:,
                      :, i) = eye(n)</code> and <code>det(X(:, :, i)) = 1</code>
                    for <code>i = 1:k</code>.</td>
                </tr>
                <tr>
                  <td>Tangent space at $X$</td>
                  <td>$T_X \mathrm{SO}(n)^k = \{ U = (X_1S_1, \ldots, X_kS_k)
                    \in (\mathbb{R}^{n\times n})^k : S_i + S_i^T = 0, i = 1:k
                    \}$</td>
                </tr>
                <tr>
                  <td> <br>
                  </td>
                  <td>A tangent vector $U$ at $X$ is represented as an array <code>S</code>
                    of size <span style="font-family: monospace;">nxnxk </span>such
                    that each slice of <code>S</code> is a skew-symmetric
                    matrix, i.e., <code>S(:, :, i) + S(:, :, i).' = 0</code>
                    for <code>i = 1:k</code>. Thus, <code>S</code> numerically
                    contains $(S_1, \ldots, S_k)$, not $U$. This is important to
                    note.</td>
                </tr>
                <tr>
                  <td>Ambient space</td>
                  <td>$(\mathbb{R}^{n\times n})^k$</td>
                </tr>
                <tr>
                  <td> <br>
                  </td>
                  <td>Points and vectors in the ambient space are, naturally,
                    represented as 3D arrays of size <span style="font-family: monospace;">nxnxk</span>.</td>
                </tr>
              </tbody>
            </table>
            <div class="alert alert-info"><strong>Heads up!</strong> Tangent
              vectors are represented as skew-symmetric matrices, that is, in
              the Lie algebra of $\mathrm{SO}(n)$. This means that all functions
              of <code>M</code> that take tangent vectors as input or output
              work with skew-symmetric matrices. This skew-symmetric part is
              often written $\Omega$; here, we call it $S$ to have a direct
              correspondence between the math notation $S$ and the Matlab matrix
              <code>S</code>.</div>
          </section>
          <section id="toolset">
            <div class="page-header">
              <h1>Toolset</h1>
            </div>
            <p>The following table shows some of the nontrivial available
              functions in the structure <code>M</code>. The norm $\|\cdot\|$
              refers to the norm in the ambient space, which is the Frobenius
              norm. The <a href="tutorial.html#manifolds">tutorial page</a>
              gives more details about the functionality implemented by each
              function.</p>
            <table style="width: 100%;" class="table table-striped table-bordered">
              <thead>
                <tr>
                  <td>Name </td>
                  <td>Field usage </td>
                  <td>Formula </td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Dimension </td>
                  <td><code>M.dim() </code></td>
                  <td>$\operatorname{dim}\mathcal{M} = k\frac{n(n-1)}{2}$ </td>
                </tr>
                <tr>
                  <td>Metric </td>
                  <td><code>M.inner(X, S, T) </code></td>
                  <td>$\langle U, V\rangle_X = \sum_{i=1}^k
                    \operatorname{trace}(S_i^T T_i)$, where <code>S</code> and
                    <code>T</code> are representations of the tangent vectors $U
                    = (X_1S_1, \ldots, X_kS_k)$ and $V = (X_1T_1, \ldots,
                    X_kT_k)$. </td>
                </tr>
                <tr>
                  <td>Norm </td>
                  <td><code>M.norm(X, S) </code></td>
                  <td>$\|U\|_X = \sqrt{\langle U, U \rangle_X}$</td>
                </tr>
                <tr>
                  <td>Distance </td>
                  <td><code>M.dist(X, Y) </code></td>
                  <td>$\operatorname{dist}(X, Y) = \sqrt{ \sum_{i=1}^k
                    \|\log(X_i^TY_i)\|^2 }$, where $\log$ denotes the matrix
                    logarithm <code>logm</code>. </td>
                </tr>
                <tr>
                  <td>Typical distance </td>
                  <td><code>M.typicaldist() </code></td>
                  <td>$\pi\sqrt{nk}$ </td>
                </tr>
                <tr>
                  <td>Tangent space projector </td>
                  <td><code>S = M.proj(X, H) </code></td>
                  <td>$(P_X(H))_i = X_i S_i$ with $S_i =
                    \operatorname{skew}(X_i^T H_i)$, for $i = 1\ldots k$ where <code>H</code>
                    represents a vector $H = (H_1, \ldots, H_k)$ in the ambient
                    space with slices <code>H(:, :, i)</code> corresponding to
                    $H_i$'s and $\operatorname{skew}$ extracts the
                    skew-symmetric part of a matrix: $\operatorname{skew}(A) =
                    \frac{A-A^T}{2}$. Notice that only $S_i$ is computed since
                    tangent vectors $XS$ are represented using their
                    skew-symmetric part $S$ only. As a result, contrary to
                    intuition, applying <code>proj</code> twice is not
                    equivalent to applying <code>proj</code> once: this is
                    merely a question of numerical representation. See also the
                    function below.</td>
                </tr>
                <tr>
                  <td>Tangent space to ambient space</td>
                  <td><code>H = M.tangent2ambient(X, S)</code></td>
                  <td>Returns an ambient vector $H$ representing the tangent
                    vector which is represented by <code>S</code>, with <code>H(:,
                      :, i) = X(:, :, i)*S(:, :, i)</code>, for $i = 1\ldots k$.
                    For a given tangent vector (represented by the skew
                    symmetric slices <code>S(:, :, i)</code>), returns a
                    representation of that vector in the ambient space, using
                    the slices <code>H(:, :, i)</code>. This function is
                    necessary because the <code>proj</code> operator takes as
                    input an ambient vector and returns a tangent vector. To
                    apply the <code>proj</code> again to the result (which
                    should change nothing), it is necessary to first represent
                    the tangent vector obtained as an ambient vector. This
                    function is here because of formal peculiarities and is
                    likely to disappear at some point. </td>
                </tr>
                <tr>
                  <td>Euclidean to Riemannian gradient</td>
                  <td><nobr><code>M.egrad2rgrad(X, egrad)</code></nobr></td>
                  <td>$\operatorname{grad} f(X) = P_X(\nabla f(X))$, where <code>egrad</code>
                    represents the Euclidean gradient $\nabla f(X)$, which is a
                    vector in the ambient space. </td>
                </tr>
                <tr>
                  <td>Euclidean to Riemannian Hessian</td>
                  <td><nobr><code>M.ehess2rhess(X, egrad, ehess, S)</code></nobr>
                  </td>
                  <td>$(\operatorname{Hess} f(X)[U])_i = P_{X_i}\left(&nbsp;
                    (\nabla^2 f(X)[U])_i &nbsp; - &nbsp; U_i
                    \operatorname{sym}\left( X_i^T (\nabla f(X))_i \right)&nbsp;
                    \right)$, for $i = 1\ldots k$, where <code>S</code>
                    represents the tangent vector $U = (X_1S_1, \ldots,
                    X_kS_k)$, <code>egrad</code> represents the Euclidean
                    gradient $\nabla f(X)$, <code>ehess</code> represents the
                    Euclidean Hessian $\nabla^2 f(X)[U]$ (the two latter being
                    vectors in the ambient space) and $\operatorname{sym}$
                    extracts the symmetric part of a matrix:
                    $\operatorname{sym}(A) = \frac{A+A^T}{2}$.</td>
                </tr>
                <tr>
                  <td>Exponential map </td>
                  <td><code>M.exp(X, S, t) </code></td>
                  <td>$(\operatorname{Exp}_X(tU))_i =
                    X_i\operatorname{exp}(tS_i)$ where <code>S</code>
                    represents the tangent vector $U = (X_1S_1, \ldots, X_kS_k)$
                    and $\operatorname{exp}$ denotes the matrix exponential <code>expm</code>.</td>
                </tr>
                <tr>
                  <td>Retraction </td>
                  <td><code>M.retr(X, S, t) </code></td>
                  <td>$\left( \operatorname{Retr}_X(tU) \right)_i =
                    \operatorname{qfactor}(X_i+tU_i)$, where
                    $\operatorname{qfactor}$ extracts the Q-factor of the QR
                    decomposition with positive elements on the diagonal of R.
                    This is guaranteed to always return a proper rotation
                    matrix, i.e., with determinant +1.</td>
                </tr>
                <tr>
                  <td>Logarithmic map </td>
                  <td><code>S = M.log(X, Y) </code></td>
                  <td>$(\operatorname{Log}_X(Y))_i = X_iS_i$, with $S_i =
                    \operatorname{log}(X_i^T Y_i)$ where $\operatorname{log}$
                    denotes the matrix logarithm <code>logm</code>. </td>
                </tr>
                <tr>
                  <td>Random point </td>
                  <td><code>M.rand() </code></td>
                  <td>Returns a point uniformly at random w.r.t. the natural
                    measure, following the algorithm described in <a href="#references">[Mez07]</a>.
                    Essentially, computes the Q-factor of a QR decomposition of
                    a matrix with i.i.d. normal entries and makes sure the
                    determinant is +1. </td>
                </tr>
                <tr>
                  <td>Random vector </td>
                  <td><code>M.randvec(X) </code></td>
                  <td>Returns a unit-norm tangent vector at $X$ with uniformly
                    random direction.</td>
                </tr>
                <tr>
                  <td>Vector transport </td>
                  <td><code>M.transp(X, Y, S) </code></td>
                  <td>$\left(\operatorname{Transp}_{Y\leftarrow X}(U) \right)_i
                    = Y_iS_i$, where <code>S</code> represents a tangent vector
                    $U = (X_1S_1, \ldots, X_kS_k)$ at $X$ that is transported to
                    the tangent space at $Y$. Since tangent vectors are
                    represented in the Lie algebra, there is nothing to do: <code>S</code>
                    is returned untouched. Notice that this transport is an
                    isometry between tangent spaces: it preserves inner
                    products. </td>
                </tr>
                <tr>
                  <td>Pair mean </td>
                  <td><code>M.pairmean(X, Y) </code></td>
                  <td>$\left( \operatorname{mean}(X, Y) \right)_i = X_i
                    \operatorname{exp}\left( \frac{\operatorname{log}(X_i^T
                    Y_i)}{2} \right)$ </td>
                </tr>
              </tbody>
            </table>
            <p></p>
          </section>
          <section id="differentials">
            <div class="page-header">
              <h1>Example</h1>
            </div>
            <p>Let $A, B\in\mathbb{R}^{n\times m}$ be two matrices representing
              clouds of $m$ points in $\mathbb{R}^n$. We search for the rotation
              matrix $X\in\mathrm{SO}(n)$ such that rotating all points in $B$
              by $X$ will bring the points of $B$ as close as possible to the
              points of $A$, according to the Frobenius norm. This problem has a
              known solution (it is the <a href="http://en.wikipedia.org/wiki/Orthogonal_Procrustes_problem">Procrustes
                problem</a>). We treat it merely for the sake of example. We
              minimize the cost $\frac{1}{2} \|XB - A\|^2 = \frac{1}{2} \|A\|^2
              + \frac{1}{2} \|B\|^2 - \operatorname{Trace}(B^T X^T A)$, which is
              equivalent to minimizing the following cost:</p>
            <p>$$f(X) = -\operatorname{Trace}(X^T \, AB^T),$$</p>
            <p>such that $X \in \mathrm{SO}(n)$. Notice that we really are just
              looking for the closest rotation matrix to the matrix $AB^T$.
              Compute the Euclidean gradient and Hessian of $f$:</p>
            <p>$$\nabla f(X) = -AB^T,$$</p>
            <p>$$\nabla^2 f(X)[XS] = 0.$$</p>
            <p>Internally, the Riemannian gradient and Hessian are obtained by
              applying the <code>M.egrad2rgrad</code> and <code>M.ehess2rhess</code>
              operators to these Euclidean quantities. This happens under the
              hood, as in the following code:</p>
            <pre class="prettyprint lang-matlab linenums">% Generate the problem data.<br>n = 3;<br>m = 10;<br>A = randn(n, m);<br>B = randn(n, m);<br>ABt = A*B.';<br><br>% Create the problem structure.
manifold = rotationsfactory(n, 1);
problem.M = manifold;

% Define the problem cost function and its Euclidean derivatives.<br>problem.cost = @(X) -X(:).'*ABt(:);
problem.egrad = @(X) -ABt;<br>% Notice that, even though the Euclidean Hessian vanishes, the Riemannian Hessian does not.<br>% Indeed, plugging the Euclidean gradient and Hessian explicitly in the ehess2rhess<br>% formula gives a non trivial operator.<br>problem.ehess = @(X, S) manifold.zerovec(X);<br><br>% Numerically check the differentials.<br>checkgradient(problem); pause;<br>checkhessian(problem); pause;<br><br>% Solve the problem<br>X = trustregions(problem);<br><br>% Compare with the known optimal solution<br>[U, S, V] = svd(ABt);<br>UVt = U*V.';<br>% The determinant of UVt is either 1 or -1, in theory<br>if abs(1 - det(UVt)) &lt; 1e-10<br>    Xopt = UVt;<br>elseif abs(-1 - det(UVt)) &lt; 1e-10<br>    % UVt is in O(n) but not SO(n). This is easily corrected for:<br>    J = diag([ones(n-1,1);-1]);<br>    Xopt = U*J*V.';<br>else<br>    error('Should never ever happen ...');<br>end<br>fprintf('This should be small: %g\n', norm(Xopt - X, 'fro'));</pre>
            <p>Notice that if you work with the cost $f(X) = \frac{1}{2} \|XB -
              A\|^2$ directly, your Euclidean gradient becomes $\nabla f(X) =
              (XB-A)B^T = XBB^T - AB^T$ and there seems to be an extra term in
              there. But this term, $XBB^T$, is of the form "$X$ times something
              symmetric", so that the orthogonal projection to the tangent space
              at $X$ will get rid of it.</p>
            <p>More interestingly, one might try to solve the orthogonal
              Procrustes problem with more than two matrices, as in <a href="#references">[TB77]</a>.
              This is linked to the algorithms proposed in [BSA13], with Manopt
              code.</p>
          </section>
          <section id="references">
            <div class="page-header">
              <h1>References</h1>
            </div>
            <p>For theory on Riemannian submanifolds, see [AMS08], section 3.6.1
              (first-order derivatives) and section 5.3.3 (second-order
              derivatives, i.e., connections).</p>
            <p>For content specifically about the Lie group of rotations,
              [Bum04] is one of many resources.</p>
            <p>For an application to the problem of interpolation and regression
              of rotation matrices, see [BA11].</p>
            <p>For algorithms that generate uniformly random rotations, see
              [Mez07].</p>
            <p>[AMS08] P.-A. Absil, R. Mahony and R. Sepulchre, <a target="_blank"
                href="http://press.princeton.edu/chapters/absil/">Optimization
                Algorithms on Matrix Manifolds</a>, Princeton University Press,
              2008.<br>
              [BA11] N. Boumal and P.-A. Absil, <a href="http://www.nicolasboumal.net/papers/Boumal_Absil_A_discrete_regression_method_on_manifolds_and_its_application_to_data_on_SOn.htm">A
                discrete regression method on manifolds and its application to
                data on SO(n)</a>, 18th IFAC World Congress, 2011.<br>
              [Bum04] D. Bump, <a href="http://books.google.be/books?id=wCE8dInDw5gC">Lie
                groups</a>, vol. 225 of Graduate Texts in Mathematics. Springer,
              2004.<br>
              [Mez07] F. Mezzadri, <a href="http://arxiv.org/abs/math-ph/0609050">How
                to generate random matrices from the classical compact groups</a>,
              Notices of the AMS, 54(5), 592â€“604, 2007.<br>
              [TB77] J.M.F. Ten Berge, <a href="http://link.springer.com/article/10.1007%2FBF02294053?LI=true">Orthogonal
                Procrustes rotation for two or more matrices</a>, Psychometrika,
              42(2), 267â€“276, 1977.<br>
              [BSA13] N. Boumal, A. Singer and P.-A. Absil, <a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6760038">Robust
                estimation of rotations from relative measurements by maximum
                likelihood</a>, CDC 2013.</p>
          </section>
          <section id="examples">
            <div class="page-header">
              <h1>List of examples</h1>
            </div>
            <p><a href="reference/examples/generalized_procrustes.html">Generalized
                Procrustes</a></p>
          </section>
        </div>
      </div>
    </div>
    <!-- /container --><!-- Le javascript ================================================== -->
    <script type="text/javascript" src="bootstrap/js/jquery.min.js"></script>
    <script type="text/javascript" src="bootstrap/js/bootstrap.js"></script>
    <script type="text/javascript" src="bootstrap/js/prettify.js"></script>
    <script type="text/javascript" src="bootstrap/js/lang-matlab.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script> <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37402854-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </body>
</html>
