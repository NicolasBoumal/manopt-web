{"title":"Core tools (internals)","markdown":{"yaml":{"title":"Core tools (internals)","subtitle":"Mostly for advanced users","toc":true,"toc-depth":3,"toc-expand":2,"sidebar":"tutorial","aliases":["tutorial.html#core"]},"headingText":"getXYZ","containsRefs":false,"markdown":"\n\nThis page lists [the core tools](https://github.com/NicolasBoumal/manopt/tree/master/manopt/core) of Manopt.\nThey are mostly relevant for users who develop solvers and tools (but not only).\n\n\n\nIn our discussion of how to implement cost functions, [we already noted](costdescription.qmd#accessing-the-cost-gradient-and-hessian) that it is best to use the tools `getCost`, `getGradient` and `getHessian` to evaluate $f$ and its derivatives, as opposed to calling `problem.cost` or `problem.grad` directly.\nThe main reason for this is that users have many choices available for how to implement these objects.\nFor example, `problem.cost` may not exist if the user opted to define `problem.costgrad` instead.\n\nThe inputs `storedb` and `key` are usually optional.\nIt is a good idea to pass them if they are available, as this allows for caching to be used.\n\n * `cost = getCost(problem, x, storedb, key)` \n * `[cost, grad] = getCostGrad(problem, x, storedb, key)` \n * `grad = getGradient(problem, x, storedb, key)` \n * `agrad = getApproxGradient(problem, x, storedb, key)` \n * `pgrad = getPartialGradient(problem, x, I, storedb, key)` \n * `egrad = getEuclideanGradient(problem, x, storedb, key)` \n * `pgrad = getPartialEuclideanGradient(problem, x, I, storedb, key)` \n * `subgrad = getSubgradient(problem, x, tol, storedb, key)` \n * `diff = getDirectionalDerivative(problem, x, d, storedb, key)` \n * `hess = getHessian(problem, x, d, storedb, key)` \n * `hessfd = getHessianFD(problem, x, d, storedb, key)` \n * `approxhess = getApproxHessian(problem, x, d, storedb, key)` \n * `t = getLinesearch(problem, x, d, storedb, key)` \n * `Pd = getPrecon(problem, x, d, storedb, key)` \n * `sqrtPd = getSqrtPrecon(problem, x, d, storedb, key)`\n\n\n## canGetXYZ\n\nFunctions called `canGetXYZ` output `true` if the problem structure provides sufficient information for Manopt to compute `XYZ` exactly.\nThey output `false` otherwise.\n\nIf `false` is returned, that does _not_ imply a call to `getXYZ` will fail.\nFor example, if the problem structure specifies the gradient via `problem.grad` but it does not provide the Hessian, then there is not enough information to compute the exact Hessian.\nAccordingly, `canGetHessian(problem)` ouputs `false`.\nYet, a call to `getHessian(problem, x, u)` does produce something; namely, a finite difference approximation of the Hessian for the provided inputs.\n\nTypically, solvers and tools call `canGetXYZ` functions to assess what can be done with the given problem structure.\nThey issue appropriate warnings as needed, then often proceed to call the `getXYZ` functions anyway.\nThe general philosophy is that Manopt tries to do its best to answer the question asked, with the caveat that it might be slow or inaccurate.\nIf so, tools and solvers normally give a heads up to that effect.\n\n\n * `candoit = canGetCost(problem)` \n * `candoit = canGetDirectionalDerivative(problem)` \n * `candoit = canGetGradient(problem)` \n * `candoit = canGetApproxGradient(problem)` \n * `candoit = canGetPartialGradient(problem)` \n * `candoit = canGetEuclideanGradient(problem)` \n * `candoit = canGetPartialEuclideanGradient(problem)` \n * `candoit = canGetSubgradient(problem)` \n * `candoit = canGetHessian(problem)` \n * `candoit = canGetApproxHessian(problem)` \n * `candoit = canGetPrecon(problem)` \n * `candoit = canGetSqrtPrecon(problem)` \n * `candoit = canGetLinesearch(problem)`\n\n\n## Helpers for solvers\n\nWhen developing solvers (optimization algorithms), it is usually necessary to call these tools:\n\n * `opts = getGlobalDefaults()` \n * `opts = mergeOptions(opts1, opts2)`\n * `stats = applyStatsfun(problem, x, storedb, key, options, stats)` \n * `[stop, reason] = stoppingcriterion(problem, x, options, info, last)` \n * `[newx, newkey, info, hooked] = applyHook(problem, x, storedb, key, options, info, last)` (less common)\n\nFor an example, read through the code of an existing solver, e.g., [`steepestdescent`](https://github.com/NicolasBoumal/manopt/blob/master/manopt/solvers/steepestdescent/steepestdescent.m).\n\n\n## Caching system\n\nThe caching system is described on [this page](costdescription.qmd#using-the-store-caching-system).\nInternally, it is handled with the `StoreDB` class whose code is [here](https://github.com/NicolasBoumal/manopt/blob/master/manopt/core/StoreDB.m).\n\n * `storedb = StoreDB()`\n\nThe class inherits from `handle_light`, whose code is [here](https://github.com/NicolasBoumal/manopt/blob/master/manopt/core/handle_light.m).\nThe latter comes from [a StackOverflow post](https://stackoverflow.com/a/13050111/5989015) by user [sclarke81](https://stackoverflow.com/users/1326370/sclarke81).\n\n\n","srcMarkdownNoYaml":"\n\nThis page lists [the core tools](https://github.com/NicolasBoumal/manopt/tree/master/manopt/core) of Manopt.\nThey are mostly relevant for users who develop solvers and tools (but not only).\n\n\n## getXYZ\n\nIn our discussion of how to implement cost functions, [we already noted](costdescription.qmd#accessing-the-cost-gradient-and-hessian) that it is best to use the tools `getCost`, `getGradient` and `getHessian` to evaluate $f$ and its derivatives, as opposed to calling `problem.cost` or `problem.grad` directly.\nThe main reason for this is that users have many choices available for how to implement these objects.\nFor example, `problem.cost` may not exist if the user opted to define `problem.costgrad` instead.\n\nThe inputs `storedb` and `key` are usually optional.\nIt is a good idea to pass them if they are available, as this allows for caching to be used.\n\n * `cost = getCost(problem, x, storedb, key)` \n * `[cost, grad] = getCostGrad(problem, x, storedb, key)` \n * `grad = getGradient(problem, x, storedb, key)` \n * `agrad = getApproxGradient(problem, x, storedb, key)` \n * `pgrad = getPartialGradient(problem, x, I, storedb, key)` \n * `egrad = getEuclideanGradient(problem, x, storedb, key)` \n * `pgrad = getPartialEuclideanGradient(problem, x, I, storedb, key)` \n * `subgrad = getSubgradient(problem, x, tol, storedb, key)` \n * `diff = getDirectionalDerivative(problem, x, d, storedb, key)` \n * `hess = getHessian(problem, x, d, storedb, key)` \n * `hessfd = getHessianFD(problem, x, d, storedb, key)` \n * `approxhess = getApproxHessian(problem, x, d, storedb, key)` \n * `t = getLinesearch(problem, x, d, storedb, key)` \n * `Pd = getPrecon(problem, x, d, storedb, key)` \n * `sqrtPd = getSqrtPrecon(problem, x, d, storedb, key)`\n\n\n## canGetXYZ\n\nFunctions called `canGetXYZ` output `true` if the problem structure provides sufficient information for Manopt to compute `XYZ` exactly.\nThey output `false` otherwise.\n\nIf `false` is returned, that does _not_ imply a call to `getXYZ` will fail.\nFor example, if the problem structure specifies the gradient via `problem.grad` but it does not provide the Hessian, then there is not enough information to compute the exact Hessian.\nAccordingly, `canGetHessian(problem)` ouputs `false`.\nYet, a call to `getHessian(problem, x, u)` does produce something; namely, a finite difference approximation of the Hessian for the provided inputs.\n\nTypically, solvers and tools call `canGetXYZ` functions to assess what can be done with the given problem structure.\nThey issue appropriate warnings as needed, then often proceed to call the `getXYZ` functions anyway.\nThe general philosophy is that Manopt tries to do its best to answer the question asked, with the caveat that it might be slow or inaccurate.\nIf so, tools and solvers normally give a heads up to that effect.\n\n\n * `candoit = canGetCost(problem)` \n * `candoit = canGetDirectionalDerivative(problem)` \n * `candoit = canGetGradient(problem)` \n * `candoit = canGetApproxGradient(problem)` \n * `candoit = canGetPartialGradient(problem)` \n * `candoit = canGetEuclideanGradient(problem)` \n * `candoit = canGetPartialEuclideanGradient(problem)` \n * `candoit = canGetSubgradient(problem)` \n * `candoit = canGetHessian(problem)` \n * `candoit = canGetApproxHessian(problem)` \n * `candoit = canGetPrecon(problem)` \n * `candoit = canGetSqrtPrecon(problem)` \n * `candoit = canGetLinesearch(problem)`\n\n\n## Helpers for solvers\n\nWhen developing solvers (optimization algorithms), it is usually necessary to call these tools:\n\n * `opts = getGlobalDefaults()` \n * `opts = mergeOptions(opts1, opts2)`\n * `stats = applyStatsfun(problem, x, storedb, key, options, stats)` \n * `[stop, reason] = stoppingcriterion(problem, x, options, info, last)` \n * `[newx, newkey, info, hooked] = applyHook(problem, x, storedb, key, options, info, last)` (less common)\n\nFor an example, read through the code of an existing solver, e.g., [`steepestdescent`](https://github.com/NicolasBoumal/manopt/blob/master/manopt/solvers/steepestdescent/steepestdescent.m).\n\n\n## Caching system\n\nThe caching system is described on [this page](costdescription.qmd#using-the-store-caching-system).\nInternally, it is handled with the `StoreDB` class whose code is [here](https://github.com/NicolasBoumal/manopt/blob/master/manopt/core/StoreDB.m).\n\n * `storedb = StoreDB()`\n\nThe class inherits from `handle_light`, whose code is [here](https://github.com/NicolasBoumal/manopt/blob/master/manopt/core/handle_light.m).\nThe latter comes from [a StackOverflow post](https://stackoverflow.com/a/13050111/5989015) by user [sclarke81](https://stackoverflow.com/users/1326370/sclarke81).\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":{"file":"_header.html"},"highlight-style":"pygments","css":["styles.css"],"toc":true,"html-math-method":"mathjax","strip-comments":true,"toc-depth":3,"output-file":"core.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","crossref":{"eq-prefix":"Eq."},"theme":{"dark":["darkly","custom_darkly.scss"],"light":"sandstone"},"grid":{"sidebar-width":"230px","body-width":"800px","margin-width":"270px","gutter-width":"1.5rem"},"anchor-sections":true,"smooth-scroll":true,"title":"Core tools (internals)","subtitle":"Mostly for advanced users","toc-expand":2,"sidebar":"tutorial","aliases":["tutorial.html#core"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}