{"title":"Manifolds","markdown":{"yaml":{"title":"Manifolds","subtitle":"Available geometries and how they are built","toc":true,"toc-depth":3,"toc-expand":2,"sidebar":"tutorial","aliases":["tutorial.html#manifolds"]},"headingText":"General description ![](images/icon_salute.gif)","containsRefs":false,"markdown":"\n\n\nManifolds in Manopt are represented as structures and are obtained by calling a factory.\nSuch a structure contains a collection of functions that make it possible to interact with the manifold.\n\n<!--\nPicking a manifold corresponds to specifying a search space for the decision variables.\nFor the special (but common) case of a submanifold, the manifold represents a constraint on the decision variables (such as the sphere, which constrains vectors to have unit norm).\nIn the case of a quotient manifold, the manifold captures an invariance in the cost function (such as the Grassmann manifold).\n-->\n\n\n## Available manifolds\n\nManopt comes with a number of implementations for generically useful manifolds.\nBuilt-in factories are located in [`/manopt/manifolds`](https://github.com/NicolasBoumal/manopt/tree/master/manopt/manifolds).\n\nOf course, manifolds can also be user-defined.\nThe best way to build your own is probably to read the code of some of the standard factories and to adapt what needs to be changed.\nIf you develop an interesting manifold factory and would like to share it, [let us know](forum.qmd).\n\nBear in mind that a manifold can be turned into a Riemannian manifold in many different ways, by choosing one or another metric.\nWhich metric is best for a specific application may vary: experiments will tell.\n\n### Linear and affine subspaces\n\n* Euclidean space (real and complex vectors, matrices, tensors, ...)\n  * $\\mathbb{R}^{n}$ <br>\n    `euclideanfactory(n)`\n  * $\\mathbb{R}^{m \\times n}$ <br>\n    `euclideanfactory(m, n)`\n  * $\\mathbb{C}^{n}$ <br>\n    `euclideancomplexfactory(n)`\n  * $\\mathbb{C}^{m \\times n}$ <br>\n    `euclideancomplexfactory(m, n)`\n* Symmetric matrices\n  * $\\{ X \\in \\mathbb{R}^{n \\times n} : X = X^\\top\\}^k$ <br>\n    `symmetricfactory(n, k)`\n* Skew-symmetric matrices\n  * $\\{ X \\in \\mathbb{R}^{n \\times n} : X + X^\\top = 0\\}^k$ <br>\n    `skewsymmetricfactory(n, k)`\n* Centered matrices\n  * $\\{ X \\in \\mathbb{R}^{m \\times n} : X\\mathbf{1}_n = 0_m \\}$ <br>\n    `centeredmatrixfactory(m, n)`\n* Sparse matrices with fixed sparsity pattern\n  * $\\{ X \\in \\mathbb{R}^{m \\times n} : X_{ij} = 0 \\textrm{ if } A_{ij} = 0 \\}$ <br>\n    `euclideansparsefactory(A)` (inefficient implementation)\n* Linear subspace of a linear space\n  * $\\{ x \\in E : x = \\mathrm{proj}(x) \\}$ where $E$ is a linear space (obtained from a factory) and $\\mathrm{proj}$ is an orthogonal projector to the desired subspace. <br>\n    `euclideansubspacefactory(E, proj, dim)`\n\n\n### Spheres, unit norm and unit modulus\n\n* Sphere\n  * $\\{x\\in\\mathbb{R}^{n} : \\|x\\|_2 = 1\\}$ <br>\n    `spherefactory(n)` (unit 2-norm)\n  * $\\{X\\in\\mathbb{R}^{n\\times m} : \\|X\\|_\\mathrm{F} = 1\\}$ <br>\n    `spherefactory(n, m)` (unit Frobenius norm)\n  * $\\{x\\in\\mathbb{C}^{n} : \\|x\\|_2 = 1\\}$ <br>\n    `spherecomplexfactory(n)` (unit 2-norm)\n  * $\\{X\\in\\mathbb{C}^{n\\times m} : \\|X\\|_\\mathrm{F} = 1\\}$ <br>\n    `spherecomplexfactory(n, m)` (unit Frobenius norm)\n* Sphere of symmetric matrices\n  * $\\{X\\in\\mathbb{R}^{n\\times n} : \\|X\\|_\\mathrm{F} = 1 \\textrm{ and } X = X^\\top\\}$ <br>\n    `spheresymmetricfactory(n)`\n* Oblique manifold (product of spheres)\n  * $\\{X\\in\\mathbb{R}^{n\\times m} : \\|X_{:1}\\| = \\cdots = \\|X_{:m}\\| = 1\\}$ <br>\n    `obliquefactory(n, m)` ($m$ normed columns in $\\mathbb{R}^n$)\n  * $\\{X\\in\\mathbb{R}^{m\\times n} : \\|X_{1:}\\| = \\cdots = \\|X_{m:}\\| = 1\\}$ <br>\n    `obliquefactory(n, m, true)` ($m$ normed rows in $\\mathbb{R}^n$)\n  * $\\{X\\in\\mathbb{C}^{n\\times m} : \\|X_{:1}\\| = \\cdots = \\|X_{:m}\\| = 1\\}$ <br>\n    `obliquecomplexfactory(n, m)` ($m$ normed columns in $\\mathbb{C}^n$)\n  * $\\{X\\in\\mathbb{C}^{m\\times n} : \\|X_{1:}\\| = \\cdots = \\|X_{m:}\\| = 1\\}$ <br>\n    `obliquecomplexfactory(n, m, true)` ($m$ normed rows in $\\mathbb{C}^n$)\n* Complex circle, phases\n  * $\\{z\\in\\mathbb{C}^n : |z_1| = \\cdots = |z_n| = 1\\}$ <br>\n    `complexcirclefactory(n)`\n* Phases of discrete Fourier transform (DFT) of a real vector\n  * $\\{z\\in\\mathbb{C}^n : |z_k| = 1, z_{1+\\operatorname{mod}(k, n)} = \\bar{z}_{1+\\operatorname{mod}(n-k, n)} \\ \\forall k\\}$ <br>\n    `realphasefactory(n)`\n\n### Stiefel, Grassmann and orthonormality\n\n* Stiefel manifold\n  * $\\{X \\in \\mathbb{R}^{n \\times p} : X^\\top X = I_p\\}^k$ <br>\n    `stiefelfactory(n, p, k)`\n  * $\\{X \\in \\mathbb{C}^{n \\times p} : X^*X = I_p\\}^k$ <br>\n    `stiefelcomplexfactory(n, p, k)`\n* Generalized Stiefel manifold\n  * $\\{X \\in \\mathbb{R}^{n \\times p} : X^\\top BX = I_p\\}$ for some $B \\succ 0$ <br>\n    `stiefelgeneralizedfactory(n, p, B)`\n* Stiefel manifold, stacked\n  * $\\{X \\in \\mathbb{R}^{md \\times k} : (XX^\\top)_{ii} = I_d\\}$ <br>\n    `stiefelstackedfactory(m, d, k)`\n* Rotation group\n  * $\\{R \\in \\mathbb{R}^{n \\times n} : R^\\top R = I_n, \\det(R) = 1\\}^k$ <br>\n    `rotationsfactory(n, k)`\n* Special Euclidean group (rigid motion)\n  * $\\{ (R, t) \\in \\mathbb{R}^{n \\times n} \\times \\mathbb{R}^n : R^\\top R = I_n, \\det(R) = 1 \\}^k$ <br>\n    `specialeuclideanfactory(n, k)`\n* Unitary matrices\n  * $\\{ U \\in \\mathbb{C}^{n \\times n} : U^*U = I_n \\}^k$ <br>\n    `unitaryfactory(n, k)`\n* Grassmann manifold\n  * $\\{\\operatorname{span}(X) : X \\in \\mathbb{R}^{n \\times p}, X^\\top X = I_p\\}^k$ <br>\n    `grassmannfactory(n, p, k)`\n  * $\\{\\operatorname{span}(X) : X \\in \\mathbb{C}^{n \\times p}, X^*X = I_p\\}^k$ <br>\n    `grassmanncomplexfactory(n, p, k)`\n* Generalized Grassmann manifold\n  * $\\{\\operatorname{span}(X) : X \\in \\mathbb{R}^{n \\times p}, X^\\top BX = I_p\\}$ for some $B \\succ 0$ <br>\n    `grassmannfactory(n, p, B)`\n\n### Rank constraints\n\n* Fixed-rank matrices\n  * $\\{X \\in \\mathbb{R}^{m \\times n} : \\operatorname{rank}(X) = k\\}$ <br>\n    `fixedrankembeddedfactory(m, n, k)` <br>\n    `fixedrankfactory_2factors(m, n, k)` <br>\n    `fixedrankfactory_2factors_preconditioned(m, n, k)` <br>\n    `fixedrankfactory_2factors_subspace_projection(m, n, k)` <br>\n    `fixedrankfactory_3factors(m, n, k)` <br>\n    `fixedrankMNquotientfactory(m, n, k)`\n* Fixed-rank tensors, Tucker\n  * Tensors of fixed multilinear rank in Tucker format <br>\n    `fixedranktensorembeddedfactory` <br>\n    `fixedrankfactory_tucker_preconditioned`\n* Fixed-rank tensors, tensor train\n  * Tensors of fixed tensor train rank in TT format <br>\n    `fixedTTrankfactory`\n\nSee more rank-constrained manifolds in the category _Positivity constraints_.\n\n### Positivity constraints\n\n* Matrices with strictly positive entries\n  * $\\{ X \\in \\mathbb{R}^{m\\times n} : X_{ij} > 0 \\ \\forall i, j\\}$ <br>\n    `positivefactory(m, n)`\n* Symmetric, positive definite matrices\n  * $\\{ X \\in \\mathbb{R}^{n\\times n} : X = X^\\top \\textrm{ and } X \\succ 0\\}$ <br>\n    `sympositivedefinitefactory(n)`\n* Symmetric positive semidefinite, fixed-rank\n  * $\\{X \\in \\mathbb{R}^{n \\times n} : X = X^\\top \\succeq 0 \\textrm{ and } \\operatorname{rank}(X) = k\\}$ <br>\n    `symfixedrankYYfactory(n, k)`\n  * $\\{X \\in \\mathbb{C}^{n \\times n} : X = X^* \\succeq 0 \\textrm{ and } \\operatorname{rank}(X) = k\\}$ <br>\n    `symfixedrankYYcomplexfactory(n, k)`\n* Symmetric positive semidefinite, fixed-rank with unit diagonal\n  * $\\{X \\in \\mathbb{R}^{n \\times n} : X = X^\\top \\succeq 0, \\operatorname{rank}(X) = k, \\operatorname{diag}(X) = 1\\}$ <br>\n    `elliptopefactory(n, k)`\n* Symmetric positive semidefinite, fixed-rank with unit trace\n  * $\\{X \\in \\mathbb{R}^{n \\times n} : X = X^\\top \\succeq 0, \\operatorname{rank}(X) = k, \\operatorname{trace}(X) = 1\\}$ <br>\n    `spectrahedronfactory(n, k)`\n* Multinomial manifold (strict simplex elements)\n  * $\\{ X \\in \\mathbb{R}^{n\\times m} : X_{ij} > 0 \\ \\forall i,j \\textrm{ and } X^\\top \\mathbf{1}_m = \\mathbf{1}_n \\}$ <br>\n    `multinomialfactory(n, m)`\n* Multinomial doubly stochastic manifold\n  * $\\{ X \\in \\mathbb{R}^{n\\times n} : X_{ij} > 0 \\ \\forall i,j \\textrm{ and } X \\mathbf{1}_n = \\mathbf{1}_n, X^\\top \\mathbf{1}_n = \\mathbf{1}_n \\}$ <br>\n    `multinomialdoublystochasticfactory(n)`\n* Multinomial symmetric and stochastic manifold\n  * $\\{ X \\in \\mathbb{R}^{n\\times n} : X_{ij} > 0 \\ \\forall i,j \\textrm{ and } X \\mathbf{1}_n = \\mathbf{1}_n, X = X^\\top \\}$ <br>\n    `multinomialsymmetricfactory(n)`\n* Positive definite simplex\n  * $\\{ (X_1, \\ldots, X_k) \\in (\\mathbb{R}^{n \\times n})^k : X_i \\succ 0 \\ \\forall i \\textrm{ and } X_1 + \\cdots + X_k = I_n \\}$ <br>\n    `sympositivedefinitesimplexfactory(n, k)`\n  * $\\{ (X_1, \\ldots, X_k) \\in (\\mathbb{C}^{n \\times n})^k : X_i \\succ 0 \\ \\forall i \\textrm{ and } X_1 + \\cdots + X_k = I_n \\}$ <br>\n    `sympositivedefinitesimplexcomplexfactory(n, k)`\n\n### Miscellaneous\n\n* Constant manifold (singleton)\n  * $\\{ A \\}$ <br>\n    `constantfactory(A)` <br>\n    This is convenient with `productmanifold`, to fix some variables.\n* Hyperbolic manifold\n  * $\\{ x \\in \\mathbb{R}^{n+1} : x_0^2 = x_1^2 + \\cdots + x_n^2 + 1 \\}^m$ with Minkowski metric <br>\n    `hyperbolicfactory(n, m)`\n* Poincaré ball\n  * $\\{ x \\in \\mathbb{R}^{k} : x^\\top x < 1 \\}^n$ with Poincaré metric <br>\n    `poincareballfactory(k, n)`\n* Essential manifold\n  * Epipolar constraint between projected points in two perspective views <br>\n    `essentialfactory(k, 'signed')` (or `unsigned`)\n\n\n## Product manifolds\n\nThe tools `productmanifold` and `powermanifold` make it easy to work on products of existing manifolds.\n<!--We provide some information here: see the [tools](tools.qmd) page for more.-->\n\nFor example, if you are minimizing a function $f(X, Y)$ where $X$ is a $3 \\times 3$ matrix with unit Frobenius norm and $Y$ is $4 \\times 2$ with orthonormal columns, then use `productmanifold` as follows:\n\n```matlab\nelements.X = spherefactory(3, 3);\nelements.Y = stiefelfactory(4, 2);\nM = productmanifold(elements);\n```\n\nPoints on `M` are encoded as structures with fields `X` and `Y`.\nLikewise for tangent vectors and vectors in the embedding space.\n\nIf you are minimizing a function $f(X_1, \\ldots, X_7)$ where each $X_i$ is a $3 \\times 4$ matrix of rank $2$ (the same manifold for each), then use `powermanifold` as follows:\n\n```matlab\nN = fixedrankembeddedfactory(3, 4, 2);\nM = powermanifold(N, 7)\n```\n\nPoints on `M` are encoded as cells with $7$ entries.\nLikewise for tangent vectors and vectors in the embedding space.\n\nOf course, calls to `productmanifold` and `powermanifold` can be composed.\n\nHowever, bear in mind that these tools are provided mostly for convenience.\nThey allow fast prototyping, but it may be possible to write a more efficient factory for your specific product manifold.\nFor example, `obliquefactory(n, m)` encodes the same geometry as `powermanifold(spherefactory(n), m)`, but the former is more efficient than the latter.\n\nIf a factory offers built-in support for products, it is highly recommend to prefer that over the tools here.\nFor example, `stiefelfactory(n, p, k)` encodes the same geometry as `powermanifold(stiefelfactory(n, p), k)`, but the former is more efficient than the latter.\n\n\n## Manifold structures: what's in them?\n\nThe documentation for a manifold factory should specify\n\n* How points on the manifold are represented numerically,\n* How tangent vectors to the manifold are represented numerically,\n* And likewise for the embedding space (submanifolds) or total space (quotient manifolds).\n\nTypically, points and tangent vector are represented by matrices, but they could be represented by structures, cells, etc.: there are no limitations.\nThey can even be represented by data on a GPU.\n\nBased on these, the implementation of a Riemannian manifold is a collection of functions.\nThese functions are collected into a structure: that is what a factory returns as output.\n\nThese functions are listed below.\nNot all factories populate all of these fields, and that's okay: for many purposes, only a subset of these functions are necessary.\n\nNotice that it is possible to add or replace fields in a manifold structure after it was returned by a factory.\nThus, one can easily experiment with various retractions, vector transports, etc.\nIf you find ways to improve the built-in geometries, let us know.\n\n\n| Name  | Field usage  | Functionality  |\n|-|-|---|\n| Name | `M.name()` | Returns the name of the manifold as a string. |\n| Dimension  | `M.dim()`  | Returns the dimension of the manifold.  |\n| Metric  | `M.inner(x, u, v)`  | Computes the Riemannian metric $\\langle u, v \\rangle_x$.  |\n| Norm  | `M.norm(x, u)`  | Computes the Riemannian norm $\\|u\\|_x = \\sqrt{\\langle u, u \\rangle_x}$. |\n| Distance  | `M.dist(x, y)`  | Computes the Riemannian distance $\\operatorname{dist}(x, y)$.  |\n| Typical distance  | `M.typicaldist()`  | Returns the \"scale\" of the manifold. This is used by the trust-regions solver for example, to determine default initial and maximal trust-region radii. |\n| Tangent space projector  | `M.proj(x, u)`  | For manifolds embedded in a Euclidean space, computes the orthogonal projection $\\operatorname{Proj}_x u$ of the vector $u$ from the embedding space to the tangent space at $x$. If `M` is a quotient manifold, then the projection is from the embedding space of the total space to the horizontal space at $x$.  |\n| Euclidean to Riemannian gradient | `M.egrad2rgrad(x, egrad)` | For manifolds embedded in a Euclidean space, converts the gradient of $f$ at $x$ seen as a function in that Euclidean space to the Riemannian gradient of $f$ on the manifold. Allowed to take `(storedb, key)` as input for caching, but must also allow to be called without it. |\n| Euclidean to Riemannian Hessian | `M.ehess2rhess(x, egrad, ehess, u)`  | Similarly to `egrad2rgrad`, converts the Euclidean gradient and Hessian of $f$ at $x$ along a tangent vector $u$ to the Riemannian Hessian of $f$ at $x$ along $u$ on the manifold. Allowed to take `(storedb, key)` as input for caching, but must also allow to be called without it. Mind the warning below. |\n| Tangentialize | `M.tangent(x, u)` | Re-tangentializes a vector. The input is a vector in the tangent vector representation, which possibly (for example because of error accumulations) is no longer tangent. The output is the \"closest\" tangent vector to the input. If tangent vectors are represented in the ambient space, this is equivalent to `proj`. |\n| Tangent to ambient representation | `M.tangent2ambient(x, u)` | Tangent vectors are sometimes represented differently from their counterpart in the ambient space. This function returns the ambient space representation of a tangent vector $u$. Useful when defining the Euclidean Hessian `ehess` for example.  |\n| Exponential map  | `M.exp(x, u, t)`  | Computes $\\operatorname{Exp}_x(tu)$, the point you reach by following the vector $u$ scaled by $t$ starting at $x$. As of 5.0, this field should only exist if the manifold provides a genuine exponential map. Otherwise, manually fall back to `M.retr`. |\n| Retraction  | `M.retr(x, u, t)`  | Computes $\\Retr_x(tu)$, where $\\Retr$ is a retraction: a cheaper proxy for the exponential map. |\n| Logarithmic map  | `M.log(x, y)`  | Computes $\\operatorname{Log}_x(y)$, a tangent vector at $x$ pointing toward $y$. This is meant to be the inverse of $\\operatorname{Exp}$. |\n| Inverse retraction | `M.invretr(x, y)`  | Computes the inverse of the retraction: a tangent vector at $x$ pointing toward $y$. |\n| Random point  | `M.rand()`  | Computes a random point on the manifold.  |\n| Random vector  | `M.randvec(x)`  | Computes a random, unit-norm tangent vector in the tangent space at $x$.  |\n| Zero vector  | `M.zerovec(x)`  | Returns the zero tangent vector at $x$. |\n| Linear combination  | `M.lincomb(x, a1, u1, a2, u2)`  | Computes the tangent vector at $x$: $v = a_1 u_1 + a_2 u_2$, where $a_1, a_2$ are scalars and $u_1, u_2$ are tangent vectors at $x$. The inputs $a_2, u_2$ are optional. |\n| Vector transport  | `M.transp(x, y, u)`  | Computes a tangent vector at $y$ that \"looks like\" the tangent vector $u$ at $x$. This is not necessarily a parallel transport. |\n| Isometric transport | `M.isotransp(x, y, u)` | An isometric vector transport (few manifold implementations offer this, though for some `M.transp` is isometric: see their documentation). |\n| Pair mean  | `M.pairmean(x, y)`  | Computes the intrinsic mean of $x$ and $y$, that is, a point that lies mid-way between $x$ and $y$ on the geodesic arc joining them.  |\n| Hashing function  | `M.hash(x)`  | Computes a string that (almost) uniquely identifies the point $x$ and that can serve as a field name for a structure. (No longer used as of Manopt 2.0.) |\n| Vector representation | `M.vec(x, u)` | Returns a real column-vector representation of the tangent vector $u$. The length of the output is always the same and at least `M.dim()`. This function is linear and invertible in $u$ on the tangent space at $x$. |\n| Normal representation | `M.mat(x, u_vec)` | The inverse of the `vec` function: returns a tangent vector representation from a column vector such that `M.mat(x, M.vec(x, u)) = u`. |\n| Isometry check for `vec` and `mat` | `M.vecmatareisometries()` | Returns `true` if `M.vec` is a linear isometry, i.e., if for all tangent vectors $u,v$, `M.inner(x, u, v) == M.vec(x, u).'*M.vec(x, v)`. Then, `M.mat` is both the adjoint and the inverse of `M.vec` (on the tangent space). |\n| Lie group identity | `M.lie_identity()` | If the manifold is a Lie group, this function returns the identity element (e.g., for the rotation group in $\\mathbb{R}^d$, that would be the identity matrix of size $d$). |\n\n: Manifolds are encoded as structures which contain fields. Most of these fields are function handles which make it possible to interact with the manifold. {.striped}\n\n::: {.callout-warning}\n## Mind the details for `ehess2rhess`.\nConsider a Riemannian manifold `M` embedded in a Euclidean space `E`.\nIn the call pattern\n```matlab\nrhess = M.ehess2rhess(x, egrad, ehess, u)\n```\nthe vectors `egrad` and `ehess` are vectors in the embedding space `E`, whereas the vectors `u` and `rhess` are tangent vectors to `M` at `x`.\nIt is important to use the corresponding numerical representations, as documented by the manifold's factory.\n\nFor factories which use the same numerical representation for tangent vectors and vectors in the embedding space (e.g., `spherefactory`), this causes no difficulties.\nHowever, for factories such as `rotationsfactory`, the distinction matters.\nThe functions `M.proj` (from embedding space to tangent space) `M.tangent2ambient` (from tangent space to embedding space) may help.\n\nIf `M` is a quotient manifold of a manifold `N` (called the total space) embedded in `E`, then `egrad` and `ehess` are still vectors in the embedding space `E` but `u` and `rhess` are horizontal vectors at `x`.\nFor example, `grassmannfactory(n, p)` is a quotient of `stiefelfactory(n, p)` which is embedded in $\\mathbb{R}^{n \\times p}$.\n:::\n","srcMarkdownNoYaml":"\n\n## General description ![](images/icon_salute.gif)\n\nManifolds in Manopt are represented as structures and are obtained by calling a factory.\nSuch a structure contains a collection of functions that make it possible to interact with the manifold.\n\n<!--\nPicking a manifold corresponds to specifying a search space for the decision variables.\nFor the special (but common) case of a submanifold, the manifold represents a constraint on the decision variables (such as the sphere, which constrains vectors to have unit norm).\nIn the case of a quotient manifold, the manifold captures an invariance in the cost function (such as the Grassmann manifold).\n-->\n\n\n## Available manifolds\n\nManopt comes with a number of implementations for generically useful manifolds.\nBuilt-in factories are located in [`/manopt/manifolds`](https://github.com/NicolasBoumal/manopt/tree/master/manopt/manifolds).\n\nOf course, manifolds can also be user-defined.\nThe best way to build your own is probably to read the code of some of the standard factories and to adapt what needs to be changed.\nIf you develop an interesting manifold factory and would like to share it, [let us know](forum.qmd).\n\nBear in mind that a manifold can be turned into a Riemannian manifold in many different ways, by choosing one or another metric.\nWhich metric is best for a specific application may vary: experiments will tell.\n\n### Linear and affine subspaces\n\n* Euclidean space (real and complex vectors, matrices, tensors, ...)\n  * $\\mathbb{R}^{n}$ <br>\n    `euclideanfactory(n)`\n  * $\\mathbb{R}^{m \\times n}$ <br>\n    `euclideanfactory(m, n)`\n  * $\\mathbb{C}^{n}$ <br>\n    `euclideancomplexfactory(n)`\n  * $\\mathbb{C}^{m \\times n}$ <br>\n    `euclideancomplexfactory(m, n)`\n* Symmetric matrices\n  * $\\{ X \\in \\mathbb{R}^{n \\times n} : X = X^\\top\\}^k$ <br>\n    `symmetricfactory(n, k)`\n* Skew-symmetric matrices\n  * $\\{ X \\in \\mathbb{R}^{n \\times n} : X + X^\\top = 0\\}^k$ <br>\n    `skewsymmetricfactory(n, k)`\n* Centered matrices\n  * $\\{ X \\in \\mathbb{R}^{m \\times n} : X\\mathbf{1}_n = 0_m \\}$ <br>\n    `centeredmatrixfactory(m, n)`\n* Sparse matrices with fixed sparsity pattern\n  * $\\{ X \\in \\mathbb{R}^{m \\times n} : X_{ij} = 0 \\textrm{ if } A_{ij} = 0 \\}$ <br>\n    `euclideansparsefactory(A)` (inefficient implementation)\n* Linear subspace of a linear space\n  * $\\{ x \\in E : x = \\mathrm{proj}(x) \\}$ where $E$ is a linear space (obtained from a factory) and $\\mathrm{proj}$ is an orthogonal projector to the desired subspace. <br>\n    `euclideansubspacefactory(E, proj, dim)`\n\n\n### Spheres, unit norm and unit modulus\n\n* Sphere\n  * $\\{x\\in\\mathbb{R}^{n} : \\|x\\|_2 = 1\\}$ <br>\n    `spherefactory(n)` (unit 2-norm)\n  * $\\{X\\in\\mathbb{R}^{n\\times m} : \\|X\\|_\\mathrm{F} = 1\\}$ <br>\n    `spherefactory(n, m)` (unit Frobenius norm)\n  * $\\{x\\in\\mathbb{C}^{n} : \\|x\\|_2 = 1\\}$ <br>\n    `spherecomplexfactory(n)` (unit 2-norm)\n  * $\\{X\\in\\mathbb{C}^{n\\times m} : \\|X\\|_\\mathrm{F} = 1\\}$ <br>\n    `spherecomplexfactory(n, m)` (unit Frobenius norm)\n* Sphere of symmetric matrices\n  * $\\{X\\in\\mathbb{R}^{n\\times n} : \\|X\\|_\\mathrm{F} = 1 \\textrm{ and } X = X^\\top\\}$ <br>\n    `spheresymmetricfactory(n)`\n* Oblique manifold (product of spheres)\n  * $\\{X\\in\\mathbb{R}^{n\\times m} : \\|X_{:1}\\| = \\cdots = \\|X_{:m}\\| = 1\\}$ <br>\n    `obliquefactory(n, m)` ($m$ normed columns in $\\mathbb{R}^n$)\n  * $\\{X\\in\\mathbb{R}^{m\\times n} : \\|X_{1:}\\| = \\cdots = \\|X_{m:}\\| = 1\\}$ <br>\n    `obliquefactory(n, m, true)` ($m$ normed rows in $\\mathbb{R}^n$)\n  * $\\{X\\in\\mathbb{C}^{n\\times m} : \\|X_{:1}\\| = \\cdots = \\|X_{:m}\\| = 1\\}$ <br>\n    `obliquecomplexfactory(n, m)` ($m$ normed columns in $\\mathbb{C}^n$)\n  * $\\{X\\in\\mathbb{C}^{m\\times n} : \\|X_{1:}\\| = \\cdots = \\|X_{m:}\\| = 1\\}$ <br>\n    `obliquecomplexfactory(n, m, true)` ($m$ normed rows in $\\mathbb{C}^n$)\n* Complex circle, phases\n  * $\\{z\\in\\mathbb{C}^n : |z_1| = \\cdots = |z_n| = 1\\}$ <br>\n    `complexcirclefactory(n)`\n* Phases of discrete Fourier transform (DFT) of a real vector\n  * $\\{z\\in\\mathbb{C}^n : |z_k| = 1, z_{1+\\operatorname{mod}(k, n)} = \\bar{z}_{1+\\operatorname{mod}(n-k, n)} \\ \\forall k\\}$ <br>\n    `realphasefactory(n)`\n\n### Stiefel, Grassmann and orthonormality\n\n* Stiefel manifold\n  * $\\{X \\in \\mathbb{R}^{n \\times p} : X^\\top X = I_p\\}^k$ <br>\n    `stiefelfactory(n, p, k)`\n  * $\\{X \\in \\mathbb{C}^{n \\times p} : X^*X = I_p\\}^k$ <br>\n    `stiefelcomplexfactory(n, p, k)`\n* Generalized Stiefel manifold\n  * $\\{X \\in \\mathbb{R}^{n \\times p} : X^\\top BX = I_p\\}$ for some $B \\succ 0$ <br>\n    `stiefelgeneralizedfactory(n, p, B)`\n* Stiefel manifold, stacked\n  * $\\{X \\in \\mathbb{R}^{md \\times k} : (XX^\\top)_{ii} = I_d\\}$ <br>\n    `stiefelstackedfactory(m, d, k)`\n* Rotation group\n  * $\\{R \\in \\mathbb{R}^{n \\times n} : R^\\top R = I_n, \\det(R) = 1\\}^k$ <br>\n    `rotationsfactory(n, k)`\n* Special Euclidean group (rigid motion)\n  * $\\{ (R, t) \\in \\mathbb{R}^{n \\times n} \\times \\mathbb{R}^n : R^\\top R = I_n, \\det(R) = 1 \\}^k$ <br>\n    `specialeuclideanfactory(n, k)`\n* Unitary matrices\n  * $\\{ U \\in \\mathbb{C}^{n \\times n} : U^*U = I_n \\}^k$ <br>\n    `unitaryfactory(n, k)`\n* Grassmann manifold\n  * $\\{\\operatorname{span}(X) : X \\in \\mathbb{R}^{n \\times p}, X^\\top X = I_p\\}^k$ <br>\n    `grassmannfactory(n, p, k)`\n  * $\\{\\operatorname{span}(X) : X \\in \\mathbb{C}^{n \\times p}, X^*X = I_p\\}^k$ <br>\n    `grassmanncomplexfactory(n, p, k)`\n* Generalized Grassmann manifold\n  * $\\{\\operatorname{span}(X) : X \\in \\mathbb{R}^{n \\times p}, X^\\top BX = I_p\\}$ for some $B \\succ 0$ <br>\n    `grassmannfactory(n, p, B)`\n\n### Rank constraints\n\n* Fixed-rank matrices\n  * $\\{X \\in \\mathbb{R}^{m \\times n} : \\operatorname{rank}(X) = k\\}$ <br>\n    `fixedrankembeddedfactory(m, n, k)` <br>\n    `fixedrankfactory_2factors(m, n, k)` <br>\n    `fixedrankfactory_2factors_preconditioned(m, n, k)` <br>\n    `fixedrankfactory_2factors_subspace_projection(m, n, k)` <br>\n    `fixedrankfactory_3factors(m, n, k)` <br>\n    `fixedrankMNquotientfactory(m, n, k)`\n* Fixed-rank tensors, Tucker\n  * Tensors of fixed multilinear rank in Tucker format <br>\n    `fixedranktensorembeddedfactory` <br>\n    `fixedrankfactory_tucker_preconditioned`\n* Fixed-rank tensors, tensor train\n  * Tensors of fixed tensor train rank in TT format <br>\n    `fixedTTrankfactory`\n\nSee more rank-constrained manifolds in the category _Positivity constraints_.\n\n### Positivity constraints\n\n* Matrices with strictly positive entries\n  * $\\{ X \\in \\mathbb{R}^{m\\times n} : X_{ij} > 0 \\ \\forall i, j\\}$ <br>\n    `positivefactory(m, n)`\n* Symmetric, positive definite matrices\n  * $\\{ X \\in \\mathbb{R}^{n\\times n} : X = X^\\top \\textrm{ and } X \\succ 0\\}$ <br>\n    `sympositivedefinitefactory(n)`\n* Symmetric positive semidefinite, fixed-rank\n  * $\\{X \\in \\mathbb{R}^{n \\times n} : X = X^\\top \\succeq 0 \\textrm{ and } \\operatorname{rank}(X) = k\\}$ <br>\n    `symfixedrankYYfactory(n, k)`\n  * $\\{X \\in \\mathbb{C}^{n \\times n} : X = X^* \\succeq 0 \\textrm{ and } \\operatorname{rank}(X) = k\\}$ <br>\n    `symfixedrankYYcomplexfactory(n, k)`\n* Symmetric positive semidefinite, fixed-rank with unit diagonal\n  * $\\{X \\in \\mathbb{R}^{n \\times n} : X = X^\\top \\succeq 0, \\operatorname{rank}(X) = k, \\operatorname{diag}(X) = 1\\}$ <br>\n    `elliptopefactory(n, k)`\n* Symmetric positive semidefinite, fixed-rank with unit trace\n  * $\\{X \\in \\mathbb{R}^{n \\times n} : X = X^\\top \\succeq 0, \\operatorname{rank}(X) = k, \\operatorname{trace}(X) = 1\\}$ <br>\n    `spectrahedronfactory(n, k)`\n* Multinomial manifold (strict simplex elements)\n  * $\\{ X \\in \\mathbb{R}^{n\\times m} : X_{ij} > 0 \\ \\forall i,j \\textrm{ and } X^\\top \\mathbf{1}_m = \\mathbf{1}_n \\}$ <br>\n    `multinomialfactory(n, m)`\n* Multinomial doubly stochastic manifold\n  * $\\{ X \\in \\mathbb{R}^{n\\times n} : X_{ij} > 0 \\ \\forall i,j \\textrm{ and } X \\mathbf{1}_n = \\mathbf{1}_n, X^\\top \\mathbf{1}_n = \\mathbf{1}_n \\}$ <br>\n    `multinomialdoublystochasticfactory(n)`\n* Multinomial symmetric and stochastic manifold\n  * $\\{ X \\in \\mathbb{R}^{n\\times n} : X_{ij} > 0 \\ \\forall i,j \\textrm{ and } X \\mathbf{1}_n = \\mathbf{1}_n, X = X^\\top \\}$ <br>\n    `multinomialsymmetricfactory(n)`\n* Positive definite simplex\n  * $\\{ (X_1, \\ldots, X_k) \\in (\\mathbb{R}^{n \\times n})^k : X_i \\succ 0 \\ \\forall i \\textrm{ and } X_1 + \\cdots + X_k = I_n \\}$ <br>\n    `sympositivedefinitesimplexfactory(n, k)`\n  * $\\{ (X_1, \\ldots, X_k) \\in (\\mathbb{C}^{n \\times n})^k : X_i \\succ 0 \\ \\forall i \\textrm{ and } X_1 + \\cdots + X_k = I_n \\}$ <br>\n    `sympositivedefinitesimplexcomplexfactory(n, k)`\n\n### Miscellaneous\n\n* Constant manifold (singleton)\n  * $\\{ A \\}$ <br>\n    `constantfactory(A)` <br>\n    This is convenient with `productmanifold`, to fix some variables.\n* Hyperbolic manifold\n  * $\\{ x \\in \\mathbb{R}^{n+1} : x_0^2 = x_1^2 + \\cdots + x_n^2 + 1 \\}^m$ with Minkowski metric <br>\n    `hyperbolicfactory(n, m)`\n* Poincaré ball\n  * $\\{ x \\in \\mathbb{R}^{k} : x^\\top x < 1 \\}^n$ with Poincaré metric <br>\n    `poincareballfactory(k, n)`\n* Essential manifold\n  * Epipolar constraint between projected points in two perspective views <br>\n    `essentialfactory(k, 'signed')` (or `unsigned`)\n\n\n## Product manifolds\n\nThe tools `productmanifold` and `powermanifold` make it easy to work on products of existing manifolds.\n<!--We provide some information here: see the [tools](tools.qmd) page for more.-->\n\nFor example, if you are minimizing a function $f(X, Y)$ where $X$ is a $3 \\times 3$ matrix with unit Frobenius norm and $Y$ is $4 \\times 2$ with orthonormal columns, then use `productmanifold` as follows:\n\n```matlab\nelements.X = spherefactory(3, 3);\nelements.Y = stiefelfactory(4, 2);\nM = productmanifold(elements);\n```\n\nPoints on `M` are encoded as structures with fields `X` and `Y`.\nLikewise for tangent vectors and vectors in the embedding space.\n\nIf you are minimizing a function $f(X_1, \\ldots, X_7)$ where each $X_i$ is a $3 \\times 4$ matrix of rank $2$ (the same manifold for each), then use `powermanifold` as follows:\n\n```matlab\nN = fixedrankembeddedfactory(3, 4, 2);\nM = powermanifold(N, 7)\n```\n\nPoints on `M` are encoded as cells with $7$ entries.\nLikewise for tangent vectors and vectors in the embedding space.\n\nOf course, calls to `productmanifold` and `powermanifold` can be composed.\n\nHowever, bear in mind that these tools are provided mostly for convenience.\nThey allow fast prototyping, but it may be possible to write a more efficient factory for your specific product manifold.\nFor example, `obliquefactory(n, m)` encodes the same geometry as `powermanifold(spherefactory(n), m)`, but the former is more efficient than the latter.\n\nIf a factory offers built-in support for products, it is highly recommend to prefer that over the tools here.\nFor example, `stiefelfactory(n, p, k)` encodes the same geometry as `powermanifold(stiefelfactory(n, p), k)`, but the former is more efficient than the latter.\n\n\n## Manifold structures: what's in them?\n\nThe documentation for a manifold factory should specify\n\n* How points on the manifold are represented numerically,\n* How tangent vectors to the manifold are represented numerically,\n* And likewise for the embedding space (submanifolds) or total space (quotient manifolds).\n\nTypically, points and tangent vector are represented by matrices, but they could be represented by structures, cells, etc.: there are no limitations.\nThey can even be represented by data on a GPU.\n\nBased on these, the implementation of a Riemannian manifold is a collection of functions.\nThese functions are collected into a structure: that is what a factory returns as output.\n\nThese functions are listed below.\nNot all factories populate all of these fields, and that's okay: for many purposes, only a subset of these functions are necessary.\n\nNotice that it is possible to add or replace fields in a manifold structure after it was returned by a factory.\nThus, one can easily experiment with various retractions, vector transports, etc.\nIf you find ways to improve the built-in geometries, let us know.\n\n\n| Name  | Field usage  | Functionality  |\n|-|-|---|\n| Name | `M.name()` | Returns the name of the manifold as a string. |\n| Dimension  | `M.dim()`  | Returns the dimension of the manifold.  |\n| Metric  | `M.inner(x, u, v)`  | Computes the Riemannian metric $\\langle u, v \\rangle_x$.  |\n| Norm  | `M.norm(x, u)`  | Computes the Riemannian norm $\\|u\\|_x = \\sqrt{\\langle u, u \\rangle_x}$. |\n| Distance  | `M.dist(x, y)`  | Computes the Riemannian distance $\\operatorname{dist}(x, y)$.  |\n| Typical distance  | `M.typicaldist()`  | Returns the \"scale\" of the manifold. This is used by the trust-regions solver for example, to determine default initial and maximal trust-region radii. |\n| Tangent space projector  | `M.proj(x, u)`  | For manifolds embedded in a Euclidean space, computes the orthogonal projection $\\operatorname{Proj}_x u$ of the vector $u$ from the embedding space to the tangent space at $x$. If `M` is a quotient manifold, then the projection is from the embedding space of the total space to the horizontal space at $x$.  |\n| Euclidean to Riemannian gradient | `M.egrad2rgrad(x, egrad)` | For manifolds embedded in a Euclidean space, converts the gradient of $f$ at $x$ seen as a function in that Euclidean space to the Riemannian gradient of $f$ on the manifold. Allowed to take `(storedb, key)` as input for caching, but must also allow to be called without it. |\n| Euclidean to Riemannian Hessian | `M.ehess2rhess(x, egrad, ehess, u)`  | Similarly to `egrad2rgrad`, converts the Euclidean gradient and Hessian of $f$ at $x$ along a tangent vector $u$ to the Riemannian Hessian of $f$ at $x$ along $u$ on the manifold. Allowed to take `(storedb, key)` as input for caching, but must also allow to be called without it. Mind the warning below. |\n| Tangentialize | `M.tangent(x, u)` | Re-tangentializes a vector. The input is a vector in the tangent vector representation, which possibly (for example because of error accumulations) is no longer tangent. The output is the \"closest\" tangent vector to the input. If tangent vectors are represented in the ambient space, this is equivalent to `proj`. |\n| Tangent to ambient representation | `M.tangent2ambient(x, u)` | Tangent vectors are sometimes represented differently from their counterpart in the ambient space. This function returns the ambient space representation of a tangent vector $u$. Useful when defining the Euclidean Hessian `ehess` for example.  |\n| Exponential map  | `M.exp(x, u, t)`  | Computes $\\operatorname{Exp}_x(tu)$, the point you reach by following the vector $u$ scaled by $t$ starting at $x$. As of 5.0, this field should only exist if the manifold provides a genuine exponential map. Otherwise, manually fall back to `M.retr`. |\n| Retraction  | `M.retr(x, u, t)`  | Computes $\\Retr_x(tu)$, where $\\Retr$ is a retraction: a cheaper proxy for the exponential map. |\n| Logarithmic map  | `M.log(x, y)`  | Computes $\\operatorname{Log}_x(y)$, a tangent vector at $x$ pointing toward $y$. This is meant to be the inverse of $\\operatorname{Exp}$. |\n| Inverse retraction | `M.invretr(x, y)`  | Computes the inverse of the retraction: a tangent vector at $x$ pointing toward $y$. |\n| Random point  | `M.rand()`  | Computes a random point on the manifold.  |\n| Random vector  | `M.randvec(x)`  | Computes a random, unit-norm tangent vector in the tangent space at $x$.  |\n| Zero vector  | `M.zerovec(x)`  | Returns the zero tangent vector at $x$. |\n| Linear combination  | `M.lincomb(x, a1, u1, a2, u2)`  | Computes the tangent vector at $x$: $v = a_1 u_1 + a_2 u_2$, where $a_1, a_2$ are scalars and $u_1, u_2$ are tangent vectors at $x$. The inputs $a_2, u_2$ are optional. |\n| Vector transport  | `M.transp(x, y, u)`  | Computes a tangent vector at $y$ that \"looks like\" the tangent vector $u$ at $x$. This is not necessarily a parallel transport. |\n| Isometric transport | `M.isotransp(x, y, u)` | An isometric vector transport (few manifold implementations offer this, though for some `M.transp` is isometric: see their documentation). |\n| Pair mean  | `M.pairmean(x, y)`  | Computes the intrinsic mean of $x$ and $y$, that is, a point that lies mid-way between $x$ and $y$ on the geodesic arc joining them.  |\n| Hashing function  | `M.hash(x)`  | Computes a string that (almost) uniquely identifies the point $x$ and that can serve as a field name for a structure. (No longer used as of Manopt 2.0.) |\n| Vector representation | `M.vec(x, u)` | Returns a real column-vector representation of the tangent vector $u$. The length of the output is always the same and at least `M.dim()`. This function is linear and invertible in $u$ on the tangent space at $x$. |\n| Normal representation | `M.mat(x, u_vec)` | The inverse of the `vec` function: returns a tangent vector representation from a column vector such that `M.mat(x, M.vec(x, u)) = u`. |\n| Isometry check for `vec` and `mat` | `M.vecmatareisometries()` | Returns `true` if `M.vec` is a linear isometry, i.e., if for all tangent vectors $u,v$, `M.inner(x, u, v) == M.vec(x, u).'*M.vec(x, v)`. Then, `M.mat` is both the adjoint and the inverse of `M.vec` (on the tangent space). |\n| Lie group identity | `M.lie_identity()` | If the manifold is a Lie group, this function returns the identity element (e.g., for the rotation group in $\\mathbb{R}^d$, that would be the identity matrix of size $d$). |\n\n: Manifolds are encoded as structures which contain fields. Most of these fields are function handles which make it possible to interact with the manifold. {.striped}\n\n::: {.callout-warning}\n## Mind the details for `ehess2rhess`.\nConsider a Riemannian manifold `M` embedded in a Euclidean space `E`.\nIn the call pattern\n```matlab\nrhess = M.ehess2rhess(x, egrad, ehess, u)\n```\nthe vectors `egrad` and `ehess` are vectors in the embedding space `E`, whereas the vectors `u` and `rhess` are tangent vectors to `M` at `x`.\nIt is important to use the corresponding numerical representations, as documented by the manifold's factory.\n\nFor factories which use the same numerical representation for tangent vectors and vectors in the embedding space (e.g., `spherefactory`), this causes no difficulties.\nHowever, for factories such as `rotationsfactory`, the distinction matters.\nThe functions `M.proj` (from embedding space to tangent space) `M.tangent2ambient` (from tangent space to embedding space) may help.\n\nIf `M` is a quotient manifold of a manifold `N` (called the total space) embedded in `E`, then `egrad` and `ehess` are still vectors in the embedding space `E` but `u` and `rhess` are horizontal vectors at `x`.\nFor example, `grassmannfactory(n, p)` is a quotient of `stiefelfactory(n, p)` which is embedded in $\\mathbb{R}^{n \\times p}$.\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":{"file":"_header.html"},"highlight-style":"pygments","css":["styles.css"],"toc":true,"html-math-method":"mathjax","strip-comments":true,"toc-depth":3,"output-file":"manifolds.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","crossref":{"eq-prefix":"Eq."},"theme":{"dark":["darkly","custom_darkly.scss"],"light":"sandstone"},"grid":{"sidebar-width":"230px","body-width":"800px","margin-width":"270px","gutter-width":"1.5rem"},"anchor-sections":true,"smooth-scroll":true,"title":"Manifolds","subtitle":"Available geometries and how they are built","toc-expand":2,"sidebar":"tutorial","aliases":["tutorial.html#manifolds"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}