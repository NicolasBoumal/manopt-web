<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Manopt, fixed-rank manifold with three factors</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link href="favicon.ico" rel="icon" type="image/x-icon">
    <!-- Le styles -->
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
body {
	padding-top: 80px;
	padding-bottom: 40px;
}
thead {
	font-weight: bold;
}
</style>
    <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet">
    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script> <![endif]-->
    <link href="bootstrap/css/prettify.css" type="text/css" rel="stylesheet">
    <link href="bootstrap/css/lang-matlab.css" type="text/css" rel="stylesheet">
  </head>
  <body onload="prettyPrint()">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <a class="btn btn-navbar"><span class="icon-bar"></span> <span
            class="icon-bar"></span> <span class="icon-bar"></span> </a>
        <div class="container">
          <a class="brand" href="index.html">Manopt</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a href="index.html"><i class="icon-home"></i> Home</a></li>
              <li><a href="tutorial.html"><i class="icon-road"></i> Tutorial</a></li>
              <li><a href="downloads.html"><i class="icon-download-alt"></i> Downloads</a></li>
            <li><a href="forum.html"><i class="icon-edit"></i> Forum</a></li>
            <li><a href="about.html"><i class="icon-user"></i> About</a></li>
            <li><a href="#contactmodal"><i class="icon-envelope"></i> Contact</a></li>
          </ul>
        </div>
        <!--/.nav-collapse -->
      </div>
    </div>
  </div>
  <!-- Contact modal Begin -->
  <div id="contactmodal" class="modal hide fade" tabindex="-1">
    <div class="modal-header">
      <button type="button" class="close">&#215;</button>
      <h3 id="myModalLabel">To contact us</h3>
    </div>
    <div class="modal-body">
      <p>To discuss code, it is best to use the <a href="forum.html">forum</a>.</p>
      <p>For things not suitable for the forum, e-mail us at <a href="mailto:manopttoolbox@gmail.com">manopttoolbox@gmail.com</a>.</p>
      <p>We are happy to receive feedback and bug reports or requests for more
        features, to discuss the toolbox in general as well as its documentation and to
        help you use it.</p>
      <p>We would also love to know how you use the toolbox, and if you built nice
        manifold factories, solvers or tools that could benefit others.</p>
    </div>
    <div class="modal-footer">
      <button class="btn">Close</button> </div>
  </div>
  <!-- Contact modal End -->
  <div class="container">
    <div class="row">
      <div class="span12">
        <!--Body content-->
        <section id="geometry">
          <div class="page-header">
            <h1>A Riemannian quotient geometry for the set of fixed-rank matrices with three factors</h1>
          </div>
          <p>The set $\mathbb{R}_k ^{m \times n}$ of rank-<code>k</code> matrices $X$ of size
            $m\times n$ is parameterized as $LSR^T$ where $L \in {\rm St}(k, m)$, $S \in S_{++}(k)$ and $R \in {\rm St}(k, n)$. ${\rm St}(k, m)$ is the set of $m\times k$ matrices with orthonormal columns and $S_{++}(k)$ is the set of symmetric and positive definite matrices of size $k\times k$. Notice that the transformation $(L,S, R) \rightarrow (LO,O^T S O, RO)$, where $O^TO = OO^T = I$, keeps $X$ unchanged. The resulting search is, thus, the quotient space ${\rm St}(k, m)\times S_{++}(k) \times {\rm St}(k, m) / {\rm OG}(k)$. Conceptually, we move on the quotient space but the matrix representations are done in the space ${\rm St}(k, m)\times S_{++}(k) \times {\rm St}(k, m) $.</p>
          <p>A function $\phi :\mathbb{R}_k ^{m \times n} \rightarrow \mathbb{R}: X \mapsto \phi(X) $ induces a function $f: {\rm St}(k, m)\times S_{++}(k) \times {\rm St}(k, m) \rightarrow \mathbb{R}: (L,S, R) \mapsto f(L,S, R)$ where $\phi(X) = f(L,S, R)$ (though in some developments belows we use the notation $f(X)$ for simplicity). The computational space ${\rm St}(k, m)\times S_{++}(k) \times {\rm St}(k, m)$ is endowed with a scaled metric that is different from the standard Euclidean metric.</p>
          <p>The following material is referenced from the paper, B. Mishra, G. Meyer, S. Bonnabel and R. Sepulchre, <a
              href="http://arxiv.org/abs/1209.0430">Fixed-rank matrix factorizations and Riemannian low-rank optimization</a>, Tech. report, arXiv:1209.0430, 2012.</p>
          <p>Factory call: <code>M = manopt.manifolds.fixedrank.fixedrankfactory_3factors(m,n,k)</code>. </p>
          <table style="width: 100%;" class="table table-striped table-bordered">
            <thead>
              <tr>
                <td>Name
              </td>
              <td>Formula
            </td>
            <td>Numerical representation</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Set</td>
            <td>$ \begin{array}{ll} \mathbb{R}_r ^{m \times n} &amp;= \{ LSR^T: L \in {\rm St}(k, m), R \in {\rm St}(k, n), \\ &amp; S \in S_{++}(k) \} \end{array} $</td>
            <td>$(L,S,R)$ is represented as a structure array of $X$ with three fields. $L$, $S$ and $R$ are represented as matrices <code>X.L</code>, <code>X.S</code> and <code>X.R</code> of size $m\times k$, $k \times k$ and $n \times k$ respectively.</td>
          </tr>
          <tr>
            <td>Horizontal space at $X$</td>
            <td>$
              \begin{array}{lll}
              &amp; \{ (U_L, U_S, U_R) \in \mathbb{R}^{m\times k} \times \mathbb{R}^{k \times k} \times \mathbb{R}^{n\times k}: \\
              &amp; U_L ^T L + L ^T U_L = 0, U_R ^T R + R^T U_R = 0, U_S ^ T = U_S, \\
              &amp; U_L^T L + U_R ^ T R + S^{-1} U_S - U_S S^{-1} {\rm \ is\ symmetric}\}
              \end{array}
              $</td>
            <td>A horizontal vector $(U_L, U_S, U_R)$ is represented as a structure array of $U$ with three fields. $U_L$, $U_S$ and $U_R$ are represented with matrices <code>U.L</code> <code>U.S</code> and <code>U.R</code> of size $m\times k$, $k \times k$ and $n \times k$ respectively.</td>
          </tr>
          <tr>
            <td>Ambient space</td>
            <td>$\mathbb{R}^{m\times k}\times \mathbb{R}^{k \times k} \times \mathbb{R}^{n\times k}$</td>
            <td>Points and vectors in the ambient space are, naturally, represented as two matrices of sizes $m\times k$, $k \times k$ and $n\times k$. The Matlab representations are done with a structure array with three fields.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section id="toolset">
      <div class="page-header">
        <h1>Toolset</h1>
      </div>
      <p>The following table shows some of the nontrivial available functions in the structure <code>M</code>. The norm $\|\cdot\|$ refers to the norm in the ambient space, which is the Frobenius norm. The <a
          href="tutorial.html#manifolds">tutorial page</a> gives more details about the functionality implemented by each function.</p>
      <table style="width: 100%;" class="table table-striped table-bordered">
        <thead>
          <tr>
            <td>Name </td>
          <td>Field usage </td>
        <td>Formula </td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Dimension </td>
    <td><code>M.dim() </code></td>
    <td>$\operatorname{dim}\mathcal{M} = (m + n - k)k;$ </td>
</tr>
<tr>
  <td>Metric </td>
<td><code>M.inner(X, U, V) </code></td>
<td>$\langle U, V\rangle_X = \operatorname{trace}(U_L^T V_L)+ \operatorname{trace}(S^{-1} U_S S^{-1} V_S) + \operatorname{trace}(U_R^T V_R)$ </td>
</tr>
<tr>
  <td>Norm </td>
<td><code>M.norm(X, U) </code></td>
<td>$\|U\|_X = \sqrt{\langle U, U \rangle_X}$</td>
</tr>
<tr>
  <td>Horizontal space projector </td>
<td><code>M.proj(Y, H) </code></td>
<td>$P_X(H) = (H_L - L\ {\rm sym}(L^T H_L) - L\Omega,H_S - {\rm skew}(H_S) - S\Omega + \Omega S, H_R - R\ {\rm sym}(R^T H_R) - R \Omega)$, where the structure array <code>H</code> represents a vector in the ambient space with three fields. $\Omega$ is the unique solution to the <a
    href="http://en.wikipedia.org/wiki/Lyapunov_equation">Lyapunov equation</a>, $\Omega S^2 + S^2 \Omega = S({\rm skew}(L^T H_L) -2 {\rm skew}(S^{-1} {\rm sym}(H_S) ) + {\rm skew}(R^T H_R) ) S$.<br>
  Here ${\rm sym}(A) = (A + A^T)/2$ and ${\rm sym}(A) = (A - A^T) /2$ are operators that extract the symmetric and skew-symmetric parts of a square matrix. </td>
</tr>
<tr>
  <td>Euclidean to Riemannian gradient</td>
  <td><nobr><code>M.egrad2rgrad(X, egrad)</code></nobr></td>
  <td>$\operatorname{grad} f(L, S, R) = (\nabla_Lf(X) - L\ {\rm sym}(L^T \nabla_Lf(X) ), S \ {\rm sym}(\nabla_S f(X))\ S , \nabla_R f(X) - R\ {\rm sym}(R^T \nabla_R f(X)))$, where <code>egrad</code> represents the Euclidean gradient as a structure array with three fields corresponding to the partial derivatives $(\nabla _L f(X), \nabla _S f(X), \nabla_R f(X))$, which is a vector in the ambient space. </td>
</tr>
<tr>
  <td>Euclidean to Riemannian Hessian</td>
  <td><nobr><code>M.ehess2rhess(X, egrad, ehess, U)</code></nobr> </td>
<td>$\operatorname{Hess} f(X)[U] = P_X(T_L, T_S, T_R)$, where \[
  \begin{array}{lll}
  T_L = &amp; (\nabla^2 f(X)[U])_L - U_L\ {\rm sym} (L^T \nabla _L f(X)) - L\ {\rm sym}(L^T (\nabla^2 f(X)[U])_L) \\
  &amp; - L\ {\rm sym}(L^T U_L\ {\rm sym} (L^T \nabla _L f(X)) )\\
  T_S = &amp; S \ {\rm sym}( (\nabla^2 f(X)[U])_S ) S + \ {\rm sym}(U_S\ {\rm sym}( \nabla _S f(X)) S ) \\ T_R = &amp; (\nabla^2 f(X)[U])_R - U_R\ {\rm sym} (R^T \nabla _R f(X)) - R\ {\rm sym}(R^T (\nabla^2 f(X)[U])_R) \\
  &amp; - R\ {\rm sym}(R^T U_R\ {\rm sym} (R^T \nabla _R f(X)) )\\
  \end{array}
  \]
  Here ${\rm sym}(\cdot)$ extracts the symmetric part of a square matrix, i.e., ${\rm sym}(A) = (A + A^T)/2$. <code>egrad</code> represents the Euclidean gradient $(\nabla _L f(X),\nabla _S f(X), \nabla _R f(X))$ and <code>ehess</code> represents the Euclidean Hessian $ \nabla^2 f(X)[U] = ({(\nabla^2 f(X)[U])_L}, {(\nabla^2 f(X)[U])_S}, (\nabla^2 f(X)[U])_R )$, both being vectors in the ambient space. $P_X(\cdot)$ is the horizonatal space projector.</td>
</tr>
<tr>
  <td>Retraction </td>
<td><code>M.retr(X, U, t) </code></td>
<td>$\operatorname{Retr}_X(tU) = ( {\rm uf}(L + tU_L), S^{\frac{1}{2}}\ {\rm Exp}(t S^{-\frac{1}{2}} U_S S^{-\frac{1}{2}}) S^{\frac{1}{2}} ,{\rm uf}(R + tU_R))$. <br>
  Here ${\rm uf}(\cdot)$ extracts the orthogonal factor of a matrix, i.e., <br>
  $ {\rm uf}(A) = A(A^T A)^{- \frac{1}{2}}$ </td>
</tr>
<tr>
  <td>Random point </td>
<td><code>M.rand() </code></td>
<td>Returns a point uniformly at random w.r.t. the natural measure as follows: generate $L$, $S$ and $R$ with i.i.d. normal entries; return $(L, S, R)$. </td>
</tr>
<tr>
  <td>Random vector </td>
<td><code>M.randvec(X) </code></td>
<td>Returns a tangent vector at $X$ with uniformly random direction, obtained as follows: generate $H_L$, $H_S$ and $H_R$ with i.i.d. normal entries; return $P_X(H)/\|P_X(H)\|_X$. </td>
</tr>
<tr>
  <td>Vector transport </td>
<td><code>M.transp(X, Y, U) </code></td>
<td>$\operatorname{Transp}_{Y\leftarrow X}(U) = P_Y (U)$, where $U$ is a tangent vector at $X$ that is transported to the tangent space at $Y$. </td>
</tr>
</tbody>
</table>
<p></p>
</section>
<section id="differentials">
  <div class="page-header">
    <h1>Example</h1>
  </div>
  <p>This is an example of low-rank matrix approximation. Let $A\in\mathbb{R}^{m\times n}$ be a low-rank matrix. Rank-$k$ matrix approximation amounts to minimize the following cost function:</p>
  <p>$$\phi(X) =0.5 \| A - X \|_F ^2,$$</p>
  <p>such that $X \in \mathbb{R}_k ^{m \times n}$. $X$ is factorized as $LSR ^T$ with $L \in {\rm St}(k, m)$, $S \in S_{++}(k)$ and $R \in {\rm St}(k, n)$. The function $f:{\rm St}(k, m)\times S_{++}(k) \times {\rm St}(k, m) \rightarrow \mathbb{R}$ is defined as $f(L,S, R) =0.5 \| A - LSR^T \|_F ^2 $. Compute the Euclidean gradient and Hessian of $f$:</p>
  <p>$$\nabla _L f(X) = (LSR^T - A)RS^T,$$</p>
  <p>$$\nabla _S f(X) = L^T (LSR^T - A) R,$$</p>
  <p>$$\nabla _R f(X) = (LSR^T - A)^T LS,$$</p>
  <p>$$(\nabla^2 f(X)[U])_L = (U_L SR^T + L U_S R ^T + LSU_R^T ) RS^T + (LSR^T - A) (U_R S^T + R U_S^T), $$</p>
  <p>$$(\nabla^2 f(X)[U])_S = L^T (U_L SR^T + L U_S R ^T + LSU_R^T ) R + U_L^T (LSR^T - A) R + L^T (LSR^T - A)U_R, $$</p>
  <p>$$(\nabla^2 f(X)[U])_R = (U_L S R^T + L U_S R ^T + LSU_R^T )^T LS + (LSR^T - A)^T (U_L S + L U_S).$$</p>
  <p>The Riemannian gradient and Hessian are obtained by applying the <code>M.egrad2rgrad</code> and <code>M.ehess2rhess</code> operators. Notice that there is no need to compute these explicitly: it suffices to write code for the Euclidean quantities and to apply the conversion tools on them to obtain the Riemannian quantities, as in the following code:</p>
  <pre class="prettyprint lang-matlab linenums">import manopt.manifolds.fixedrank.*;<br>import manopt.tools.*;<br><br>% Generate the problem data. 

% Problem
m = 1000;
n = 500;
k = 5;
B_L = randn(m, k);
B_R = randn(n, k);
A = B_L*B_R';

% Create the problem structure.
manifold = fixedrankfactory_3factors(m,n,k);
problem.M = manifold;

% Define the problem cost function and its gradient.<br>
problem.cost = @cost;
    function f = cost(X)
        f = .5*norm(X.L*X.S*X.R' - A, 'fro')^2;
    end

problem.grad = @(X) problem.M.egrad2rgrad(X, egrad(X)); 
    function g = egrad(X)
        P = (X.L*X.S*X.R' - A);
        g.L= P*X.R*X.S';
        g.S = X.L'*P*X.R;        
        g.R = P'*X.L*X.S;
    end

problem.hess = @(X, U) problem.M.ehess2rhess(X, egrad(X), ehess(X, U), U); 
    function Hess = ehess(X, eta)
        P = (X.L*X.S*X.R' - A);
        Pdot  = (eta.L*X.S*X.R' + X.L*eta.S*X.R' + X.L*X.S*eta.R');
        
        Hess.L = Pdot*X.R*X.S' + P*(X.R*eta.S' + eta.R*X.S');
        Hess.R = Pdot'*X.L*X.S + P'*(X.L*eta.S + eta.L*X.S);
        Hess.S = X.L'*Pdot*X.R + eta.L'*P*X.R + X.L'*P*eta.R;
     end


% Numerically check the differentials.
checkgradient(problem); pause;
checkhessian(problem); pause;

</pre> </section>
<section id="references">
  <div class="page-header">
    <h1>References</h1>
  </div>
  <p>For theory on Riemannian submanifolds, see [AMS08], section 3.6.1 (first-order derivatives) and section 5.3.3 (second-order derivatives, i.e., connections).</p>
  <p>For content specifically about the sphere, see [AMS08] and look up examples 3.5.1 (tangent space), 3.6.1 (metric, projector), 4.1.1 (retraction), 5.3.1 (connection), 5.4.1 (exponential map, i.e., geodesics) and 8.1.1 (parallel translation, not implemented), 8.1.4 and 8.1.7 (vector transport).</p>
  <p>[AMS08] P.-A. Absil, R. Mahony and R. Sepulchre, <a target="_blank"
      href="http://press.princeton.edu/chapters/absil/">Optimization Algorithms on Matrix Manifolds</a>, Princeton University Press, 2008.</p>
</section>
<section id="examples">
  <div class="page-header">
    <h1>List of examples</h1>
  </div>
  <p>The first example on the <a href="tutorial.html">tutorial page</a> is an example on the sphere. Section 6.4.1 in [AMS08] also gives an example of second-order optimization on the sphere.</p>
  <p>We are still working on building a collection of examples for Manopt. The relevant ones will be referenced here when the time comes.</p>
</section>
</div>
</div>
</div>
<!-- /container -->
<!-- Le javascript ================================================== -->
<script type="text/javascript" src="bootstrap/js/jquery.min.js">
	</script>
<script type="text/javascript" src="bootstrap/js/bootstrap.js">
	</script>
<script type="text/javascript" src="bootstrap/js/prettify.js">
	</script>
<script type="text/javascript" src="bootstrap/js/lang-matlab.js">
	</script>
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/javascript">

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-37402854-1']);
_gaq.push(['_trackPageview']);

(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
 })();
</script>
</body>
</html>
