<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of shapefit_smoothed</title>
  <meta name="keywords" content="shapefit_smoothed">
  <meta name="description" content="ShapeFit formulation for sensor network localization from pair directions">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">examples</a> &gt; shapefit_smoothed.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for examples&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>shapefit_smoothed
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>ShapeFit formulation for sensor network localization from pair directions</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [T_hub, T_lsq, T_cvx] = shapefit_smoothed(V, J) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ShapeFit formulation for sensor network localization from pair directions

 function [T_hub, T_lsq, T_cvx] = shapefit_smoothed(V, J)

 This example in based on the paper http://arxiv.org/abs/1506.01437:
 ShapeFit: Exact location recovery from corrupted pairwise directions, 2015
 by Paul Hand, Choongbum Lee and Vladislav Voroninski.

 The problem is the following: there are n points t_1, ..., t_n in R^d
 which need to be estimated (localized). To this end, we are given
 measurements of some of the pairwise directions,
 v_ij = (t_i - t_j) / norm(t_i - t_j) + noise.
 Assume there are m such pairwise measurements, defining a graph with m
 edges over n nodes. J is the signed incidence matrix of this graph (see
 in code). To build J from lists I, J in R^m of nodes, use:
 J = sparse([I ; J], [(1:m)' ; (1:m)'], [ones(m, 1), -ones(m, 1)], n, m, 2*m);

 The measurements are arranged in the matrix V of size d x m. From V, we
 attempt to estimate t_1, ..., t_n, arranged in T, a matrix of size d x n.
 The estimation can only be done up to translation and scaling. The
 returned T's are centered: the columns sum to zero.

 ShapeFit is a formulation of this estimation problem which is robust to
 outliers. It is a nonsmooth, convex optimization problem over an affine
 space, i.e., a linear manifold. We smooth the cost using the pseudo-Huber
 loss cost and solve the problem using Manopt. This requires two
 ingredients: (1) a factory to describe the affine space, see
 shapefitfactory; (2) defining the cost and its derivative, and minimizing
 it while progressively tightening the smooth approximation (with
 warm-start).

 Simply run the example to see the results on random data. It compares the
 smoothed ShapeFit formulation against a least-squares formulation, when
 the measurements include outliers. See in code to vary the noise
 parameters, dimension d, number of nodes n, number of measurements m, ...

 Note: since the problem is convex, this returns the global optimum.
 This example also illustrates the use of Manopt for optimization under
 linear constraints: admittedly a simple subcase of optimization on
 manifolds.


 See also: shapefitfactory</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../manopt/manifolds/euclidean/shapefitfactory.html" class="code" title="function M = shapefitfactory(VJt)">shapefitfactory</a>	Linear manifold structure for optimization over the ShapeFit search space</li><li><a href="../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>	Riemannian trust-regions solver for optimization on manifolds.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function AT = A(T)</a></li><li><a href="#_sub2" class="code">function T_cvx = shapefit_cvx(V, J)</a></li><li><a href="#_sub3" class="code">function [I, J, A] = erdosrenyi(n, p)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [T_hub, T_lsq, T_cvx] = shapefit_smoothed(V, J)</a>
0002 <span class="comment">% ShapeFit formulation for sensor network localization from pair directions</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function [T_hub, T_lsq, T_cvx] = shapefit_smoothed(V, J)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% This example in based on the paper http://arxiv.org/abs/1506.01437:</span>
0007 <span class="comment">% ShapeFit: Exact location recovery from corrupted pairwise directions, 2015</span>
0008 <span class="comment">% by Paul Hand, Choongbum Lee and Vladislav Voroninski.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% The problem is the following: there are n points t_1, ..., t_n in R^d</span>
0011 <span class="comment">% which need to be estimated (localized). To this end, we are given</span>
0012 <span class="comment">% measurements of some of the pairwise directions,</span>
0013 <span class="comment">% v_ij = (t_i - t_j) / norm(t_i - t_j) + noise.</span>
0014 <span class="comment">% Assume there are m such pairwise measurements, defining a graph with m</span>
0015 <span class="comment">% edges over n nodes. J is the signed incidence matrix of this graph (see</span>
0016 <span class="comment">% in code). To build J from lists I, J in R^m of nodes, use:</span>
0017 <span class="comment">% J = sparse([I ; J], [(1:m)' ; (1:m)'], [ones(m, 1), -ones(m, 1)], n, m, 2*m);</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% The measurements are arranged in the matrix V of size d x m. From V, we</span>
0020 <span class="comment">% attempt to estimate t_1, ..., t_n, arranged in T, a matrix of size d x n.</span>
0021 <span class="comment">% The estimation can only be done up to translation and scaling. The</span>
0022 <span class="comment">% returned T's are centered: the columns sum to zero.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% ShapeFit is a formulation of this estimation problem which is robust to</span>
0025 <span class="comment">% outliers. It is a nonsmooth, convex optimization problem over an affine</span>
0026 <span class="comment">% space, i.e., a linear manifold. We smooth the cost using the pseudo-Huber</span>
0027 <span class="comment">% loss cost and solve the problem using Manopt. This requires two</span>
0028 <span class="comment">% ingredients: (1) a factory to describe the affine space, see</span>
0029 <span class="comment">% shapefitfactory; (2) defining the cost and its derivative, and minimizing</span>
0030 <span class="comment">% it while progressively tightening the smooth approximation (with</span>
0031 <span class="comment">% warm-start).</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% Simply run the example to see the results on random data. It compares the</span>
0034 <span class="comment">% smoothed ShapeFit formulation against a least-squares formulation, when</span>
0035 <span class="comment">% the measurements include outliers. See in code to vary the noise</span>
0036 <span class="comment">% parameters, dimension d, number of nodes n, number of measurements m, ...</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% Note: since the problem is convex, this returns the global optimum.</span>
0039 <span class="comment">% This example also illustrates the use of Manopt for optimization under</span>
0040 <span class="comment">% linear constraints: admittedly a simple subcase of optimization on</span>
0041 <span class="comment">% manifolds.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% See also: shapefitfactory</span>
0045 
0046 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0047 <span class="comment">% Original author: Nicolas Boumal, June 18, 2015.</span>
0048 <span class="comment">% Contributors:</span>
0049 <span class="comment">% Change log:</span>
0050 
0051 
0052     <span class="comment">% DATA GENERATION</span>
0053     <span class="comment">%</span>
0054     <span class="comment">% If no inputs are specified, generate some random data for</span>
0055     <span class="comment">% illustration purposes.</span>
0056     <span class="keyword">if</span> nargin == 0
0057 
0058         <span class="comment">% We estimate n points in R^d</span>
0059         d =   2;
0060         n = 500;
0061 
0062         <span class="comment">% Generic useful functions</span>
0063         center_cols = @(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>) bsxfun(@minus, <a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>, mean(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>, 2));
0064         normalize_cols = @(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>) bsxfun(@times, <a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>, 1./sqrt(sum(A.^2, 1)));
0065         sqnorm_cols = @(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>) sum(A.^2, 1);
0066 
0067         <span class="comment">% Those points are the columns of T : they are what we need to</span>
0068         <span class="comment">% estimate, up to scaling and translation. We center T for</span>
0069         <span class="comment">% convenience.</span>
0070         T_tru = center_cols(rand(d, n));
0071 
0072         <span class="comment">% We get a measurement of some pairs of relative directions.</span>
0073         <span class="comment">% Which pairs is encoded in this graph, with J being the (signed,</span>
0074         <span class="comment">% transposed) incidence matrix. J is n x m, sparse.</span>
0075         <span class="comment">% There are roughly edge_fraction * n * (n+1) / 2 measurements.</span>
0076         edge_fraction = 0.1;
0077         [ii, jj] = <a href="#_sub3" class="code" title="subfunction [I, J, A] = erdosrenyi(n, p)">erdosrenyi</a>(n, edge_fraction);
0078         m = length(ii);
0079         J = sparse([ii ; jj], [(1:m)' ; (1:m)'], <span class="keyword">...</span>
0080                    [ones(m, 1), -ones(m, 1)], n, m, 2*m);
0081 
0082         <span class="comment">% The measurements give the directions from one point to another.</span>
0083         <span class="comment">% That is: we get the position difference, normalized. Here, with</span>
0084         <span class="comment">% Gaussian noise. Least-squares will be well-suited for this.</span>
0085         sigma = .0;
0086         V = normalize_cols(T_tru*J + sigma*randn(d, m)); <span class="comment">% d x m</span>
0087 
0088         <span class="comment">% Outliers: we replace some of the direction measurements by</span>
0089         <span class="comment">% uniformly random unit-norm vectors.</span>
0090         outlier_fraction = .3;
0091         outliers = rand(1, m) &lt; outlier_fraction;
0092         V(:, outliers) = normalize_cols(randn(d, sum(outliers)));
0093         
0094     <span class="keyword">end</span> <span class="comment">% done generating random data</span>
0095     
0096     
0097     
0098     
0099     
0100     [d, m] = size(V);
0101     n = size(J, 1);
0102     assert(size(J, 2) == m, <span class="string">'J must be n x m, with V of size d x m.'</span>);
0103 
0104     VJt = full(V*J');
0105 
0106     <span class="comment">% This &quot;manifold&quot; describes the Euclidean space of matrices T of size</span>
0107     <span class="comment">% d x n such that &lt;VJt, T&gt; = 1 and T has centered columns: T1 = 0.</span>
0108     problem.M = <a href="../manopt/manifolds/euclidean/shapefitfactory.html" class="code" title="function M = shapefitfactory(VJt)">shapefitfactory</a>(VJt);
0109 
0110     <span class="comment">% This linear operator computes the orthogonal projection of each</span>
0111     <span class="comment">% difference ti - tj on the orthogonal space to v_ij.</span>
0112     <span class="comment">% If the alignment is compatible with the data, then this is zero.</span>
0113     <span class="comment">% A(T) is a d x m matrix.</span>
0114     <a name="_sub1" href="#_subfunctions" class="code">function AT = A(T)</a>
0115         TJ = T*J;
0116         AT = TJ - bsxfun(@times, V, sum(V .* TJ, 1));
0117     <span class="keyword">end</span>
0118 
0119     <span class="comment">% Need the adjoint of A, too. Input is d x m, output is d x n.</span>
0120     Astar = @(W) (W - bsxfun(@times, V, sum(V.*W, 1)))*J';
0121 
0122     
0123     
0124     <span class="comment">% LEAST-SQUARES</span>
0125     <span class="comment">%</span>
0126     <span class="comment">% First, work with a least-squares formulation of the problem.</span>
0127     <span class="comment">% That is, we minimize a (very nice) convex cost over an affine space.</span>
0128     <span class="comment">% Since the smooth solvers in Manopt converge to critical points, this</span>
0129     <span class="comment">% means they converge to global optimizers.</span>
0130     problem.cost  = @(T) 0.5*norm(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>(T), <span class="string">'fro'</span>)^2;
0131     problem.egrad = @(T) Astar(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>(T));
0132     problem.ehess = @(T, Tdot) Astar(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>(Tdot));
0133 
0134     T_lsq = <a href="../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>(problem);
0135     
0136 
0137     
0138     <span class="comment">% PSEUDO-HUBER SMOOTHED SHAPEFIT</span>
0139     <span class="comment">%</span>
0140     <span class="comment">% Now solve the same, but with a pseudo-Huber loss instead of</span>
0141     <span class="comment">% least-squares.</span>
0142     <span class="comment">% We iteratively sharpen the Huber function, i.e., reduce delta.</span>
0143     <span class="comment">% It is important to warm start in such a fashion: trying to optimize</span>
0144     <span class="comment">% with a random initial guess and a very small delta is typically slow.</span>
0145     <span class="comment">% How fast one should decrease delta, and how accurately one should</span>
0146     <span class="comment">% optimize at each intermediate stage, is open for research.</span>
0147     delta = 1;
0148     T_hub = []; <span class="comment">% We could use T_lsq as initial guess, too.</span>
0149     problem = rmfield(problem, <span class="string">'ehess'</span>);
0150     warning(<span class="string">'off'</span>, <span class="string">'manopt:getHessian:approx'</span>);
0151     <span class="keyword">for</span> iter = 1 : 12
0152         
0153         delta = delta / 2;
0154         
0155         h = @(x2) sqrt(x2 + delta^2) - delta; <span class="comment">% pseudo-Huber loss</span>
0156 
0157         problem.cost  = @(T) sum(h(sqnorm_cols(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>(T))));
0158         problem.egrad = @(T) Astar(bsxfun(@times, <a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>(T), <span class="keyword">...</span>
0159                                     1./sqrt(sqnorm_cols(<a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a>(T)) + delta^2)));
0160 
0161         <span class="comment">% Solve, using the previous solution as initial guess.</span>
0162         T_hub = <a href="../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>(problem, T_hub);
0163         
0164     <span class="keyword">end</span>
0165     
0166     
0167     
0168     <span class="comment">% CVX SHAPEFIT</span>
0169     <span class="comment">%</span>
0170     <span class="comment">% Actual ShapeFit cost (nonsmooth), with CVX.</span>
0171     <span class="comment">% You can get CVX from http://cvxr.com/.</span>
0172     <span class="keyword">if</span> exist(<span class="string">'cvx_version'</span>, <span class="string">'file'</span>)
0173         T_cvx = <a href="#_sub2" class="code" title="subfunction T_cvx = shapefit_cvx(V, J)">shapefit_cvx</a>(V, J);
0174     <span class="keyword">else</span>
0175         T_cvx = NaN(d, n);
0176     <span class="keyword">end</span>
0177     
0178     
0179     
0180     <span class="comment">% VISUALIZATION</span>
0181     <span class="comment">%</span>
0182     <span class="comment">% If T_true is available, for display, we scale the estimators to match</span>
0183     <span class="comment">% the norm of the target. The scaling factor is obtained by minimizing</span>
0184     <span class="comment">% the norm of the discrepancy : norm(T_tru - scale*T_xxx, 'fro').</span>
0185     <span class="comment">% A plot is produced if d is 2 or 3.</span>
0186     <span class="keyword">if</span> exist(<span class="string">'T_tru'</span>, <span class="string">'var'</span>) &amp;&amp; (d == 2 || d == 3)
0187         
0188         T_lsq = T_lsq * trace(T_tru'*T_lsq) / norm(T_lsq, <span class="string">'fro'</span>)^2;
0189         T_hub = T_hub * trace(T_tru'*T_hub) / norm(T_hub, <span class="string">'fro'</span>)^2;
0190         T_cvx = T_cvx * trace(T_tru'*T_cvx) / norm(T_cvx, <span class="string">'fro'</span>)^2;
0191 
0192     
0193         <span class="keyword">switch</span> d
0194             <span class="keyword">case</span> 2
0195                 plot(T_tru(1, :), T_tru(2, :), <span class="string">'bo'</span>, <span class="keyword">...</span>
0196                      T_lsq(1, :), T_lsq(2, :), <span class="string">'rx'</span>, <span class="keyword">...</span>
0197                      T_hub(1, :), T_hub(2, :), <span class="string">'k.'</span>, <span class="keyword">...</span>
0198                      T_cvx(1, :), T_cvx(2, :), <span class="string">'g.'</span>);
0199             <span class="keyword">case</span> 3
0200                 plot3(T_tru(1, :), T_tru(2, :), T_tru(3, :), <span class="string">'bo'</span>, <span class="keyword">...</span>
0201                       T_lsq(1, :), T_lsq(2, :), T_lsq(3, :), <span class="string">'rx'</span>, <span class="keyword">...</span>
0202                       T_hub(1, :), T_hub(2, :), T_hub(3, :), <span class="string">'k.'</span>, <span class="keyword">...</span>
0203                       T_cvx(1, :), T_cvx(2, :), T_cvx(3, :), <span class="string">'g.'</span>);
0204         <span class="keyword">end</span>
0205 
0206         legend(<span class="string">'ground truth'</span>, <span class="string">'least squares'</span>, <span class="keyword">...</span>
0207                sprintf(<span class="string">'pseudo-huber, \\delta = %.1e'</span>, delta), <span class="keyword">...</span>
0208                <span class="string">'CVX ShapeFit'</span>);
0209            
0210         title(sprintf([<span class="string">'ShapeFit problem : d = %d, n = %d, edge '</span> <span class="keyword">...</span>
0211                        <span class="string">'fraction = %.2g, sigma = %.2g, outlier '</span> <span class="keyword">...</span>
0212                        <span class="string">'fraction = %.2g'</span>], d, n, edge_fraction, sigma, <span class="keyword">...</span>
0213                        outlier_fraction));
0214         axis equal;
0215     
0216     <span class="keyword">end</span>
0217 
0218 <span class="keyword">end</span>
0219 
0220 
0221 <span class="comment">% If CVX is available, it can be used to solve the nonsmooth problem</span>
0222 <span class="comment">% directly, very elegantly.</span>
0223 <a name="_sub2" href="#_subfunctions" class="code">function T_cvx = shapefit_cvx(V, J)</a>
0224     d = size(V, 1);
0225     n = size(J, 1); <span class="comment">%#ok&lt;NASGU&gt;</span>
0226     VJt = full(V*J');
0227     cvx_begin
0228         variable T_cvx(d, n)
0229         <span class="comment">% We want to minimize this:</span>
0230         <span class="comment">% minimize sum( norms( A(T_cvx), 2, 1 ) )</span>
0231         <span class="comment">% But unfortunately, CVX doesn't handle bsxfun. Instead, we use</span>
0232         <span class="comment">% repmat, which is slower, and hence hurts the comparison in</span>
0233         <span class="comment">% disfavor of CVX.</span>
0234         minimize sum( norms( T_cvx*J - V .* repmat(sum(V .* (T_cvx*J), 1), [d, 1])  , 2, 1 ) )
0235         sum(T_cvx, 2) == zeros(d, 1); <span class="comment">%#ok&lt;NODEF,EQEFF&gt;</span>
0236         VJt(:).' * T_cvx(:) == 1; <span class="comment">%#ok&lt;EQEFF&gt;</span>
0237     cvx_end
0238 <span class="keyword">end</span>
0239 
0240 
0241 <a name="_sub3" href="#_subfunctions" class="code">function [I, J, A] = erdosrenyi(n, p)</a>
0242 <span class="comment">% Generate a random Erdos-Renyi graph with n nodes and edge probability p.</span>
0243 <span class="comment">%</span>
0244 <span class="comment">% [I, J, A] = erdosrenyi(n, p)</span>
0245 <span class="comment">%</span>
0246 <span class="comment">% Returns a list of edges (I(k), J(k)) for a random, undirected Erdos-Renyi</span>
0247 <span class="comment">% graph with n nodes and edge probability p. A is the adjacency matrix.</span>
0248 <span class="comment">%</span>
0249 <span class="comment">% I(k) &lt;= J(k) for all k, i.e., all(I&lt;=J) is true.</span>
0250 
0251     X = rand(n);
0252     mask = X &lt;= p;
0253     X( mask) = 1;
0254     X(~mask) = 0;
0255     X = triu(X, 1);
0256 
0257     <span class="comment">% A is the adjacency matrix</span>
0258     <a href="#_sub1" class="code" title="subfunction AT = A(T)">A</a> = X + X';
0259     
0260     [I, J] = find(X);
0261 
0262 <span class="keyword">end</span>
0263</pre></div>
<hr><address>Generated on Thu 02-Jul-2015 18:56:12 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>