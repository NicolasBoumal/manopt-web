<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of low_rank_tensor_completion_embedded</title>
  <meta name="keywords" content="low_rank_tensor_completion_embedded">
  <meta name="description" content="Given partial observation of a low rank tensor (possibly including noise),">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">examples</a> &gt; low_rank_tensor_completion_embedded.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for examples&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>low_rank_tensor_completion_embedded
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Given partial observation of a low rank tensor (possibly including noise),</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function low_rank_tensor_completion_embedded() </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Given partial observation of a low rank tensor (possibly including noise),
 attempts to complete it.

 function low_rank_tensor_completion_embedded()

 NOTE: Tensor Toolbox version 2.6 or higher is required for this factory:
 see https://www.tensortoolbox.org/ or https://gitlab.com/tensors/tensor_toolbox

 This example demonstrates how to use the geometry factory for the
 embedded submanifold of fixed-rank tensors in Tucker format:
 fixedranktensorembeddedfactory.

 This geometry is described in the article
 &quot;A Riemannian trust-region method for low-rank tensor completion&quot;
 Gennadij Heidel and Volker Schulz, doi:10.1002/nla.2175.

 This can be a starting point for many optimization problems of the form:

 minimize f(X) such that rank(X) = [r1 ... rd], size(X) = [n1 ... nd].

 Important: to keep this example short, the code for the cost function,
 gradient and Hessian do not properly exploit sparsity of the
 observations, which leads to significant slow-downs for large tensors.
 This example file should be considered a starting point for more
 sophisticated implementations.

 Input:  None. This example file generates random data with noise.
 
 Output: None.

 Please cite the Manopt and Matlab Tensor Toolbox papers as well as the
 research paper:
     @Article{heidel2018riemannian,
       Title   = {A {R}iemannian trust-region method for low-rank tensor completion},
       Author  = {G. Heidel and V. Schulz},
       Journal = {Numerical Linear Algebra with Applications},
       Year    = {2018},
       Volume  = {23},
       Number  = {6},
       Pages   = {e1275},
       Doi     = {10.1002/nla.2175}
     }

 See also: fixedranktensorembeddedfactory</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../manopt/core/getGradient.html" class="code" title="function grad = getGradient(problem, x, storedb, key)">getGradient</a>	Computes the gradient of the cost function at x.</li><li><a href="../manopt/manifolds/fixedranktensors/fixedranktensorembeddedfactory.html" class="code" title="function M = fixedranktensorembeddedfactory(tensor_size, tensor_rank)">fixedranktensorembeddedfactory</a>	Manifold of tensors with fixed multilinear rank in Tucker format</li><li><a href="../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>	Riemannian trust-regions solver for optimization on manifolds.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [f, store] = cost(X, store)</a></li><li><a href="#_sub2" class="code">function [g, store] = egrad(X, store)</a></li><li><a href="#_sub3" class="code">function H = ehess(X, eta)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function low_rank_tensor_completion_embedded()</a>
0002 <span class="comment">% Given partial observation of a low rank tensor (possibly including noise),</span>
0003 <span class="comment">% attempts to complete it.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% function low_rank_tensor_completion_embedded()</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% NOTE: Tensor Toolbox version 2.6 or higher is required for this factory:</span>
0008 <span class="comment">% see https://www.tensortoolbox.org/ or https://gitlab.com/tensors/tensor_toolbox</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% This example demonstrates how to use the geometry factory for the</span>
0011 <span class="comment">% embedded submanifold of fixed-rank tensors in Tucker format:</span>
0012 <span class="comment">% fixedranktensorembeddedfactory.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% This geometry is described in the article</span>
0015 <span class="comment">% &quot;A Riemannian trust-region method for low-rank tensor completion&quot;</span>
0016 <span class="comment">% Gennadij Heidel and Volker Schulz, doi:10.1002/nla.2175.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% This can be a starting point for many optimization problems of the form:</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% minimize f(X) such that rank(X) = [r1 ... rd], size(X) = [n1 ... nd].</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% Important: to keep this example short, the code for the cost function,</span>
0023 <span class="comment">% gradient and Hessian do not properly exploit sparsity of the</span>
0024 <span class="comment">% observations, which leads to significant slow-downs for large tensors.</span>
0025 <span class="comment">% This example file should be considered a starting point for more</span>
0026 <span class="comment">% sophisticated implementations.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% Input:  None. This example file generates random data with noise.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Output: None.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% Please cite the Manopt and Matlab Tensor Toolbox papers as well as the</span>
0033 <span class="comment">% research paper:</span>
0034 <span class="comment">%     @Article{heidel2018riemannian,</span>
0035 <span class="comment">%       Title   = {A {R}iemannian trust-region method for low-rank tensor completion},</span>
0036 <span class="comment">%       Author  = {G. Heidel and V. Schulz},</span>
0037 <span class="comment">%       Journal = {Numerical Linear Algebra with Applications},</span>
0038 <span class="comment">%       Year    = {2018},</span>
0039 <span class="comment">%       Volume  = {23},</span>
0040 <span class="comment">%       Number  = {6},</span>
0041 <span class="comment">%       Pages   = {e1275},</span>
0042 <span class="comment">%       Doi     = {10.1002/nla.2175}</span>
0043 <span class="comment">%     }</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% See also: fixedranktensorembeddedfactory</span>
0046 
0047 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0048 <span class="comment">% Original author: Gennadij Heidel, January 24, 2019.</span>
0049 <span class="comment">% Contributors:</span>
0050 <span class="comment">% Change log:</span>
0051 
0052     <span class="keyword">if</span> ~exist(<span class="string">'tenrand'</span>, <span class="string">'file'</span>)
0053         fprintf(<span class="string">'Tensor Toolbox version 2.6 or higher is required.\n'</span>);
0054         <span class="keyword">return</span>;
0055     <span class="keyword">end</span>
0056 
0057     <span class="comment">% Random data generation with pseudo-random numbers from a</span>
0058     <span class="comment">% uniform distribution on [0, 1].</span>
0059     tensor_dims = [60 40 20];
0060     core_dims = [8 6 5];
0061     total_entries = prod(tensor_dims);
0062     d = length(tensor_dims);
0063     
0064     <span class="comment">% Standard deviation of normally distributed noise.</span>
0065     <span class="comment">% Set sigma to 0 to test the noise-free case.</span>
0066     sigma = 0.1;
0067     
0068     <span class="comment">% Generate a random tensor A of size n1-by-...-by-nd of rank (r1, ..., rd).</span>
0069     U = cell(1, d);
0070     R = cell(1, d);
0071     <span class="keyword">for</span> i = 1:d
0072         [U{i}, R{i}] = qr(randn(tensor_dims(i), core_dims(i)), 0);
0073     <span class="keyword">end</span>
0074 
0075     Z.U = R;
0076     Z.G = tenrand(core_dims);
0077     Core = ttm(Z.G, Z.U);
0078 
0079     Y.U = U;
0080     Y.G = Core;
0081     A = ttm(Core, Y.U);
0082     
0083     <span class="comment">% Add noise to low-rank tensor</span>
0084     A = A + sigma*tensor(randn(tensor_dims));
0085     
0086     
0087     <span class="comment">% Generate a random mask P for observed entries:</span>
0088     <span class="comment">% P(i, j, k) = 1 if the entry (i, j, k) of A is observed,</span>
0089     <span class="comment">%            = 0 otherwise.</span>
0090     fraction = 0.1; <span class="comment">% Fraction of observed entries.</span>
0091     nr = round(fraction * total_entries);
0092     ind = randperm(total_entries);
0093     ind = ind(1 : nr);
0094     P = false(tensor_dims);
0095     P(ind) = true;
0096     <span class="comment">% Hence, we observe the nonzero entries in PA:</span>
0097     P = tensor(P);
0098     PA = P.*A; 
0099     <span class="comment">% Note that an efficient implementation would require evaluating A as a</span>
0100     <span class="comment">% sparse tensor only at the indices of P.</span>
0101 
0102     
0103     
0104     <span class="comment">% Pick the submanifold of tensors of size n1-by-...-by-nd of</span>
0105     <span class="comment">% multilinear rank (r1, ..., rd).</span>
0106     problem.M = <a href="../manopt/manifolds/fixedranktensors/fixedranktensorembeddedfactory.html" class="code" title="function M = fixedranktensorembeddedfactory(tensor_size, tensor_rank)">fixedranktensorembeddedfactory</a>(tensor_dims, core_dims);
0107     
0108     
0109     <span class="comment">% Define the problem cost function.</span>
0110     <span class="comment">% The store structure is used to reduce full tensor evaluations.</span>
0111     <span class="comment">% Again: proper handling of sparse tensors would dramatically reduce</span>
0112     <span class="comment">% the computation time for large tensors. This file only serves as a</span>
0113     <span class="comment">% simple starting point. See help for the Tensor Toolbox regarding</span>
0114     <span class="comment">% sparse tensors. Same comment for gradient and Hessian below.</span>
0115     problem.cost = @<a href="#_sub1" class="code" title="subfunction [f, store] = cost(X, store)">cost</a>;
0116     <a name="_sub1" href="#_subfunctions" class="code">function [f, store] = cost(X, store)</a>
0117         <span class="keyword">if</span> ~isfield(store, <span class="string">'PXmPA'</span>)
0118             Xfull = full(X.X);
0119             store.PXmPA = P.*Xfull - PA;
0120         <span class="keyword">end</span>
0121         f = .5*norm(store.PXmPA)^2;
0122     <span class="keyword">end</span>
0123 
0124     <span class="comment">% Define the Euclidean gradient of the cost function, that is, the</span>
0125     <span class="comment">% gradient of f(X) seen as a function of X without rank restrictions.</span>
0126     problem.egrad =  @<a href="#_sub2" class="code" title="subfunction [g, store] = egrad(X, store)">egrad</a>;
0127     <a name="_sub2" href="#_subfunctions" class="code">function [g, store] = egrad(X, store)</a>
0128         <span class="keyword">if</span> ~isfield(store, <span class="string">'PXmPA'</span>)
0129             Xfull = full(X.X);
0130             store.PXmPA = P.*Xfull - PA;
0131         <span class="keyword">end</span>
0132         g = store.PXmPA;
0133     <span class="keyword">end</span>
0134     
0135     <span class="comment">% Define the Euclidean Hessian of the cost at X along a vector eta.</span>
0136     problem.ehess = @<a href="#_sub3" class="code" title="subfunction H = ehess(X, eta)">ehess</a>;
0137     <a name="_sub3" href="#_subfunctions" class="code">function H = ehess(X, eta)</a>
0138         ambient_H = problem.M.tangent2ambient(X, eta);
0139         H = P.*ambient_H;
0140     <span class="keyword">end</span>
0141     
0142     <span class="comment">% Options</span>
0143     X0 = problem.M.rand();
0144     options.maxiter = 3000;
0145     options.maxinner = 100;
0146     options.maxtime = inf;
0147     options.storedepth = 3;
0148     <span class="comment">% Target gradient norm</span>
0149     options.tolgradnorm = 1e-8*problem.M.norm(X0, <a href="../manopt/core/getGradient.html" class="code" title="function grad = getGradient(problem, x, storedb, key)">getGradient</a>(problem, X0));
0150 
0151     <span class="comment">% Minimize the cost function using Riemannian trust-regions</span>
0152     Xtr = <a href="../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>(problem, X0, options);
0153 
0154     <span class="comment">% Display some quality metrics for the computed solution</span>
0155     Xtrfull = full(Xtr.X);
0156     fprintf(<span class="string">'||X-A||_F / ||A||_F = %g\n'</span>, norm(Xtrfull - A)/norm(A));
0157     fprintf(<span class="string">'||PX-PA||_F / ||PA||_F = %g\n'</span>, norm(P.*Xtrfull - PA)/norm(PA));
0158     
0159 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-May-2020 18:46:12 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>