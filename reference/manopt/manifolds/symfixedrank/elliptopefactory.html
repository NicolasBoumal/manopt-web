<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of elliptopefactory</title>
  <meta name="keywords" content="elliptopefactory">
  <meta name="description" content="Manifold of n-by-n psd matrices of rank k with unit diagonal elements.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">manifolds</a> &gt; <a href="index.html">symfixedrank</a> &gt; elliptopefactory.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\manifolds\symfixedrank&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>elliptopefactory
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Manifold of n-by-n psd matrices of rank k with unit diagonal elements.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function M = elliptopefactory(n, k) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Manifold of n-by-n psd matrices of rank k with unit diagonal elements.

 function M = elliptopefactory(n, k)

 A point X on the manifold is parameterized as YY^T where Y is a matrix of
 size nxk. As such, X is symmetric, positive semidefinite. We restrict to
 full-rank Y's, such that X has rank exactly k. The point X is numerically
 represented by Y (this is more efficient than working with X, which may
 be big). Tangent vectors are represented as matrices of the same size as
 Y, call them Ydot, so that Xdot = Y Ydot' + Ydot Y and diag(Xdot) == 0.
 The metric is the canonical Euclidean metric on Y.
 
 The diagonal constraints on X (X(i, i) == 1 for all i) translate to
 unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.
 The set of such Y's forms the oblique manifold. But because for any
 orthogonal Q of size k, it holds that (YQ)(YQ)' = YY', we &quot;group&quot; all
 matrices of the form YQ in an equivalence class. The set of equivalence
 classes is a Riemannian quotient manifold, implemented here.

 Note that this geometry formally breaks down at rank-deficient Y's.
 This does not appear to be a major issue in practice when optimization
 algorithms converge to rank-deficient Y's, but convergence theorems no
 longer hold. As an alternative, you may use the oblique manifold (it has
 larger dimension, but does not break down at rank drop.)

 The geometry is taken from the 2010 paper:
 M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
 &quot;Low-Rank Optimization on the Cone of Positive Semidefinite Matrices&quot;.
 Paper link: http://www.di.ens.fr/~fbach/journee2010_sdp.pdf
 
 
 Please cite the Manopt paper as well as the research paper:
     @Article{journee2010low,
       Title   = {Low-rank optimization on the cone of positive semidefinite matrices},
       Author  = {Journ{\'e}e, M. and Bach, F. and Absil, P.-A. and Sepulchre, R.},
       Journal = {SIAM Journal on Optimization},
       Year    = {2010},
       Number  = {5},
       Pages   = {2327--2351},
       Volume  = {20},
       Doi     = {10.1137/080731359}
     }
 

 See also: obliquefactory <a href="symfixedrankYYfactory.html" class="code" title="function M = symfixedrankYYfactory(n, k)">symfixedrankYYfactory</a> <a href="spectrahedronfactory.html" class="code" title="function M = spectrahedronfactory(n, k)">spectrahedronfactory</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>	Computes the MD5 hash of input data.</li><li><a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>	Linear combination function for tangent vectors represented as matrices.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/maxcut.html" class="code" title="function [x, cutvalue, cutvalue_upperbound, Y] = maxcut(L, r)">maxcut</a>	Algorithm to (try to) compute a maximum cut of a graph, via SDP approach.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function X = normalize_rows(X)</a></li><li><a href="#_sub2" class="code">function PXH = project_rows(X, H)</a></li><li><a href="#_sub3" class="code">function etaproj = projection(Y, eta)</a></li><li><a href="#_sub4" class="code">function Ynew = retraction(Y, eta, t)</a></li><li><a href="#_sub5" class="code">function Ynew = exponential(Y, eta, t)</a></li><li><a href="#_sub6" class="code">function rgrad = egrad2rgrad(Y, egrad)</a></li><li><a href="#_sub7" class="code">function Hess = ehess2rhess(Y, egrad, ehess, eta)</a></li><li><a href="#_sub8" class="code">function Y = random(n, k)</a></li><li><a href="#_sub9" class="code">function eta = randomvec(Y)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function M = elliptopefactory(n, k)</a>
0002 <span class="comment">% Manifold of n-by-n psd matrices of rank k with unit diagonal elements.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function M = elliptopefactory(n, k)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% A point X on the manifold is parameterized as YY^T where Y is a matrix of</span>
0007 <span class="comment">% size nxk. As such, X is symmetric, positive semidefinite. We restrict to</span>
0008 <span class="comment">% full-rank Y's, such that X has rank exactly k. The point X is numerically</span>
0009 <span class="comment">% represented by Y (this is more efficient than working with X, which may</span>
0010 <span class="comment">% be big). Tangent vectors are represented as matrices of the same size as</span>
0011 <span class="comment">% Y, call them Ydot, so that Xdot = Y Ydot' + Ydot Y and diag(Xdot) == 0.</span>
0012 <span class="comment">% The metric is the canonical Euclidean metric on Y.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% The diagonal constraints on X (X(i, i) == 1 for all i) translate to</span>
0015 <span class="comment">% unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.</span>
0016 <span class="comment">% The set of such Y's forms the oblique manifold. But because for any</span>
0017 <span class="comment">% orthogonal Q of size k, it holds that (YQ)(YQ)' = YY', we &quot;group&quot; all</span>
0018 <span class="comment">% matrices of the form YQ in an equivalence class. The set of equivalence</span>
0019 <span class="comment">% classes is a Riemannian quotient manifold, implemented here.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% Note that this geometry formally breaks down at rank-deficient Y's.</span>
0022 <span class="comment">% This does not appear to be a major issue in practice when optimization</span>
0023 <span class="comment">% algorithms converge to rank-deficient Y's, but convergence theorems no</span>
0024 <span class="comment">% longer hold. As an alternative, you may use the oblique manifold (it has</span>
0025 <span class="comment">% larger dimension, but does not break down at rank drop.)</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% The geometry is taken from the 2010 paper:</span>
0028 <span class="comment">% M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,</span>
0029 <span class="comment">% &quot;Low-Rank Optimization on the Cone of Positive Semidefinite Matrices&quot;.</span>
0030 <span class="comment">% Paper link: http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% Please cite the Manopt paper as well as the research paper:</span>
0034 <span class="comment">%     @Article{journee2010low,</span>
0035 <span class="comment">%       Title   = {Low-rank optimization on the cone of positive semidefinite matrices},</span>
0036 <span class="comment">%       Author  = {Journ{\'e}e, M. and Bach, F. and Absil, P.-A. and Sepulchre, R.},</span>
0037 <span class="comment">%       Journal = {SIAM Journal on Optimization},</span>
0038 <span class="comment">%       Year    = {2010},</span>
0039 <span class="comment">%       Number  = {5},</span>
0040 <span class="comment">%       Pages   = {2327--2351},</span>
0041 <span class="comment">%       Volume  = {20},</span>
0042 <span class="comment">%       Doi     = {10.1137/080731359}</span>
0043 <span class="comment">%     }</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% See also: obliquefactory symfixedrankYYfactory spectrahedronfactory</span>
0047 
0048 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0049 <span class="comment">% Original author: Bamdev Mishra, July 12, 2013.</span>
0050 <span class="comment">% Contributors:</span>
0051 <span class="comment">% Change log:</span>
0052 <span class="comment">%   July 18, 2013 (NB):</span>
0053 <span class="comment">%       Fixed projection operator for rank-deficient Y'Y.</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%   Aug.  8, 2013 (NB):</span>
0056 <span class="comment">%       No longer using nested functions, to aim at Octave compatibility.</span>
0057 <span class="comment">%       Sign error in right hand side of the call to minres corrected.</span>
0058 <span class="comment">%</span>
0059 <span class="comment">%   June 24, 2014 (NB):</span>
0060 <span class="comment">%       Used code snippets from obliquefactory to speed up projection,</span>
0061 <span class="comment">%       retraction, egrad2rgrad and rand: the code now uses bsxfun for this.</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%   April 3, 2015 (NB):</span>
0064 <span class="comment">%       Replaced trace(A'*B) by A(:)'*B(:) : equivalent but faster.</span>
0065 
0066 <span class="comment">% TODO: modify normalize_rows and project_rows to work without transposes.</span>
0067 <span class="comment">% TODO: enhance ehess2rhess to also use bsxfun.</span>
0068     
0069     
0070     <span class="keyword">if</span> ~exist(<span class="string">'lyap'</span>, <span class="string">'file'</span>)
0071         warning(<span class="string">'manopt:elliptopefactory:slowlyap'</span>, <span class="keyword">...</span>
0072                [<span class="string">'The function lyap to solve Lyapunov equations seems not to '</span> <span class="keyword">...</span>
0073                 <span class="string">'be available. This may slow down optimization over this '</span> <span class="keyword">...</span>
0074                 <span class="string">'manifold significantly. lyap is part of the control system '</span> <span class="keyword">...</span>
0075                 <span class="string">'toolbox.'</span>]);
0076     <span class="keyword">end</span>
0077     
0078     
0079     M.name = @() sprintf(<span class="string">'YY'' quotient manifold of %dx%d psd matrices of rank %d with diagonal elements being 1'</span>, n, k);
0080     
0081     M.dim = @() n*(k-1) - k*(k-1)/2; <span class="comment">% Extra -1 is because of the diagonal constraint that</span>
0082     
0083     <span class="comment">% Euclidean metric on the total space</span>
0084     M.inner = @(Y, eta, zeta) eta(:)'*zeta(:);
0085     
0086     M.norm = @(Y, eta) sqrt(M.inner(Y, eta, eta));
0087     
0088     M.dist = @(Y, Z) error(<span class="string">'elliptopefactory.dist not implemented yet.'</span>);
0089     
0090     M.typicaldist = @() 10*k;
0091     
0092     M.proj = @<a href="#_sub3" class="code" title="subfunction etaproj = projection(Y, eta)">projection</a>;
0093     
0094     M.tangent = M.proj;
0095     M.tangent2ambient = @(Y, eta) eta;
0096     
0097     M.retr = @<a href="#_sub4" class="code" title="subfunction Ynew = retraction(Y, eta, t)">retraction</a>;
0098     
0099     M.egrad2rgrad = @<a href="#_sub6" class="code" title="subfunction rgrad = egrad2rgrad(Y, egrad)">egrad2rgrad</a>;
0100     
0101     M.ehess2rhess = @<a href="#_sub7" class="code" title="subfunction Hess = ehess2rhess(Y, egrad, ehess, eta)">ehess2rhess</a>;
0102     
0103     M.exp = @<a href="#_sub5" class="code" title="subfunction Ynew = exponential(Y, eta, t)">exponential</a>;
0104     
0105     <span class="comment">% Notice that the hash of two equivalent points will be different...</span>
0106     M.hash = @(Y) [<span class="string">'z'</span> <a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>(Y(:))];
0107     
0108     M.rand = @() <a href="#_sub8" class="code" title="subfunction Y = random(n, k)">random</a>(n, k);
0109     
0110     M.randvec = @<a href="#_sub9" class="code" title="subfunction eta = randomvec(Y)">randomvec</a>;
0111     
0112     M.lincomb = @<a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>;
0113     
0114     M.zerovec = @(Y) zeros(n, k);
0115     
0116     M.transp = @(Y1, Y2, d) <a href="#_sub3" class="code" title="subfunction etaproj = projection(Y, eta)">projection</a>(Y2, d);
0117     
0118     M.vec = @(Y, u_mat) u_mat(:);
0119     M.mat = @(Y, u_vec) reshape(u_vec, [n, k]);
0120     M.vecmatareisometries = @() true;
0121     
0122 <span class="keyword">end</span>
0123 
0124 <span class="comment">% Given a matrix X, returns the same matrix but with each column scaled so</span>
0125 <span class="comment">% that they have unit 2-norm.</span>
0126 <span class="comment">% See obliquefactory.</span>
0127 <a name="_sub1" href="#_subfunctions" class="code">function X = normalize_rows(X)</a>
0128     X = X';
0129     norms = sqrt(sum(X.^2, 1));
0130     X = bsxfun(@times, X, 1./norms);
0131     X = X';
0132 <span class="keyword">end</span>
0133 
0134 <span class="comment">% Orthogonal projection of each row of H to the tangent space at the</span>
0135 <span class="comment">% corresponding row of X, seen as a point on a sphere.</span>
0136 <span class="comment">% See obliquefactory.</span>
0137 <a name="_sub2" href="#_subfunctions" class="code">function PXH = project_rows(X, H)</a>
0138     X = X';
0139     H = H';
0140     <span class="comment">% Compute the inner product between each vector H(:, i) with its root</span>
0141     <span class="comment">% point X(:, i), that is, X(:, i).' * H(:, i). Returns a row vector.</span>
0142     inners = sum(X.*H, 1);
0143     <span class="comment">% Subtract from H the components of the H(:, i)'s that are parallel to</span>
0144     <span class="comment">% the root points X(:, i).</span>
0145     PXH = H - bsxfun(@times, X, inners);
0146     PXH = PXH';
0147 <span class="keyword">end</span>
0148 
0149 
0150 <span class="comment">% Projection onto the tangent space, i.e., on the tangent space of</span>
0151 <span class="comment">% ||Y(i, :)|| = 1</span>
0152 <a name="_sub3" href="#_subfunctions" class="code">function etaproj = projection(Y, eta)</a>
0153     [unused, k] = size(Y); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0154     eta = <a href="#_sub2" class="code" title="subfunction PXH = project_rows(X, H)">project_rows</a>(Y, eta);
0155 
0156     <span class="comment">% Projection onto the horizontal space</span>
0157     YtY = Y'*Y;
0158     SS = YtY;
0159     AS = Y'*eta - eta'*Y;
0160     <span class="keyword">try</span>
0161         <span class="comment">% This is supposed to work and indeed return a skew-symmetric</span>
0162         <span class="comment">% solution Omega.</span>
0163         Omega = lyap(SS, -AS);
0164     <span class="keyword">catch</span> up <span class="comment">%#ok&lt;NASGU&gt;</span>
0165         <span class="comment">% It can happen though that SS will be rank deficient. The</span>
0166         <span class="comment">% Lyapunov equation we solve still has a unique skew-symmetric</span>
0167         <span class="comment">% solution, but solutions with a symmetric part now also exist,</span>
0168         <span class="comment">% and the lyap function doesn't like that. So we want to</span>
0169         <span class="comment">% extract the minimum norm solution. This is also useful if lyap is</span>
0170         <span class="comment">% not available (it is part of the control system toolbox).</span>
0171         mat = @(x) reshape(x, [k k]);
0172         vec = @(X) X(:);
0173         is_octave = exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>);
0174         <span class="keyword">if</span> ~is_octave
0175             [vecomega, unused] = minres(@(x) vec(SS*mat(x) + mat(x)*SS), vec(AS)); <span class="comment">%#ok&lt;NASGU&gt;</span>
0176         <span class="keyword">else</span>
0177             [vecomega, unused] = gmres(@(x) vec(SS*mat(x) + mat(x)*SS), vec(AS)); <span class="comment">%#ok&lt;NASGU&gt;</span>
0178         <span class="keyword">end</span>
0179         Omega = mat(vecomega);
0180     <span class="keyword">end</span>
0181     <span class="comment">% % Make sure the result is skew-symmetric (does not seem necessary).</span>
0182     <span class="comment">% Omega = (Omega-Omega')/2;</span>
0183     etaproj = eta - Y*Omega;
0184 <span class="keyword">end</span>
0185 
0186 <span class="comment">% Retraction</span>
0187 <a name="_sub4" href="#_subfunctions" class="code">function Ynew = retraction(Y, eta, t)</a>
0188     <span class="keyword">if</span> nargin &lt; 3
0189         t = 1.0;
0190     <span class="keyword">end</span>
0191     Ynew = Y + t*eta;
0192     Ynew = <a href="#_sub1" class="code" title="subfunction X = normalize_rows(X)">normalize_rows</a>(Ynew);
0193 <span class="keyword">end</span>
0194 
0195 <span class="comment">% Exponential map</span>
0196 <a name="_sub5" href="#_subfunctions" class="code">function Ynew = exponential(Y, eta, t)</a>
0197     <span class="keyword">if</span> nargin &lt; 3
0198         t = 1.0;
0199     <span class="keyword">end</span>
0200 
0201     Ynew = <a href="#_sub4" class="code" title="subfunction Ynew = retraction(Y, eta, t)">retraction</a>(Y, eta, t);
0202     warning(<span class="string">'manopt:elliptopefactory:exp'</span>, <span class="keyword">...</span>
0203         [<span class="string">'Exponential for fixed rank spectrahedron '</span> <span class="keyword">...</span>
0204         <span class="string">'manifold not implemented yet. Used retraction instead.\n'</span> <span class="keyword">...</span>
0205         <span class="string">'To disable this warning: warning(''off'', ''manopt:elliptopefactory:exp'')'</span>]);
0206 <span class="keyword">end</span>
0207 
0208 <span class="comment">% Euclidean gradient to Riemannian gradient conversion.</span>
0209 <span class="comment">% We only need the ambient space projection: the remainder of the</span>
0210 <span class="comment">% projection function is not necessary because the Euclidean gradient must</span>
0211 <span class="comment">% already be orthogonal to the vertical space.</span>
0212 <a name="_sub6" href="#_subfunctions" class="code">function rgrad = egrad2rgrad(Y, egrad)</a>
0213     rgrad = <a href="#_sub2" class="code" title="subfunction PXH = project_rows(X, H)">project_rows</a>(Y, egrad);
0214 <span class="keyword">end</span>
0215 
0216 <span class="comment">% Euclidean Hessian to Riemannian Hessian conversion.</span>
0217 <span class="comment">% TODO: speed this function up using bsxfun.</span>
0218 <a name="_sub7" href="#_subfunctions" class="code">function Hess = ehess2rhess(Y, egrad, ehess, eta)</a>
0219     k = size(Y, 2);
0220 
0221     <span class="comment">% Directional derivative of the Riemannian gradient</span>
0222     scaling_grad = sum((egrad.*Y), 2); <span class="comment">% column vector of size n</span>
0223     scaling_grad_repeat = scaling_grad*ones(1, k);
0224 
0225     Hess = ehess - scaling_grad_repeat.*eta;
0226 
0227     scaling_hess = sum((eta.*egrad) + (Y.*ehess), 2);
0228     scaling_hess_repeat = scaling_hess*ones(1, k);
0229     <span class="comment">% directional derivative of scaling_grad_repeat</span>
0230     Hess = Hess - scaling_hess_repeat.*Y;
0231 
0232     <span class="comment">% Project on the horizontal space</span>
0233     Hess = <a href="#_sub3" class="code" title="subfunction etaproj = projection(Y, eta)">projection</a>(Y, Hess);
0234 <span class="keyword">end</span>
0235 
0236 <span class="comment">% Random point generation on the manifold</span>
0237 <a name="_sub8" href="#_subfunctions" class="code">function Y = random(n, k)</a>
0238     Y = randn(n, k);
0239     Y = <a href="#_sub1" class="code" title="subfunction X = normalize_rows(X)">normalize_rows</a>(Y);
0240 <span class="keyword">end</span>
0241 
0242 <span class="comment">% Random vector generation at Y</span>
0243 <a name="_sub9" href="#_subfunctions" class="code">function eta = randomvec(Y)</a>
0244     eta = randn(size(Y));
0245     eta = <a href="#_sub3" class="code" title="subfunction etaproj = projection(Y, eta)">projection</a>(Y, eta);
0246     nrm = norm(eta, <span class="string">'fro'</span>);
0247     eta = eta / nrm;
0248 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 12-Nov-2016 14:11:22 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>