<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sympositivedefinitefactory</title>
  <meta name="keywords" content="sympositivedefinitefactory">
  <meta name="description" content="Manifold of n-by-n symmetric positive definite matrices with">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">manifolds</a> &gt; <a href="index.html">symfixedrank</a> &gt; sympositivedefinitefactory.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\manifolds\symfixedrank&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>sympositivedefinitefactory
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Manifold of n-by-n symmetric positive definite matrices with</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function M = sympositivedefinitefactory(n) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Manifold of n-by-n symmetric positive definite matrices with
 the bi-invariant geometry.

 function M = sympositivedefinitefactory(n)

 A point X on the manifold is represented as a symmetric positive definite
 matrix X (nxn). Tangent vectors are symmetric matrices of the same size
 (but not necessarily definite).

 The Riemannian metric is the bi-invariant metric, described notably in
 Chapter 6 of the 2007 book &quot;Positive definite matrices&quot;
 by Rajendra Bhatia, Princeton University Press.


 The retraction / exponential map involves expm (the matrix exponential).
 If too large a vector is retracted / exponentiated (e.g., a solver tries
 to make too big a step), this may result in NaN's in the returned point,
 which most likely would lead to NaN's in the cost / gradient / ... and
 will result in failure of the optimization. For trustregions, this can be
 controlled by setting options.Delta0 and options.Delta_bar, to prevent
 too large steps.


 Note also that many of the functions involve solving linear systems in X
 (a point on the manifold), taking matrix exponentals and logarithms, etc.
 It could therefore be beneficial to do some precomputation on X (an
 eigenvalue decomposition for example) and store both X and the
 preprocessing in a structure. This would require modifying the present
 factory to work with such structures to represent both points and tangent
 vectors. We omit this in favor of simplicity, but it may be good to keep
 this in mind if efficiency becomes an issue in your application.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>	Computes the MD5 hash of input data.</li><li><a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>	Linear combination function for tangent vectors represented as matrices.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/positive_definite_karcher_mean.html" class="code" title="function X = positive_definite_karcher_mean(A)">positive_definite_karcher_mean</a>	Computes a Karcher mean of a collection of positive definite matrices.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function eta = egrad2rgrad(X, eta)</a></li><li><a href="#_sub2" class="code">function Hess = ehess2rhess(X, egrad, ehess, eta)</a></li><li><a href="#_sub3" class="code">function Y = retraction(X, eta, t)</a></li><li><a href="#_sub4" class="code">function Y = exponential(X, eta, t)</a></li><li><a href="#_sub5" class="code">function H = logarithm(X, Y)</a></li><li><a href="#_sub6" class="code">function X = random()</a></li><li><a href="#_sub7" class="code">function eta = randomvec(X)</a></li><li><a href="#_sub8" class="code">function zeta = parallel_transport(X, Y, eta)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function M = sympositivedefinitefactory(n)</a>
0002 <span class="comment">% Manifold of n-by-n symmetric positive definite matrices with</span>
0003 <span class="comment">% the bi-invariant geometry.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% function M = sympositivedefinitefactory(n)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% A point X on the manifold is represented as a symmetric positive definite</span>
0008 <span class="comment">% matrix X (nxn). Tangent vectors are symmetric matrices of the same size</span>
0009 <span class="comment">% (but not necessarily definite).</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% The Riemannian metric is the bi-invariant metric, described notably in</span>
0012 <span class="comment">% Chapter 6 of the 2007 book &quot;Positive definite matrices&quot;</span>
0013 <span class="comment">% by Rajendra Bhatia, Princeton University Press.</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% The retraction / exponential map involves expm (the matrix exponential).</span>
0017 <span class="comment">% If too large a vector is retracted / exponentiated (e.g., a solver tries</span>
0018 <span class="comment">% to make too big a step), this may result in NaN's in the returned point,</span>
0019 <span class="comment">% which most likely would lead to NaN's in the cost / gradient / ... and</span>
0020 <span class="comment">% will result in failure of the optimization. For trustregions, this can be</span>
0021 <span class="comment">% controlled by setting options.Delta0 and options.Delta_bar, to prevent</span>
0022 <span class="comment">% too large steps.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% Note also that many of the functions involve solving linear systems in X</span>
0026 <span class="comment">% (a point on the manifold), taking matrix exponentals and logarithms, etc.</span>
0027 <span class="comment">% It could therefore be beneficial to do some precomputation on X (an</span>
0028 <span class="comment">% eigenvalue decomposition for example) and store both X and the</span>
0029 <span class="comment">% preprocessing in a structure. This would require modifying the present</span>
0030 <span class="comment">% factory to work with such structures to represent both points and tangent</span>
0031 <span class="comment">% vectors. We omit this in favor of simplicity, but it may be good to keep</span>
0032 <span class="comment">% this in mind if efficiency becomes an issue in your application.</span>
0033 
0034 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0035 <span class="comment">% Original author: Bamdev Mishra, August 29, 2013.</span>
0036 <span class="comment">% Contributors: Nicolas Boumal</span>
0037 <span class="comment">% Change log:</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%   March 5, 2014 (NB)</span>
0040 <span class="comment">%       There were a number of mistakes in the code owing to the tacit</span>
0041 <span class="comment">%       assumption that if X and eta are symmetric, then X\eta is</span>
0042 <span class="comment">%       symmetric too, which is not the case. See discussion on the Manopt</span>
0043 <span class="comment">%       forum started on Jan. 19, 2014. Functions norm, dist, exp and log</span>
0044 <span class="comment">%       were modified accordingly. Furthermore, they only require matrix</span>
0045 <span class="comment">%       inversion (as well as matrix log or matrix exp), not matrix square</span>
0046 <span class="comment">%       roots or their inverse.</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%   July 28, 2014 (NB)</span>
0049 <span class="comment">%       The dim() function returned n*(n-1)/2 instead of n*(n+1)/2.</span>
0050 <span class="comment">%       Implemented proper parallel transport from Sra and Hosseini (not</span>
0051 <span class="comment">%       used by default).</span>
0052 <span class="comment">%       Also added symmetrization in exp and log (to be sure).</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%   April 3, 2015 (NB):</span>
0055 <span class="comment">%       Replaced trace(A*B) by a faster equivalent that does not compute</span>
0056 <span class="comment">%       the whole product A*B, for inner product, norm and distance.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%   May 23, 2017 (NB):</span>
0059 <span class="comment">%       As seen in a talk of Wen Huang at the SIAM Optimization Conference</span>
0060 <span class="comment">%       today, replaced the retraction of this factory (which was simply</span>
0061 <span class="comment">%       equal to the exponential map) with a simpler, second-order</span>
0062 <span class="comment">%       retraction. That this retraction is second order can be verified</span>
0063 <span class="comment">%       numerically with checkretraction(sympositivedefinitefactory(5));</span>
0064 <span class="comment">%       Notice that, for this retraction, it would be cheap to evaluate for</span>
0065 <span class="comment">%       many values of t, that is, it is cheap to retract many points along</span>
0066 <span class="comment">%       the same tangent direction. This could in principle be exploited to</span>
0067 <span class="comment">%       speed up line-searches.</span>
0068     
0069     symm = @(X) .5*(X+X');
0070     
0071     M.name = @() sprintf(<span class="string">'Symmetric positive definite geometry of %dx%d matrices'</span>, n, n);
0072     
0073     M.dim = @() n*(n+1)/2;
0074     
0075     <span class="comment">% Helpers to avoid computing full matrices simply to extract their trace</span>
0076     vec     = @(A) A(:);
0077     trinner = @(A, B) vec(A')'*vec(B);  <span class="comment">% = trace(A*B)</span>
0078     trnorm  = @(A) sqrt(trinner(A, A)); <span class="comment">% = sqrt(trace(A^2))</span>
0079     
0080     <span class="comment">% Choice of the metric on the orthonormal space is motivated by the</span>
0081     <span class="comment">% symmetry present in the space. The metric on the positive definite</span>
0082     <span class="comment">% cone is its natural bi-invariant metric.</span>
0083     <span class="comment">% The result is equal to: trace( (X\eta) * (X\zeta) )</span>
0084     M.inner = @(X, eta, zeta) trinner(X\eta, X\zeta);
0085     
0086     <span class="comment">% Notice that X\eta is *not* symmetric in general.</span>
0087     <span class="comment">% The result is equal to: sqrt(trace((X\eta)^2))</span>
0088     <span class="comment">% There should be no need to take the real part, but rounding errors</span>
0089     <span class="comment">% may cause a small imaginary part to appear, so we discard it.</span>
0090     M.norm = @(X, eta) real(trnorm(X\eta));
0091     
0092     <span class="comment">% Same here: X\Y is not symmetric in general.</span>
0093     <span class="comment">% Same remark about taking the real part.</span>
0094     M.dist = @(X, Y) real(trnorm(real(logm(X\Y))));
0095     
0096     
0097     M.typicaldist = @() sqrt(n*(n+1)/2);
0098     
0099     
0100     M.egrad2rgrad = @<a href="#_sub1" class="code" title="subfunction eta = egrad2rgrad(X, eta)">egrad2rgrad</a>;
0101     <a name="_sub1" href="#_subfunctions" class="code">function eta = egrad2rgrad(X, eta)</a>
0102         eta = X*symm(eta)*X;
0103     <span class="keyword">end</span>
0104     
0105     
0106     M.ehess2rhess = @<a href="#_sub2" class="code" title="subfunction Hess = ehess2rhess(X, egrad, ehess, eta)">ehess2rhess</a>;
0107     <a name="_sub2" href="#_subfunctions" class="code">function Hess = ehess2rhess(X, egrad, ehess, eta)</a>
0108         <span class="comment">% Directional derivatives of the Riemannian gradient</span>
0109         Hess = X*symm(ehess)*X + 2*symm(eta*symm(egrad)*X);
0110         
0111         <span class="comment">% Correction factor for the non-constant metric</span>
0112         Hess = Hess - symm(eta*symm(egrad)*X);
0113     <span class="keyword">end</span>
0114     
0115     
0116     M.proj = @(X, eta) symm(eta);
0117     
0118     M.tangent = M.proj;
0119     M.tangent2ambient = @(X, eta) eta;
0120     
0121     M.retr = @<a href="#_sub3" class="code" title="subfunction Y = retraction(X, eta, t)">retraction</a>;
0122     <a name="_sub3" href="#_subfunctions" class="code">function Y = retraction(X, eta, t)</a>
0123         <span class="keyword">if</span> nargin &lt; 3
0124             teta = eta;
0125         <span class="keyword">else</span>
0126             teta = t*eta;
0127         <span class="keyword">end</span>
0128         <span class="comment">% The symm() call is mathematically unnecessary but numerically</span>
0129         <span class="comment">% necessary.</span>
0130         Y = symm(X + teta + .5*teta*(X\teta));
0131     <span class="keyword">end</span>
0132     
0133     M.exp = @<a href="#_sub4" class="code" title="subfunction Y = exponential(X, eta, t)">exponential</a>;
0134     <a name="_sub4" href="#_subfunctions" class="code">function Y = exponential(X, eta, t)</a>
0135         <span class="keyword">if</span> nargin &lt; 3
0136             t = 1.0;
0137         <span class="keyword">end</span>
0138         <span class="comment">% The symm() and real() calls are mathematically not necessary but</span>
0139         <span class="comment">% are numerically necessary.</span>
0140         Y = symm(X*real(expm(X\(t*eta))));
0141     <span class="keyword">end</span>
0142     
0143     M.log = @<a href="#_sub5" class="code" title="subfunction H = logarithm(X, Y)">logarithm</a>;
0144     <a name="_sub5" href="#_subfunctions" class="code">function H = logarithm(X, Y)</a>
0145         <span class="comment">% Same remark regarding the calls to symm() and real().</span>
0146         H = symm(X*real(logm(X\Y)));
0147     <span class="keyword">end</span>
0148     
0149     M.hash = @(X) [<span class="string">'z'</span> <a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>(X(:))];
0150     
0151     <span class="comment">% Generate a random symmetric positive definite matrix following a</span>
0152     <span class="comment">% certain distribution. The particular choice of a distribution is of</span>
0153     <span class="comment">% course arbitrary, and specific applications might require different</span>
0154     <span class="comment">% ones.</span>
0155     M.rand = @<a href="#_sub6" class="code" title="subfunction X = random()">random</a>;
0156     <a name="_sub6" href="#_subfunctions" class="code">function X = random()</a>
0157         D = diag(1+rand(n, 1));
0158         [Q, R] = qr(randn(n)); <span class="comment">%#ok&lt;NASGU&gt;</span>
0159         X = Q*D*Q';
0160     <span class="keyword">end</span>
0161     
0162     <span class="comment">% Generate a uniformly random unit-norm tangent vector at X.</span>
0163     M.randvec = @<a href="#_sub7" class="code" title="subfunction eta = randomvec(X)">randomvec</a>;
0164     <a name="_sub7" href="#_subfunctions" class="code">function eta = randomvec(X)</a>
0165         eta = symm(randn(n));
0166         nrm = M.norm(X, eta);
0167         eta = eta / nrm;
0168     <span class="keyword">end</span>
0169     
0170     M.lincomb = @<a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>;
0171     
0172     M.zerovec = @(X) zeros(n);
0173     
0174     <span class="comment">% Poor man's vector transport: exploit the fact that all tangent spaces</span>
0175     <span class="comment">% are the set of symmetric matrices, so that the identity is a sort of</span>
0176     <span class="comment">% vector transport. It may perform poorly if the origin and target (X1</span>
0177     <span class="comment">% and X2) are far apart though. This should not be the case for typical</span>
0178     <span class="comment">% optimization algorithms, which perform small steps.</span>
0179     M.transp = @(X1, X2, eta) eta;
0180     
0181     <span class="comment">% For reference, a proper vector transport is given here, following</span>
0182     <span class="comment">% work by Sra and Hosseini: &quot;Conic geometric optimisation on the</span>
0183     <span class="comment">% manifold of positive definite matrices&quot;, to appear in SIAM J. Optim.</span>
0184     <span class="comment">% in 2015; also available here: http://arxiv.org/abs/1312.1039</span>
0185     <span class="comment">% This will not be used by default. To force the use of this transport,</span>
0186     <span class="comment">% execute &quot;M.transp = M.paralleltransp;&quot; on your M returned by the</span>
0187     <span class="comment">% present factory.</span>
0188     M.paralleltransp = @<a href="#_sub8" class="code" title="subfunction zeta = parallel_transport(X, Y, eta)">parallel_transport</a>;
0189     <a name="_sub8" href="#_subfunctions" class="code">function zeta = parallel_transport(X, Y, eta)</a>
0190         E = sqrtm((Y/X));
0191         zeta = E*eta*E';
0192     <span class="keyword">end</span>
0193     
0194     <span class="comment">% vec and mat are not isometries, because of the unusual inner metric.</span>
0195     M.vec = @(X, U) U(:);
0196     M.mat = @(X, u) reshape(u, n, n);
0197     M.vecmatareisometries = @() false;
0198     
0199 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 08-Sep-2017 12:43:19 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>