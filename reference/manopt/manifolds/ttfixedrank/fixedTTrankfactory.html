<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fixedTTrankfactory</title>
  <meta name="keywords" content="fixedTTrankfactory">
  <meta name="description" content="Manifold of tensors of fixed Tensor Train (TT) rank, embedded geometry">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">manifolds</a> &gt; <a href="index.html">ttfixedrank</a> &gt; fixedTTrankfactory.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\manifolds\ttfixedrank&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fixedTTrankfactory
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Manifold of tensors of fixed Tensor Train (TT) rank, embedded geometry</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function M = fixedTTrankfactory(n, r, ind) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Manifold of tensors of fixed Tensor Train (TT) rank, embedded geometry
 
 NOTE: this manifold requires the use of a modified version of TTeMPS_1.1,
 which is packaced with Manopt and can be found in 
 /manopt/manifolds/ttfixedrank/TTeMPS_1.1/
 
 function M = fixedTTrankfactory(n, r)
 function M = fixedTTrankfactory(n, r, ind)
 
 Inputs:
   n is a vector denoting the embedding space dimension,
     R^{n(1) x ... x n(d)} (d = length(n) is the order of the tensor)
   r is a vector denoting the TT-rank of all tensors in the manifold,
     where length(r) = d + 1. We also enforce r(1) = r(d+1) = 1.
   ind (optional): if only sparse tensors in the embedding space are
     considered (as is the case for tensor completion in particular), the
     parameter ind can be passed, where ind is a matrix of size p-by-d
     whose rows contain the multi-indices of the p non-zero entries.
     See TTeMPS_1.1/algorithms/completion/makeOmegaSet.m for an example
     on constructing ind.
 
 A point X on the manifold is represented through its TT-cores, stored in
 the cell array X.U. We enforce the TT-cores in X.U to be
 'left-orthogonalized' (see Steinlechner's thesis, Section 4.2.1), because
 many algorithms require X.U to be left-orthogonalized.
 
 A tangent vector Z in the tangent space of a TT-tensor X is represented
 as a structure containing 3 cell-arrays:
 
 1) Z.U, which is exactly X.U of the base point X
 2) Z.V, the right-orthogonalization of X.U
 3) Z.dU, the 'variational cores' that parametrize the tangent vector Z
          itself. This matches the 'alternative representation' of tangent
          vectors discussed in the Psenka and Boumal paper (see below).
 
 The first-order Riemannian geometry of the manifold of fixed TT-rank
 tensors is described in detail in Steinlechner's PhD thesis, Section 4:
   https://infoscience.epfl.ch/record/217938?ln=en
 TTeMPS also comes from that work.

 The second-order Riemannian geometry (necessary for the ehess2rhess tool)
 is described in the following paper:
   Psenka and Boumal,
   Second-order optimization for tensors with fixed tensor-train rank,
   Optimization workshop at NeurIPS 2020.
   https://arxiv.org/abs/2011.13395
 
 Please cite the Manopt paper as well as the relevant research papers.
 
 See also: fixedrankembeddedfactory fixedranktensorembeddedfactory</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="TT_weingarten.html" class="code" title="function Y = TT_weingarten(V, Z, ind)">TT_weingarten</a>	Weingarten map computation for the fixed TT-rank manifold.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/full.html" class="code" title="function y = full( x )">full</a>	FULL Convert TTeMPS tensor to full array</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/innerprod.html" class="code" title="function res = innerprod( x, y, dir, upto, storeParts )">innerprod</a>	INNERPROD Inner product between two TT/MPS tensors.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/norm.html" class="code" title="function res = norm( x, safe )">norm</a>	NORM Norm of a TT/MPS tensor.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/orthogonalize.html" class="code" title="function x = orthogonalize( x, pos )">orthogonalize</a>	ORTHOGONALIZE Orthogonalize tensor.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_block/full.html" class="code" title="function y = full( x )">full</a>	FULL Convert TTeMPS tensor to full array</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_block/innerprod.html" class="code" title="function res = innerprod( x, y, dir, upto )">innerprod</a>	INNERPROD Inner product between two TT/MPS tensors.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_block/norm.html" class="code" title="function res = norm( x )">norm</a>	NORM Norm of a TT/MPS block-mu tensor.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_block/orthogonalize.html" class="code" title="function res = orthogonalize( x )">orthogonalize</a>	ORTHOGONALIZE Orthogonalize TT/MPS Block-mu tensor.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_op/full.html" class="code" title="function Afull = full( A )">full</a>	FULL Convert TTeMPS_op operator to full array</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_tangent_orth/TTeMPS_tangent_orth.html" class="code" title="">TTeMPS_tangent_orth</a>	</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/TTeMPS_randn.html" class="code" title="function x = TTeMPS_randn(r, n)">TTeMPS_randn</a>	TTEMPS_RANDN Create random TTeMPS tensor</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/unfold.html" class="code" title="function W = unfold( U, dir )">unfold</a>	UNFOLD Left/right-unfold a 3D array.</li><li><a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>	Linear combination function for tangent vectors represented as matrices.</li><li><a href="../../../manopt/tools/orthogonalize.html" class="code" title="function [Q, R] = orthogonalize(M, x, A)">orthogonalize</a>	Orthonormalizes a basis of tangent vectors in the Manopt framework.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/low_rank_tensor_completion_TT.html" class="code" title="function low_rank_tensor_completion_TT()">low_rank_tensor_completion_TT</a>	Example file for the manifold encoded in fixedTTrankfactory.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/examples/linearsystem_compare.html" class="code" title="">linearsystem_compare</a>	Example code for the algorithms described in</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function k = dim()</a></li><li><a href="#_sub2" class="code">function X = random()</a></li><li><a href="#_sub3" class="code">function X = fromArray(Y)</a></li><li><a href="#_sub4" class="code">function Z = randomTangent(X, Xr)</a></li><li><a href="#_sub5" class="code">function Z0 = zeroVector(X)</a></li><li><a href="#_sub6" class="code">function Z = tangent(X, Zin)</a></li><li><a href="#_sub7" class="code">function Zproj = projection(X, Z)</a></li><li><a href="#_sub8" class="code">function rhess = ehess2rhess(X, egrad, ehess, H)</a></li><li><a href="#_sub9" class="code">function Z_TT = tangent2TT(X, Z)</a></li><li><a href="#_sub10" class="code">function Zamb = tangent2ambient(X, Z)</a></li><li><a href="#_sub11" class="code">function Y = retraction(X, Z, t)</a></li><li><a href="#_sub12" class="code">function Z2 = project_tangent(X1, X2, Z1)</a></li><li><a href="#_sub13" class="code">function Zvec = vec(X, Z)</a></li><li><a href="#_sub14" class="code">function Zmat = mat(X, Zvec)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function M = fixedTTrankfactory(n, r, ind)</a>
0002 <span class="comment">% Manifold of tensors of fixed Tensor Train (TT) rank, embedded geometry</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% NOTE: this manifold requires the use of a modified version of TTeMPS_1.1,</span>
0005 <span class="comment">% which is packaced with Manopt and can be found in</span>
0006 <span class="comment">% /manopt/manifolds/ttfixedrank/TTeMPS_1.1/</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% function M = fixedTTrankfactory(n, r)</span>
0009 <span class="comment">% function M = fixedTTrankfactory(n, r, ind)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Inputs:</span>
0012 <span class="comment">%   n is a vector denoting the embedding space dimension,</span>
0013 <span class="comment">%     R^{n(1) x ... x n(d)} (d = length(n) is the order of the tensor)</span>
0014 <span class="comment">%   r is a vector denoting the TT-rank of all tensors in the manifold,</span>
0015 <span class="comment">%     where length(r) = d + 1. We also enforce r(1) = r(d+1) = 1.</span>
0016 <span class="comment">%   ind (optional): if only sparse tensors in the embedding space are</span>
0017 <span class="comment">%     considered (as is the case for tensor completion in particular), the</span>
0018 <span class="comment">%     parameter ind can be passed, where ind is a matrix of size p-by-d</span>
0019 <span class="comment">%     whose rows contain the multi-indices of the p non-zero entries.</span>
0020 <span class="comment">%     See TTeMPS_1.1/algorithms/completion/makeOmegaSet.m for an example</span>
0021 <span class="comment">%     on constructing ind.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% A point X on the manifold is represented through its TT-cores, stored in</span>
0024 <span class="comment">% the cell array X.U. We enforce the TT-cores in X.U to be</span>
0025 <span class="comment">% 'left-orthogonalized' (see Steinlechner's thesis, Section 4.2.1), because</span>
0026 <span class="comment">% many algorithms require X.U to be left-orthogonalized.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% A tangent vector Z in the tangent space of a TT-tensor X is represented</span>
0029 <span class="comment">% as a structure containing 3 cell-arrays:</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% 1) Z.U, which is exactly X.U of the base point X</span>
0032 <span class="comment">% 2) Z.V, the right-orthogonalization of X.U</span>
0033 <span class="comment">% 3) Z.dU, the 'variational cores' that parametrize the tangent vector Z</span>
0034 <span class="comment">%          itself. This matches the 'alternative representation' of tangent</span>
0035 <span class="comment">%          vectors discussed in the Psenka and Boumal paper (see below).</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% The first-order Riemannian geometry of the manifold of fixed TT-rank</span>
0038 <span class="comment">% tensors is described in detail in Steinlechner's PhD thesis, Section 4:</span>
0039 <span class="comment">%   https://infoscience.epfl.ch/record/217938?ln=en</span>
0040 <span class="comment">% TTeMPS also comes from that work.</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% The second-order Riemannian geometry (necessary for the ehess2rhess tool)</span>
0043 <span class="comment">% is described in the following paper:</span>
0044 <span class="comment">%   Psenka and Boumal,</span>
0045 <span class="comment">%   Second-order optimization for tensors with fixed tensor-train rank,</span>
0046 <span class="comment">%   Optimization workshop at NeurIPS 2020.</span>
0047 <span class="comment">%   https://arxiv.org/abs/2011.13395</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% Please cite the Manopt paper as well as the relevant research papers.</span>
0050 <span class="comment">%</span>
0051 <span class="comment">% See also: fixedrankembeddedfactory fixedranktensorembeddedfactory</span>
0052 
0053 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0054 <span class="comment">% Original author: Michael Psenka, Nov. 24, 2020.</span>
0055 <span class="comment">% Contributors: Nicolas Boumal</span>
0056 <span class="comment">% Change log:</span>
0057 
0058     <span class="comment">% Order of tensors</span>
0059     d = numel(n);
0060     
0061     assert(length(r) == d+1, <span class="keyword">...</span>
0062                     <span class="string">'Vector r must have length equal to length(n)+1.'</span>);
0063     assert(r(1) == 1 &amp;&amp; r(end) == 1, <span class="keyword">...</span>
0064                     <span class="string">'The first and last entry of r must be equal to 1.'</span>);
0065 
0066     M.name = @() sprintf(<span class="string">'Manifold of tensor order %d, dimension %s, and TT-rank %s'</span>, <span class="keyword">...</span>
0067         d, mat2str(n), mat2str(r));
0068 
0069     M.dim = @<a href="#_sub1" class="code" title="subfunction k = dim()">dim</a>;
0070     <a name="_sub1" href="#_subfunctions" class="code">function k = dim()</a>
0071         k = 0;
0072 
0073         <span class="keyword">for</span> m = 1:(d-1)
0074             k = k + r(m) * n(m) * r(m + 1) - r(m + 1) * r(m + 1);
0075         <span class="keyword">end</span>
0076 
0077         k = k + r(d) * n(d) * r(d + 1);
0078     <span class="keyword">end</span>
0079 
0080     <span class="comment">% Creates random unit-norm TT-tensor of TT-rank r.</span>
0081     M.rand = @<a href="#_sub2" class="code" title="subfunction X = random()">random</a>;
0082     <a name="_sub2" href="#_subfunctions" class="code">function X = random()</a>
0083         <span class="comment">% Gaussian random cores</span>
0084         X = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/TTeMPS_randn.html" class="code" title="function x = TTeMPS_randn(r, n)">TTeMPS_randn</a>(r, n);
0085         <span class="comment">% Left-orthogonalize X</span>
0086         X = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/orthogonalize.html" class="code" title="function x = orthogonalize( x, pos )">orthogonalize</a>(X, d);
0087         <span class="comment">% Normalize (efficient transformation to unit norm)</span>
0088         X.U{d} = (1 / <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/norm.html" class="code" title="function res = norm( x, safe )">norm</a>(X.U{d})) * X.U{d};
0089     <span class="keyword">end</span>
0090 
0091     <span class="comment">% Uses the TT-SVD algorithm to project a full array to a TT-tensor</span>
0092     <span class="comment">% of TT-rank r</span>
0093     M.from_array = @<a href="#_sub3" class="code" title="subfunction X = fromArray(Y)">fromArray</a>;
0094 
0095     <a name="_sub3" href="#_subfunctions" class="code">function X = fromArray(Y)</a>
0096         <span class="comment">% TTeMPS implementation of TT-SVD</span>
0097         X = TTeMPS.from_array(Y, r);
0098         <span class="comment">% Left-orthogonalized version of X</span>
0099         X = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/orthogonalize.html" class="code" title="function x = orthogonalize( x, pos )">orthogonalize</a>(X, d);
0100     <span class="keyword">end</span>
0101 
0102     <span class="comment">% Creates random unit norm tangent vector at X on manifold.</span>
0103     <span class="comment">% Optional argument Xr of right-orthogonalized X.</span>
0104     M.randvec = @<a href="#_sub4" class="code" title="subfunction Z = randomTangent(X, Xr)">randomTangent</a>;
0105     <a name="_sub4" href="#_subfunctions" class="code">function Z = randomTangent(X, Xr)</a>
0106         <span class="keyword">if</span> nargin == 1
0107             <span class="comment">% If not provided, right orthogonalize X</span>
0108             Xr = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/orthogonalize.html" class="code" title="function x = orthogonalize( x, pos )">orthogonalize</a>(X, 1); <span class="comment">% right-orthogonalized version of X</span>
0109         <span class="keyword">end</span>
0110 
0111         <span class="comment">% Two arguments --&gt; random unit-norm tangent vector</span>
0112         Z = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_tangent_orth/TTeMPS_tangent_orth.html" class="code" title="">TTeMPS_tangent_orth</a>(X, Xr);
0113     <span class="keyword">end</span>
0114 
0115     M.zerovec = @<a href="#_sub5" class="code" title="subfunction Z0 = zeroVector(X)">zeroVector</a>;
0116     <a name="_sub5" href="#_subfunctions" class="code">function Z0 = zeroVector(X)</a>
0117         <span class="comment">% X could be given as base point or tangent vector</span>
0118         <span class="keyword">if</span> isa(X, <span class="string">'TTeMPS'</span>)
0119             <span class="comment">% For TTeMPS function, one argument --&gt; zero vec at point</span>
0120             Z0 = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_tangent_orth/TTeMPS_tangent_orth.html" class="code" title="">TTeMPS_tangent_orth</a>(X); 
0121         <span class="keyword">elseif</span> isa(X, <span class="string">'TTeMPS_tangent_orth'</span>)
0122             <span class="comment">% If tangent vec, simply set dU cores to 0</span>
0123             Z0 = X;
0124             <span class="keyword">for</span> k = 1:d
0125                 Z0.dU{k} = zeros(r(k), n(k), r(k + 1));
0126             <span class="keyword">end</span>
0127         <span class="keyword">else</span>
0128             error(<span class="string">'unexpected input type for zerovec'</span>)
0129         <span class="keyword">end</span>
0130 
0131     <span class="keyword">end</span>
0132 
0133     <span class="comment">% Note that innerprod has an overflow in TTeMPS for TT-tensor arguments</span>
0134     M.inner = @(x, u, v) <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/innerprod.html" class="code" title="function res = innerprod( x, y, dir, upto, storeParts )">innerprod</a>(u, v);
0135     M.norm = @(x, v) real(sqrt(<a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/innerprod.html" class="code" title="function res = innerprod( x, y, dir, upto, storeParts )">innerprod</a>(v, v)));
0136     M.dist = @(x, y) error(<span class="string">'tensor_fixed_TT_rank_factory.dist not implemented yet.'</span>);
0137     M.typicaldist = @() M.dim();
0138 
0139 
0140     <span class="comment">% Given Z in tangent vector format, projects the components U_i such</span>
0141     <span class="comment">% that they satisfy the tangent space constraints up to numerical</span>
0142     <span class="comment">% errors (i.e., enforce that they satisfy the so-called gauge</span>
0143     <span class="comment">% conditions). If Z was indeed a tangent vector at X, this should</span>
0144     <span class="comment">% barely affect Z (it would not at all if we had infinite numerical</span>
0145     <span class="comment">% accuracy).</span>
0146     M.tangent = @<a href="#_sub6" class="code" title="subfunction Z = tangent(X, Zin)">tangent</a>;
0147     <a name="_sub6" href="#_subfunctions" class="code">function Z = tangent(X, Zin)</a>
0148         <span class="comment">% Project to normal spaces of U^L for all but the last core</span>
0149         Z = Zin; <span class="comment">% this copies the TTeMPS_tangent_orth class structure</span>
0150         <span class="keyword">for</span> k = 1:(d-1)
0151             dUL = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/unfold.html" class="code" title="function W = unfold( U, dir )">unfold</a>(Zin.dU{k}, <span class="string">'left'</span>);
0152             UL = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/unfold.html" class="code" title="function W = unfold( U, dir )">unfold</a>(X.U{k}, <span class="string">'left'</span>);
0153             dUL_new = dUL - UL * (UL' * dUL);
0154             r = Z.rank;
0155             n = Z.size;
0156             Z.dU{k} = reshape(dUL_new, [r(k), n(k), r(k + 1)]);
0157         <span class="keyword">end</span>
0158     <span class="keyword">end</span>
0159 
0160 
0161     <span class="comment">% It would be useful to implement the following efficienctly.</span>
0162     <span class="comment">%</span>
0163     <span class="comment">% Applies a linear transformation to tensor W.</span>
0164     <span class="comment">% Z is a matrix, and W is a tensor, which must be flattened into a</span>
0165     <span class="comment">% vector before applying Z.</span>
0166     <span class="comment">% function ZW = apply_matrix(Z, W)</span>
0167     <span class="comment">%     ...</span>
0168     <span class="comment">% end</span>
0169     <span class="comment">%</span>
0170     <span class="comment">% Same as apply_ambient, but applies Z' to W.</span>
0171     <span class="comment">% function ZtW = apply_matrix_transpose(Z, W)</span>
0172     <span class="comment">%     ...</span>
0173     <span class="comment">% end</span>
0174 
0175     <span class="comment">% Compute linear combination of two TT-tensors.</span>
0176     <span class="comment">% Note that '+' and scalar multiplication are both overloaded in the</span>
0177     <span class="comment">% TTeMPS library.</span>
0178     M.lincomb = @<a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>;
0179 
0180 
0181     <span class="comment">% Orthogonal projection of an ambient vector Z represented as full</span>
0182     <span class="comment">% array of size n to the tangent space of TT-tensor Z.</span>
0183     <span class="comment">% Two possible calls: either xR (right orthogonalized) is known or not.</span>
0184     M.proj = @<a href="#_sub7" class="code" title="subfunction Zproj = projection(X, Z)">projection</a>;
0185     <a name="_sub7" href="#_subfunctions" class="code">function Zproj = projection(X, Z)</a>
0186 
0187         Xr = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/orthogonalize.html" class="code" title="function x = orthogonalize( x, pos )">orthogonalize</a>(X, 1); <span class="comment">%right-orthogonalized version of X</span>
0188 
0189         <span class="comment">% Check if using sparse ambient space</span>
0190         <span class="keyword">if</span> exist(<span class="string">'ind'</span>, <span class="string">'var'</span>)
0191             Zproj = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_tangent_orth/TTeMPS_tangent_orth.html" class="code" title="">TTeMPS_tangent_orth</a>(X, Xr, Z, ind);
0192         <span class="keyword">else</span>
0193             Zproj = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_tangent_orth/TTeMPS_tangent_orth.html" class="code" title="">TTeMPS_tangent_orth</a>(X, Xr, Z);
0194         <span class="keyword">end</span>
0195 
0196     <span class="keyword">end</span>
0197 
0198     M.egrad2rgrad = @<a href="#_sub7" class="code" title="subfunction Zproj = projection(X, Z)">projection</a>;
0199 
0200 
0201     <span class="comment">% Given the Euclidean gradient at X and the Euclidean Hessian at X</span>
0202     <span class="comment">% along H, where egrad and ehess are vectors in the ambient space and H</span>
0203     <span class="comment">% is a tangent vector at X, returns the Riemannian Hessian at X along</span>
0204     <span class="comment">% H, which is a tangent vector.</span>
0205     <span class="comment">% Curvature part denotes the Weingarten map part. Euclidean part is the</span>
0206     <span class="comment">% Euclidean hessian projection part,</span>
0207     M.ehess2rhess = @<a href="#_sub8" class="code" title="subfunction rhess = ehess2rhess(X, egrad, ehess, H)">ehess2rhess</a>;
0208     <a name="_sub8" href="#_subfunctions" class="code">function rhess = ehess2rhess(X, egrad, ehess, H)</a>
0209 
0210         <span class="comment">% Euclidean part</span>
0211         rhess = <a href="#_sub7" class="code" title="subfunction Zproj = projection(X, Z)">projection</a>(X, ehess);
0212 
0213         <span class="comment">% Curvature part</span>
0214         <span class="keyword">if</span> exist(<span class="string">'ind'</span>, <span class="string">'var'</span>)
0215             rhess = rhess + <a href="TT_weingarten.html" class="code" title="function Y = TT_weingarten(V, Z, ind)">TT_weingarten</a>(H, egrad, ind);
0216         <span class="keyword">else</span>
0217             rhess = rhess + <a href="TT_weingarten.html" class="code" title="function Y = TT_weingarten(V, Z, ind)">TT_weingarten</a>(H, egrad);
0218         <span class="keyword">end</span>
0219     <span class="keyword">end</span>
0220 
0221     <span class="comment">% Converts a tangent vector to the TT format</span>
0222     M.tangent2TT = @<a href="#_sub9" class="code" title="subfunction Z_TT = tangent2TT(X, Z) ">tangent2TT</a>;
0223     <a name="_sub9" href="#_subfunctions" class="code">function Z_TT = tangent2TT(X, Z) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
0224         Z_TT = tangent_to_TTeMPS(Z);
0225     <span class="keyword">end</span>
0226 
0227     <span class="comment">% It would be useful to implement the following more efficiently...</span>
0228     M.tangent2ambient = @<a href="#_sub10" class="code" title="subfunction Zamb = tangent2ambient(X, Z) ">tangent2ambient</a>;
0229     <a name="_sub10" href="#_subfunctions" class="code">function Zamb = tangent2ambient(X, Z) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
0230         Zamb = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/full.html" class="code" title="function y = full( x )">full</a>(Z);
0231     <span class="keyword">end</span>
0232 
0233     <span class="comment">% Retraction for the fixed TT - rank manifold</span>
0234     M.retr = @<a href="#_sub11" class="code" title="subfunction Y = retraction(X, Z, t) ">retraction</a>;
0235 
0236     <span class="comment">% NOTE: X not used in the function because Z is</span>
0237     <span class="comment">% a structure that contains all information of</span>
0238     <span class="comment">% X. X is kept as an argument to keep consistency</span>
0239     <span class="comment">% with standard manifold factory format</span>
0240     <a name="_sub11" href="#_subfunctions" class="code">function Y = retraction(X, Z, t) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
0241 
0242         <span class="keyword">if</span> nargin &lt; 3
0243             t = 1;
0244         <span class="keyword">end</span>
0245 
0246         Y = tangentAdd(Z, t, true);
0247         Y = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/orthogonalize.html" class="code" title="function x = orthogonalize( x, pos )">orthogonalize</a>(Y, d);
0248 
0249     <span class="keyword">end</span>
0250 
0251     <span class="comment">% Vector transport (see Steinlechner's thesis)</span>
0252     <span class="comment">% Computes a tangent vector at X2 that &quot;looks like&quot; the tangent vector</span>
0253     <span class="comment">% Z1 at X1. This is not necessarily a parallel transport.</span>
0254     M.transp = @<a href="#_sub12" class="code" title="subfunction Z2 = project_tangent(X1, X2, Z1) ">project_tangent</a>;
0255     <a name="_sub12" href="#_subfunctions" class="code">function Z2 = project_tangent(X1, X2, Z1) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
0256         Z2 = <a href="#_sub7" class="code" title="subfunction Zproj = projection(X, Z)">projection</a>(X2, Z1);
0257     <span class="keyword">end</span>
0258 
0259     <span class="comment">% The function 'vec' is isometric from the tangent space at X to real</span>
0260     <span class="comment">% vectors by flattening dU cores and stringing out to one vector.</span>
0261     <span class="comment">% The function 'mat' is the left-inverse of 'vec'. It is sometimes</span>
0262     <span class="comment">% useful to apply 'tangent' to the output of 'mat'.</span>
0263     M.vec = @<a href="#_sub13" class="code" title="subfunction Zvec = vec(X, Z) ">vec</a>;
0264     <a name="_sub13" href="#_subfunctions" class="code">function Zvec = vec(X, Z) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
0265         X_size = 0;
0266         <span class="keyword">for</span> k = 1:d
0267             X_size = X_size + numel(Z.dU{k});
0268         <span class="keyword">end</span>
0269         <span class="comment">% initialize full flattened vector in memory</span>
0270         Zvec = zeros(X_size,1);
0271         <span class="comment">% starting index to fill Zvec</span>
0272         ind_start = 1;
0273         <span class="comment">% how many entries to fill Zvec</span>
0274         ind_step = numel(Z.dU{1});
0275         <span class="keyword">for</span> k = 1:d
0276             Zvec(ind_start:ind_start+ind_step-1) = Z.dU{k}(:);
0277             ind_start = ind_start+ind_step;
0278             <span class="keyword">if</span> k &lt; d <span class="comment">% avoids indexing error at end of loop</span>
0279                 ind_step = numel(Z.dU{k+1});
0280             <span class="keyword">end</span>
0281         <span class="keyword">end</span>
0282     <span class="keyword">end</span>
0283 
0284     M.mat = @<a href="#_sub14" class="code" title="subfunction Zmat = mat(X, Zvec)">mat</a>;
0285     <a name="_sub14" href="#_subfunctions" class="code">function Zmat = mat(X, Zvec)</a>
0286         Zmat = M.zerovec(X);
0287         <span class="keyword">for</span> k = 1:d
0288             sizeSubVec = numel(Zmat.dU{k}); <span class="comment">% how many elements from Zvec belong to dU{k}</span>
0289             Zmat.dU{k} = reshape(Zvec(1:sizeSubVec), size(Zmat.dU{k}));
0290             Zvec = Zvec((sizeSubVec+1):end);
0291         <span class="keyword">end</span>        
0292 
0293     <span class="keyword">end</span>
0294 
0295     <span class="comment">% That vec/mat are isometries is checked in the Psenka &amp; Boumal paper,</span>
0296     <span class="comment">% in relation to the discussion of an alternative parametrization of</span>
0297     <span class="comment">% the tangent spaces.</span>
0298     M.vecmatareisometries = @() true;
0299 
0300 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Sep-2022 13:18:25 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>