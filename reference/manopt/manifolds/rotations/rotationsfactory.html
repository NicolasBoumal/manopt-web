<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of rotationsfactory</title>
  <meta name="keywords" content="rotationsfactory">
  <meta name="description" content="Returns a manifold structure to optimize over rotation matrices.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">manifolds</a> &gt; <a href="index.html">rotations</a> &gt; rotationsfactory.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\manifolds\rotations&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>rotationsfactory
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Returns a manifold structure to optimize over rotation matrices.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function M = rotationsfactory(n, k) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Returns a manifold structure to optimize over rotation matrices.
 
 function M = rotationsfactory(n)
 function M = rotationsfactory(n, k)

 Special orthogonal group (the manifold of rotations): deals with matrices
 R of size n x n x k (or n x n if k = 1, which is the default) such that
 each n x n matrix is orthogonal, with determinant 1, i.e., X'*X = eye(n)
 if k = 1, or X(:, :, i)' * X(:, :, i) = eye(n) for i = 1 : k if k &gt; 1.

 This is a description of SO(n)^k with the induced metric from the
 embedding space (R^nxn)^k, i.e., this manifold is a Riemannian
 submanifold of (R^nxn)^k endowed with the usual trace inner product.

 Tangent vectors are represented in the Lie algebra, i.e., as skew
 symmetric matrices. Use the function M.tangent2ambient(X, H) to switch
 from the Lie algebra representation to the embedding space
 representation. This is often necessary when defining
 problem.ehess(X, H).

 By default, the retraction is only a first-order approximation of the
 exponential. To force the use of a second-order approximation, call
 M.retr = M.retr2 after creating M. This switches from a QR-based
 computation to an SVD-based computation.

 By default, k = 1.

 See also: stiefelfactory</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="randrot.html" class="code" title="function R = randrot(n, N)">randrot</a>	Generates uniformly random rotation matrices.</li><li><a href="randskew.html" class="code" title="function S = randskew(n, N)">randskew</a>	Generates random skew symmetric matrices with normal entries.</li><li><a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>	Computes the MD5 hash of input data.</li><li><a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>	Linear combination function for tangent vectors represented as matrices.</li><li><a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>	Multiplying 1-D or 2-D subarrays contained in two N-D arrays.</li><li><a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>	Returns the skew-symmetric parts of the matrices in the 3D matrix X.</li><li><a href="../../../manopt/tools/multisym.html" class="code" title="function Y = multisym(X)">multisym</a>	Returns the symmetric parts of the matrices in the 3D matrix X</li><li><a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>	Transposing arrays of matrices.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/generalized_procrustes.html" class="code" title="function [A, R] = generalized_procrustes(A_measure)">generalized_procrustes</a>	Rotationally align clouds of points (generalized Procrustes problem)</li><li><a href="../../../manopt/manifolds/specialeuclidean/specialeuclideanfactory.html" class="code" title="function M = specialeuclideanfactory(n, k)">specialeuclideanfactory</a>	Returns a manifold structure to optimize over the special Euclidean group</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Rhess = ehess2rhess(X, Egrad, Ehess, H)</a></li><li><a href="#_sub2" class="code">function Y = retraction(X, U, t)</a></li><li><a href="#_sub3" class="code">function Y = retraction2(X, U, t)</a></li><li><a href="#_sub4" class="code">function Y = exponential(X, U, t)</a></li><li><a href="#_sub5" class="code">function U = logarithm(X, Y)</a></li><li><a href="#_sub6" class="code">function U = randomvec(X)</a></li><li><a href="#_sub7" class="code">function Y = pairmean(X1, X2)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function M = rotationsfactory(n, k)</a>
0002 <span class="comment">% Returns a manifold structure to optimize over rotation matrices.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function M = rotationsfactory(n)</span>
0005 <span class="comment">% function M = rotationsfactory(n, k)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Special orthogonal group (the manifold of rotations): deals with matrices</span>
0008 <span class="comment">% R of size n x n x k (or n x n if k = 1, which is the default) such that</span>
0009 <span class="comment">% each n x n matrix is orthogonal, with determinant 1, i.e., X'*X = eye(n)</span>
0010 <span class="comment">% if k = 1, or X(:, :, i)' * X(:, :, i) = eye(n) for i = 1 : k if k &gt; 1.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% This is a description of SO(n)^k with the induced metric from the</span>
0013 <span class="comment">% embedding space (R^nxn)^k, i.e., this manifold is a Riemannian</span>
0014 <span class="comment">% submanifold of (R^nxn)^k endowed with the usual trace inner product.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% Tangent vectors are represented in the Lie algebra, i.e., as skew</span>
0017 <span class="comment">% symmetric matrices. Use the function M.tangent2ambient(X, H) to switch</span>
0018 <span class="comment">% from the Lie algebra representation to the embedding space</span>
0019 <span class="comment">% representation. This is often necessary when defining</span>
0020 <span class="comment">% problem.ehess(X, H).</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% By default, the retraction is only a first-order approximation of the</span>
0023 <span class="comment">% exponential. To force the use of a second-order approximation, call</span>
0024 <span class="comment">% M.retr = M.retr2 after creating M. This switches from a QR-based</span>
0025 <span class="comment">% computation to an SVD-based computation.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% By default, k = 1.</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% See also: stiefelfactory</span>
0030 
0031 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0032 <span class="comment">% Original author: Nicolas Boumal, Dec. 30, 2012.</span>
0033 <span class="comment">% Contributors:</span>
0034 <span class="comment">% Change log:</span>
0035 <span class="comment">%   Jan. 31, 2013 (NB)</span>
0036 <span class="comment">%       Added egrad2rgrad and ehess2rhess</span>
0037 <span class="comment">%   Oct. 21, 2016 (NB)</span>
0038 <span class="comment">%       Added M.retr2: a second-order retraction based on SVD.</span>
0039 
0040     
0041     <span class="keyword">if</span> ~exist(<span class="string">'k'</span>, <span class="string">'var'</span>) || isempty(k)
0042         k = 1;
0043     <span class="keyword">end</span>
0044     
0045     <span class="keyword">if</span> k == 1
0046         M.name = @() sprintf(<span class="string">'Rotations manifold SO(%d)'</span>, n);
0047     <span class="keyword">elseif</span> k &gt; 1
0048         M.name = @() sprintf(<span class="string">'Product rotations manifold SO(%d)^%d'</span>, n, k);
0049     <span class="keyword">else</span>
0050         error(<span class="string">'k must be an integer no less than 1.'</span>);
0051     <span class="keyword">end</span>
0052     
0053     M.dim = @() k*nchoosek(n, 2);
0054     
0055     M.inner = @(x, d1, d2) d1(:).'*d2(:);
0056     
0057     M.norm = @(x, d) norm(d(:));
0058     
0059     M.typicaldist = @() pi*sqrt(n*k);
0060     
0061     M.proj = @(X, H) <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(<a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X), H));
0062     
0063     M.tangent = @(X, H) <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(H);
0064     
0065     M.tangent2ambient = @(X, U) <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, U);
0066     
0067     M.egrad2rgrad = M.proj;
0068     
0069     M.ehess2rhess = @<a href="#_sub1" class="code" title="subfunction Rhess = ehess2rhess(X, Egrad, Ehess, H)">ehess2rhess</a>;
0070     <a name="_sub1" href="#_subfunctions" class="code">function Rhess = ehess2rhess(X, Egrad, Ehess, H)</a>
0071         <span class="comment">% Reminder : H contains skew-symmeric matrices. The actual</span>
0072         <span class="comment">% direction that the point X is moved along is X*H.</span>
0073         Xt = <a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X);
0074         XtEgrad = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(Xt, Egrad);
0075         symXtEgrad = <a href="../../../manopt/tools/multisym.html" class="code" title="function Y = multisym(X)">multisym</a>(XtEgrad);
0076         XtEhess = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(Xt, Ehess);
0077         Rhess = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>( XtEhess - <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(H, symXtEgrad) );
0078     <span class="keyword">end</span>
0079     
0080     M.retr = @<a href="#_sub2" class="code" title="subfunction Y = retraction(X, U, t)">retraction</a>;
0081     <a name="_sub2" href="#_subfunctions" class="code">function Y = retraction(X, U, t)</a>
0082         <span class="keyword">if</span> nargin == 3
0083             tU = t*U;
0084         <span class="keyword">else</span>
0085             tU = U;
0086         <span class="keyword">end</span>
0087         Y = X + <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, tU);
0088         <span class="keyword">for</span> i = 1 : k
0089             <span class="comment">% This QR-based retraction is only a first-order approximation</span>
0090             <span class="comment">% of the exponential map, not a second-order one.</span>
0091             [Q, R] = qr(Y(:, :, i));
0092             <span class="comment">% The instruction with R ensures we are not flipping signs</span>
0093             <span class="comment">% of some columns, which should never happen in modern Matlab</span>
0094             <span class="comment">% versions but may be an issue with older versions.</span>
0095             Y(:, :, i) = Q * diag(sign(sign(diag(R))+.5));
0096             <span class="comment">% This is guaranteed to always yield orthogonal matrices with</span>
0097             <span class="comment">% determinant +1. Simply look at the eigenvalues of a skew</span>
0098             <span class="comment">% symmetric matrix, than at those of identity plus that matrix,</span>
0099             <span class="comment">% and compute their product for the determinant: it's stricly</span>
0100             <span class="comment">% positive in all cases.</span>
0101         <span class="keyword">end</span>
0102     <span class="keyword">end</span>
0103     
0104     <span class="comment">% A second order retraction is implemented here. To force its use,</span>
0105     <span class="comment">% after creating the factory M, execute M.retr = M.retr2.</span>
0106     M.retr2 = @<a href="#_sub3" class="code" title="subfunction Y = retraction2(X, U, t)">retraction2</a>;
0107     <a name="_sub3" href="#_subfunctions" class="code">function Y = retraction2(X, U, t)</a>
0108         <span class="keyword">if</span> nargin == 3
0109             tU = t*U;
0110         <span class="keyword">else</span>
0111             tU = U;
0112         <span class="keyword">end</span>
0113         Y = X + <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, tU);
0114         <span class="keyword">for</span> i = 1 : k
0115             [Uk, ~, Vk] = svd(Y(:, :, k));
0116             Y(:, :, k) = Uk*Vk';
0117         <span class="keyword">end</span>
0118     <span class="keyword">end</span>
0119     
0120     M.exp = @<a href="#_sub4" class="code" title="subfunction Y = exponential(X, U, t)">exponential</a>;
0121     <a name="_sub4" href="#_subfunctions" class="code">function Y = exponential(X, U, t)</a>
0122         <span class="keyword">if</span> nargin == 3
0123             exptU = t*U;
0124         <span class="keyword">else</span>
0125             exptU = U;
0126         <span class="keyword">end</span>
0127         <span class="keyword">for</span> i = 1 : k
0128             exptU(:, :, i) = expm(exptU(:, :, i));
0129         <span class="keyword">end</span>
0130         Y = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, exptU);
0131     <span class="keyword">end</span>
0132     
0133     M.log = @<a href="#_sub5" class="code" title="subfunction U = logarithm(X, Y)">logarithm</a>;
0134     <a name="_sub5" href="#_subfunctions" class="code">function U = logarithm(X, Y)</a>
0135         U = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X), Y);
0136         <span class="keyword">for</span> i = 1 : k
0137             <span class="comment">% The result of logm should be real in theory, but it is</span>
0138             <span class="comment">% numerically useful to force it.</span>
0139             U(:, :, i) = real(logm(U(:, :, i)));
0140         <span class="keyword">end</span>
0141         <span class="comment">% Ensure the tangent vector is in the Lie algebra.</span>
0142         U = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(U);
0143     <span class="keyword">end</span>
0144 
0145     M.hash = @(X) [<span class="string">'z'</span> <a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>(X(:))];
0146     
0147     M.rand = @() <a href="randrot.html" class="code" title="function R = randrot(n, N)">randrot</a>(n, k);
0148     
0149     M.randvec = @<a href="#_sub6" class="code" title="subfunction U = randomvec(X) ">randomvec</a>;
0150     <a name="_sub6" href="#_subfunctions" class="code">function U = randomvec(X) </a><span class="comment">%#ok&lt;INUSD&gt;</span>
0151         U = <a href="randskew.html" class="code" title="function S = randskew(n, N)">randskew</a>(n, k);
0152         nrmU = sqrt(U(:).'*U(:));
0153         U = U / nrmU;
0154     <span class="keyword">end</span>
0155     
0156     M.lincomb = @<a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>;
0157     
0158     M.zerovec = @(x) zeros(n, n, k);
0159     
0160     M.transp = @(x1, x2, d) d;
0161     
0162     M.pairmean = @<a href="#_sub7" class="code" title="subfunction Y = pairmean(X1, X2)">pairmean</a>;
0163     <a name="_sub7" href="#_subfunctions" class="code">function Y = pairmean(X1, X2)</a>
0164         V = M.log(X1, X2);
0165         Y = M.exp(X1, .5*V);
0166     <span class="keyword">end</span>
0167     
0168     M.dist = @(x, y) M.norm(x, M.log(x, y));
0169     
0170     M.vec = @(x, u_mat) u_mat(:);
0171     M.mat = @(x, u_vec) reshape(u_vec, [n, n, k]);
0172     M.vecmatareisometries = @() true;
0173 
0174 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 08-Sep-2017 12:43:19 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>