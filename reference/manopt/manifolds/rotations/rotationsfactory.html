<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of rotationsfactory</title>
  <meta name="keywords" content="rotationsfactory">
  <meta name="description" content="Returns a manifold structure to optimize over rotation matrices.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">manifolds</a> &gt; <a href="index.html">rotations</a> &gt; rotationsfactory.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\manifolds\rotations&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>rotationsfactory
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Returns a manifold structure to optimize over rotation matrices.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function M = rotationsfactory(n, k) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Returns a manifold structure to optimize over rotation matrices.
 
 function M = rotationsfactory(n)
 function M = rotationsfactory(n, k)

 Special orthogonal group (the manifold of rotations): deals with matrices
 R of size n x n x k (or n x n if k = 1, which is the default) such that
 each n x n matrix is orthogonal, i.e., X'*X = eye(n) if k = 1, or
 X(:, :, i)' * X(:, :, i) = eye(n) for i = 1 : k if k &gt; 1. Furthermore,
 all these matrices have determinant +1.

 This is a description of SO(n)^k with the induced metric from the
 embedding space (R^nxn)^k, i.e., this manifold is a Riemannian
 submanifold of (R^nxn)^k endowed with the usual trace inner product.

 This is important:
 Tangent vectors are represented in the Lie algebra, i.e., as skew
 symmetric matrices. Use the function M.tangent2ambient(X, H) to switch
 from the Lie algebra representation to the embedding space
 representation. This is often necessary when defining
 problem.ehess(X, H), as the input H will then be a skew-symmetric matrix
 (but the output must not be, as the output is the Hessian in the
 embedding Euclidean space.)

 By default, the retraction is only a first-order approximation of the
 exponential. To force the use of a second-order approximation, call

     M.retr = M.retr_polar;
     M.invretr = M.invretr_polar;

 after creating M. This switches from a QR-based computation to an
 SVD-based computation.

 For n = 3, the code uses Rodrigues formulas for exp and log. Since most
 optimization algorithms use retractions by default, you can force those
 algorithms to use the Rodrigues formulas as follows:
  
     M.retr = M.exp;
     M.invretr = M.log;


 By default, k = 1.


 See also: stiefelfactory</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="randrot.html" class="code" title="function Q = randrot(n, N)">randrot</a>	Generates uniformly random rotation matrices.</li><li><a href="randskew.html" class="code" title="function S = randskew(n, N)">randskew</a>	Generates random skew symmetric matrices with normal entries.</li><li><a href="../../../manopt/manifolds/stiefel/solve_for_triu.html" class="code" title="function X = solve_for_triu(A, H)">solve_for_triu</a>	Solve the linear matrix equation AX + X'A' = H for X upper triangular.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/norm.html" class="code" title="function res = norm( x, safe )">norm</a>	NORM Norm of a TT/MPS tensor.</li><li><a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS_block/norm.html" class="code" title="function res = norm( x )">norm</a>	NORM Norm of a TT/MPS block-mu tensor.</li><li><a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>	Computes the MD5 hash of input data.</li><li><a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>	Linear combination function for tangent vectors represented as matrices.</li><li><a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>	Matrix multiply 2-D slices of N-D arrays</li><li><a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>	Returns the skew-symmetric parts of the matrices in the 3D matrix X.</li><li><a href="../../../manopt/tools/multisym.html" class="code" title="function Y = multisym(X)">multisym</a>	Returns the symmetric parts of the matrices in a 3D array</li><li><a href="../../../manopt/tools/multitransp.html" class="code" title="function B = multitransp(A, unused) %#ok<INUSD>">multitransp</a>	Transpose the matrix slices of an N-D array (no complex conjugate)</li><li><a href="../../../manopt/tools/qr_unique.html" class="code" title="function [Q, R] = qr_unique(A)">qr_unique</a>	Thin QR factorization ensuring diagonal of R is real, positive if possible.</li><li><a href="../../../manopt/tools/sylvester_nochecks.html" class="code" title="function X = sylvester_nochecks(A, B, C)">sylvester_nochecks</a>	Solve Sylvester equation without input checks.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/generalized_procrustes.html" class="code" title="function [A, R] = generalized_procrustes(A_measure)">generalized_procrustes</a>	Rotationally align clouds of points (generalized Procrustes problem)</li><li><a href="../../../manopt/manifolds/specialeuclidean/specialeuclideanfactory.html" class="code" title="function M = specialeuclideanfactory(n, k)">specialeuclideanfactory</a>	Returns a manifold structure to optimize over the special Euclidean group</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Rhess = ehess2rhess(X, Egrad, Ehess, H)</a></li><li><a href="#_sub2" class="code">function Y = retraction_qr(X, U, t)</a></li><li><a href="#_sub3" class="code">function S = inverse_retraction_qr(X, Y)</a></li><li><a href="#_sub4" class="code">function Y = retraction_polar(X, U, t)</a></li><li><a href="#_sub5" class="code">function S = inverse_retraction_polar(X, Y)</a></li><li><a href="#_sub6" class="code">function Y = exponential(X, U, t)</a></li><li><a href="#_sub7" class="code">function U = logarithm(X, Y)</a></li><li><a href="#_sub8" class="code">function U = randomvec(X)</a></li><li><a href="#_sub9" class="code">function Y = pairmean(X1, X2)</a></li><li><a href="#_sub10" class="code">function R = expm_SO3(phi)</a></li><li><a href="#_sub11" class="code">function phi = logm_SO3(R)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function M = rotationsfactory(n, k)</a>
0002 <span class="comment">% Returns a manifold structure to optimize over rotation matrices.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function M = rotationsfactory(n)</span>
0005 <span class="comment">% function M = rotationsfactory(n, k)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Special orthogonal group (the manifold of rotations): deals with matrices</span>
0008 <span class="comment">% R of size n x n x k (or n x n if k = 1, which is the default) such that</span>
0009 <span class="comment">% each n x n matrix is orthogonal, i.e., X'*X = eye(n) if k = 1, or</span>
0010 <span class="comment">% X(:, :, i)' * X(:, :, i) = eye(n) for i = 1 : k if k &gt; 1. Furthermore,</span>
0011 <span class="comment">% all these matrices have determinant +1.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% This is a description of SO(n)^k with the induced metric from the</span>
0014 <span class="comment">% embedding space (R^nxn)^k, i.e., this manifold is a Riemannian</span>
0015 <span class="comment">% submanifold of (R^nxn)^k endowed with the usual trace inner product.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% This is important:</span>
0018 <span class="comment">% Tangent vectors are represented in the Lie algebra, i.e., as skew</span>
0019 <span class="comment">% symmetric matrices. Use the function M.tangent2ambient(X, H) to switch</span>
0020 <span class="comment">% from the Lie algebra representation to the embedding space</span>
0021 <span class="comment">% representation. This is often necessary when defining</span>
0022 <span class="comment">% problem.ehess(X, H), as the input H will then be a skew-symmetric matrix</span>
0023 <span class="comment">% (but the output must not be, as the output is the Hessian in the</span>
0024 <span class="comment">% embedding Euclidean space.)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% By default, the retraction is only a first-order approximation of the</span>
0027 <span class="comment">% exponential. To force the use of a second-order approximation, call</span>
0028 <span class="comment">%</span>
0029 <span class="comment">%     M.retr = M.retr_polar;</span>
0030 <span class="comment">%     M.invretr = M.invretr_polar;</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% after creating M. This switches from a QR-based computation to an</span>
0033 <span class="comment">% SVD-based computation.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% For n = 3, the code uses Rodrigues formulas for exp and log. Since most</span>
0036 <span class="comment">% optimization algorithms use retractions by default, you can force those</span>
0037 <span class="comment">% algorithms to use the Rodrigues formulas as follows:</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%     M.retr = M.exp;</span>
0040 <span class="comment">%     M.invretr = M.log;</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% By default, k = 1.</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% See also: stiefelfactory</span>
0047 
0048 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0049 <span class="comment">% Original author: Nicolas Boumal, Dec. 30, 2012.</span>
0050 <span class="comment">% Contributors: Spencer Kraisler</span>
0051 <span class="comment">% Change log:</span>
0052 <span class="comment">%   Jan. 31, 2013 (NB)</span>
0053 <span class="comment">%       Added egrad2rgrad and ehess2rhess</span>
0054 <span class="comment">%   Oct. 21, 2016 (NB)</span>
0055 <span class="comment">%       Added M.retr2: a second-order retraction based on SVD.</span>
0056 <span class="comment">%   July 18, 2018 (NB)</span>
0057 <span class="comment">%       Fixed a bug in M.retr2 (only relevant for k &gt; 1).</span>
0058 <span class="comment">%       Added inverse retraction as M.invretr.</span>
0059 <span class="comment">%       Retraction and inverse also available as M.retr_qr, M.invretr_qr.</span>
0060 <span class="comment">%       Renamed M.retr2 to M.retr_polar, and implemented M.invretr_polar.</span>
0061 <span class="comment">%       For backward compatibility, M.retr2 is still defined and is now</span>
0062 <span class="comment">%       equal to M.retr_polar. There is no M.invretr2.</span>
0063 <span class="comment">%   Sep.  06, 2018 (NB)</span>
0064 <span class="comment">%       Added M.isotransp, which is equal to M.transp since it is</span>
0065 <span class="comment">%       isometric.</span>
0066 <span class="comment">%   June 18, 2019 (NB)</span>
0067 <span class="comment">%       Using qr_unique for the QR-based retraction.</span>
0068 <span class="comment">%   Nov. 19, 2019 (NB)</span>
0069 <span class="comment">%       Clarified that the isometric transport is not parallel transport</span>
0070 <span class="comment">%       along geodesics.</span>
0071 <span class="comment">%   June 10, 2022 (NB)</span>
0072 <span class="comment">%       Following input from Spencer Kraisler on Manopt forum, added code</span>
0073 <span class="comment">%       for Rodrigues formulas, now used instead of expm / logm for n = 3.</span>
0074 
0075     
0076     <span class="keyword">if</span> ~exist(<span class="string">'k'</span>, <span class="string">'var'</span>) || isempty(k)
0077         k = 1;
0078     <span class="keyword">end</span>
0079     
0080     <span class="keyword">if</span> k == 1
0081         M.name = @() sprintf(<span class="string">'Rotations manifold SO(%d)'</span>, n);
0082     <span class="keyword">elseif</span> k &gt; 1
0083         M.name = @() sprintf(<span class="string">'Product rotations manifold SO(%d)^%d'</span>, n, k);
0084     <span class="keyword">else</span>
0085         error(<span class="string">'k must be an integer no less than 1.'</span>);
0086     <span class="keyword">end</span>
0087     
0088     M.dim = @() k*nchoosek(n, 2);
0089     
0090     M.inner = @(x, d1, d2) d1(:).'*d2(:);
0091     
0092     M.norm = @(x, d) <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/norm.html" class="code" title="function res = norm( x, safe )">norm</a>(d(:));
0093     
0094     M.typicaldist = @() pi*sqrt(n*k);
0095     
0096     M.proj = @(X, H) <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(<a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function B = multitransp(A, unused) %#ok<INUSD>">multitransp</a>(X), H));
0097     
0098     M.tangent = @(X, H) <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(H);
0099     
0100     M.tangent2ambient_is_identity = false;
0101     M.tangent2ambient = @(X, U) <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(X, U);
0102     
0103     M.egrad2rgrad = M.proj;
0104     
0105     M.ehess2rhess = @<a href="#_sub1" class="code" title="subfunction Rhess = ehess2rhess(X, Egrad, Ehess, H)">ehess2rhess</a>;
0106     <a name="_sub1" href="#_subfunctions" class="code">function Rhess = ehess2rhess(X, Egrad, Ehess, H)</a>
0107         <span class="comment">% Reminder : H contains skew-symmeric matrices. The actual</span>
0108         <span class="comment">% direction that the point X is moved along is X*H.</span>
0109         Xt = <a href="../../../manopt/tools/multitransp.html" class="code" title="function B = multitransp(A, unused) %#ok<INUSD>">multitransp</a>(X);
0110         XtEgrad = <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(Xt, Egrad);
0111         symXtEgrad = <a href="../../../manopt/tools/multisym.html" class="code" title="function Y = multisym(X)">multisym</a>(XtEgrad);
0112         XtEhess = <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(Xt, Ehess);
0113         Rhess = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>( XtEhess - <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(H, symXtEgrad) );
0114     <span class="keyword">end</span>
0115     
0116     <span class="comment">% This QR-based retraction is only a first-order approximation</span>
0117     <span class="comment">% of the exponential map, not a second-order one.</span>
0118     M.retr_qr = @<a href="#_sub2" class="code" title="subfunction Y = retraction_qr(X, U, t)">retraction_qr</a>;
0119     <a name="_sub2" href="#_subfunctions" class="code">function Y = retraction_qr(X, U, t)</a>
0120         <span class="comment">% It is necessary to call qr_unique rather than simply qr to ensure</span>
0121         <span class="comment">% this is a retraction, to avoid spurious column sign flips.</span>
0122         XU = <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(X, U);
0123         <span class="keyword">if</span> nargin &lt; 3
0124             Y = <a href="../../../manopt/tools/qr_unique.html" class="code" title="function [Q, R] = qr_unique(A)">qr_unique</a>(X + XU);
0125         <span class="keyword">else</span>
0126             Y = <a href="../../../manopt/tools/qr_unique.html" class="code" title="function [Q, R] = qr_unique(A)">qr_unique</a>(X + t*XU);
0127         <span class="keyword">end</span>
0128         <span class="comment">% This is guaranteed to always yield orthogonal matrices with</span>
0129         <span class="comment">% determinant +1. Indeed: look at the eigenvalues of a skew</span>
0130         <span class="comment">% symmetric matrix, then at those of &quot;identity plus that matrix&quot;,</span>
0131         <span class="comment">% and compute their product for the determinant: it is strictly</span>
0132         <span class="comment">% positive in all cases.</span>
0133     <span class="keyword">end</span>
0134 
0135     M.invretr_qr = @<a href="#_sub3" class="code" title="subfunction S = inverse_retraction_qr(X, Y)">inverse_retraction_qr</a>;
0136     <a name="_sub3" href="#_subfunctions" class="code">function S = inverse_retraction_qr(X, Y)</a>
0137         
0138         <span class="comment">% Assume k = 1 in this explanation:</span>
0139         <span class="comment">% If Y = Retr_X(XS) where S is a skew-symmetric matrix, then</span>
0140         <span class="comment">%  X(I+S) = YR</span>
0141         <span class="comment">% for some upper triangular matrix R. Multiply with X' on the left:</span>
0142         <span class="comment">%  I + S = (X'Y) R    (*)</span>
0143         <span class="comment">% Since S is skew-symmetric, add the transpose of this equation:</span>
0144         <span class="comment">%  2I + 0 = (X'Y) R + R' (X'Y)'</span>
0145         <span class="comment">% We can solve for R by calling solve_for_triu, then solve for S</span>
0146         <span class="comment">% using equation (*).</span>
0147         R = zeros(n, n, k);
0148         XtY = <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function B = multitransp(A, unused) %#ok<INUSD>">multitransp</a>(X), Y);
0149         H = 2*eye(n);
0150         <span class="keyword">for</span> kk = 1 : k
0151             R(:, :, kk) = <a href="../../../manopt/manifolds/stiefel/solve_for_triu.html" class="code" title="function X = solve_for_triu(A, H)">solve_for_triu</a>(XtY(:, :, kk), H);
0152         <span class="keyword">end</span>
0153         <span class="comment">% In exact arithmetic, taking the skew-symmetric part has the</span>
0154         <span class="comment">% effect of subtracting the identity from each slice; in inexact</span>
0155         <span class="comment">% arithmetic, taking the skew-symmetric part is beneficial to</span>
0156         <span class="comment">% further enforce tangency.</span>
0157         S = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(<a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(XtY, R));
0158         
0159     <span class="keyword">end</span>
0160     
0161     <span class="comment">% A second-order retraction is implemented here. To force its use,</span>
0162     <span class="comment">% after creating the factory M, execute M.retr = M.retr_polar.</span>
0163     M.retr_polar = @<a href="#_sub4" class="code" title="subfunction Y = retraction_polar(X, U, t)">retraction_polar</a>;
0164     <a name="_sub4" href="#_subfunctions" class="code">function Y = retraction_polar(X, U, t)</a>
0165         <span class="keyword">if</span> nargin == 3
0166             tU = t*U;
0167         <span class="keyword">else</span>
0168             tU = U;
0169         <span class="keyword">end</span>
0170         Y = X + <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(X, tU);
0171         <span class="keyword">for</span> kk = 1 : k
0172             [Uk, ~, Vk] = svd(Y(:, :, kk));
0173             Y(:, :, kk) = Uk*Vk';
0174             <span class="comment">% One can check that det(Uk*Vk') = det(X) for all skew-sym U.</span>
0175             <span class="comment">% That's because X + XU = X(I+U), and U is normal (UU' = U'U)</span>
0176             <span class="comment">% hence it can be unitarily diagonalized as U = WDW' with W</span>
0177             <span class="comment">% unitary and D diagonal; the eigenvalues of U are purely</span>
0178             <span class="comment">% imaginary because U+U' = 0, and they come in conjugate pairs</span>
0179             <span class="comment">% because U is real (there's a zero eigenvalue if n is odd).</span>
0180             <span class="comment">% This way, it follows that</span>
0181             <span class="comment">%   det(X+XU) = det(X)det(I+U) = det(X)det(I+D)</span>
0182             <span class="comment">% and det(I+D) is real, strictly positive provided n &gt;= 2.</span>
0183         <span class="keyword">end</span>
0184     <span class="keyword">end</span>
0185 
0186     M.invretr_polar = @<a href="#_sub5" class="code" title="subfunction S = inverse_retraction_polar(X, Y)">inverse_retraction_polar</a>;
0187     <a name="_sub5" href="#_subfunctions" class="code">function S = inverse_retraction_polar(X, Y)</a>
0188         
0189         <span class="comment">% Assume k = 1 in this explanation:</span>
0190         <span class="comment">% If Y = Retr_X(XS) where S is a skew-symmetric matrix, then</span>
0191         <span class="comment">%  X(I+S) = YM</span>
0192         <span class="comment">% for some symmetric matrix M. Multiply with X' on the left:</span>
0193         <span class="comment">%  I + S = (X'Y) M    (*)</span>
0194         <span class="comment">% Since S is skew-symmetric, add the transpose of this equation:</span>
0195         <span class="comment">%  2I + 0 = (X'Y) M + M (X'Y)'</span>
0196         <span class="comment">% We can solve for M by calling sylvester, then solve for S</span>
0197         <span class="comment">% using equation (*).</span>
0198         MM = zeros(n, n, k);
0199         XtY = <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function B = multitransp(A, unused) %#ok<INUSD>">multitransp</a>(X), Y);
0200         H = 2*eye(n);
0201         <span class="keyword">for</span> kk = 1 : k
0202             MM(:, :, kk) = <a href="../../../manopt/tools/sylvester_nochecks.html" class="code" title="function X = sylvester_nochecks(A, B, C)">sylvester_nochecks</a>(XtY(:, :, kk), XtY(:, :, kk)', H);
0203         <span class="keyword">end</span>
0204         <span class="comment">% In exact arithmetic, taking the skew-symmetric part has the</span>
0205         <span class="comment">% effect of subtracting the identity from each slice; in inexact</span>
0206         <span class="comment">% arithmetic, taking the skew-symmetric part is beneficial to</span>
0207         <span class="comment">% further enforce tangency.</span>
0208         S = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(<a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(XtY, MM));
0209         
0210     <span class="keyword">end</span>
0211 
0212     <span class="comment">% By default, use QR retraction</span>
0213     M.retr = M.retr_qr;
0214     M.invretr = M.invretr_qr;
0215     
0216     <span class="comment">% For backward compatibility:</span>
0217     M.retr2 = M.retr_polar;
0218     
0219     <span class="comment">% Special case: for n = 3, we use Rodrigues formulas for expm / logm.</span>
0220     <span class="keyword">if</span> n == 3
0221         myexpm = @<a href="#_sub10" class="code" title="subfunction R = expm_SO3(phi)">expm_SO3</a>;
0222         mylogm = @<a href="#_sub11" class="code" title="subfunction phi = logm_SO3(R)">logm_SO3</a>;
0223     <span class="keyword">else</span>
0224         myexpm = @expm;
0225         mylogm = @logm;
0226     <span class="keyword">end</span>
0227 
0228     M.exp = @<a href="#_sub6" class="code" title="subfunction Y = exponential(X, U, t)">exponential</a>;
0229     <a name="_sub6" href="#_subfunctions" class="code">function Y = exponential(X, U, t)</a>
0230         <span class="keyword">if</span> nargin == 3
0231             exptU = t*U;
0232         <span class="keyword">else</span>
0233             exptU = U;
0234         <span class="keyword">end</span>
0235         <span class="keyword">for</span> kk = 1 : k
0236             exptU(:, :, kk) = myexpm(exptU(:, :, kk));
0237         <span class="keyword">end</span>
0238         Y = <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(X, exptU);
0239     <span class="keyword">end</span>
0240     
0241     M.log = @<a href="#_sub7" class="code" title="subfunction U = logarithm(X, Y)">logarithm</a>;
0242     <a name="_sub7" href="#_subfunctions" class="code">function U = logarithm(X, Y)</a>
0243         U = <a href="../../../manopt/tools/multiprod.html" class="code" title="function C = multiprod(A, B, unused1, unused2) %#ok<INUSD>">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function B = multitransp(A, unused) %#ok<INUSD>">multitransp</a>(X), Y);
0244         <span class="keyword">for</span> kk = 1 : k
0245             <span class="comment">% The result of logm should be real in theory, but it is</span>
0246             <span class="comment">% numerically useful to force it.</span>
0247             U(:, :, kk) = real(mylogm(U(:, :, kk)));
0248         <span class="keyword">end</span>
0249         <span class="comment">% Ensure the tangent vector is in the Lie algebra.</span>
0250         U = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(U);
0251     <span class="keyword">end</span>
0252 
0253     M.hash = @(X) [<span class="string">'z'</span> <a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>(X(:))];
0254     
0255     M.rand = @() <a href="randrot.html" class="code" title="function Q = randrot(n, N)">randrot</a>(n, k);
0256     
0257     M.randvec = @<a href="#_sub8" class="code" title="subfunction U = randomvec(X) ">randomvec</a>;
0258     <a name="_sub8" href="#_subfunctions" class="code">function U = randomvec(X) </a><span class="comment">%#ok&lt;INUSD&gt;</span>
0259         U = <a href="randskew.html" class="code" title="function S = randskew(n, N)">randskew</a>(n, k);
0260         nrmU = sqrt(U(:).'*U(:));
0261         U = U / nrmU;
0262     <span class="keyword">end</span>
0263     
0264     M.lincomb = @<a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>;
0265     
0266     M.zerovec = @(x) zeros(n, n, k);
0267     
0268     <span class="comment">% Cheap vector transport</span>
0269     M.transp = @(x1, x2, d) d;
0270     <span class="comment">% This transporter is isometric (but it is /not/ parallel transport</span>
0271     <span class="comment">% along geodesics.)</span>
0272     M.isotransp = M.transp;
0273     
0274     M.pairmean = @<a href="#_sub9" class="code" title="subfunction Y = pairmean(X1, X2)">pairmean</a>;
0275     <a name="_sub9" href="#_subfunctions" class="code">function Y = pairmean(X1, X2)</a>
0276         V = M.log(X1, X2);
0277         Y = M.exp(X1, .5*V);
0278     <span class="keyword">end</span>
0279     
0280     M.dist = @(x, y) M.norm(x, M.log(x, y));
0281     
0282     M.vec = @(x, u_mat) u_mat(:);
0283     M.mat = @(x, u_vec) reshape(u_vec, [n, n, k]);
0284     M.vecmatareisometries = @() true;
0285     M.lie_identity = @() repmat(eye(n), [1, 1, k]);
0286 
0287 <span class="keyword">end</span>
0288 
0289 <span class="comment">% The following code is based on a proposal by Spencer Kraisler, June 2022.</span>
0290 <span class="comment">% https://groups.google.com/g/manopttoolbox/c/KwdpyLiPUBw/m/aS-Yjq-pAwAJ</span>
0291 <span class="comment">%</span>
0292 <span class="comment">% Rodrigues formula for matrix exponential on SO(3): R = expm(phi)</span>
0293 <a name="_sub10" href="#_subfunctions" class="code">function R = expm_SO3(phi)</a>
0294     phi_vee = [-phi(2, 3); phi(1, 3); -phi(1, 2)];
0295     norm_phi_vee = <a href="../../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/@TTeMPS/norm.html" class="code" title="function res = norm( x, safe )">norm</a>(phi_vee);
0296     <span class="keyword">if</span> norm_phi_vee &gt; 0
0297         q1 = sin(norm_phi_vee)/norm_phi_vee;
0298         r = norm_phi_vee / 2;
0299         q2 = (sin(r)/r).^2 / 2;
0300         R = eye(3) + q1*phi + q2*phi^2;
0301     <span class="keyword">else</span>
0302         R = eye(3);
0303     <span class="keyword">end</span>
0304 <span class="keyword">end</span>
0305 <span class="comment">% Rodrigues formula for inverting matrix exp on SO(3): phi = logm(R)</span>
0306 <a name="_sub11" href="#_subfunctions" class="code">function phi = logm_SO3(R)</a>
0307     t = trace(R);
0308     norm_t = real(acos((t - 1)/2));
0309     <span class="keyword">if</span> norm_t &gt; 0 <span class="comment">% could fail even when trace(R) &lt; 3, because sensitive</span>
0310         q = .5*norm_t/sin(norm_t);
0311     <span class="keyword">else</span>
0312         q = .5;   <span class="comment">% even with this, phi (below) could be nonzero</span>
0313     <span class="keyword">end</span>
0314     phi = q * [R(3, 2) - R(2, 3); R(1, 3) - R(3, 1); R(2, 1) - R(1, 2)];
0315     phi = [0 -phi(3) phi(2); phi(3) 0 -phi(1); -phi(2) phi(1) 0];
0316 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Sep-2022 13:18:25 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>