<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of rotationsfactory</title>
  <meta name="keywords" content="rotationsfactory">
  <meta name="description" content="Returns a manifold structure to optimize over rotation matrices.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">manifolds</a> &gt; <a href="index.html">rotations</a> &gt; rotationsfactory.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\manifolds\rotations&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>rotationsfactory
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Returns a manifold structure to optimize over rotation matrices.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function M = rotationsfactory(n, k) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Returns a manifold structure to optimize over rotation matrices.
 
 function M = rotationsfactory(n)
 function M = rotationsfactory(n, k)

 Special orthogonal group (the manifold of rotations): deals with matrices
 R of size n x n x k (or n x n if k = 1, which is the default) such that
 each n x n matrix is orthogonal, i.e., X'*X = eye(n) if k = 1, or
 X(:, :, i)' * X(:, :, i) = eye(n) for i = 1 : k if k &gt; 1. Furthermore,
 all these matrices have determinant +1.

 This is a description of SO(n)^k with the induced metric from the
 embedding space (R^nxn)^k, i.e., this manifold is a Riemannian
 submanifold of (R^nxn)^k endowed with the usual trace inner product.

 This is important:
 Tangent vectors are represented in the Lie algebra, i.e., as skew
 symmetric matrices. Use the function M.tangent2ambient(X, H) to switch
 from the Lie algebra representation to the embedding space
 representation. This is often necessary when defining
 problem.ehess(X, H), as the input H will then be a skew-symmetric matrix
 (but the output must not be, as the output is the Hessian in the
 embedding Euclidean space.)

 By default, the retraction is only a first-order approximation of the
 exponential. To force the use of a second-order approximation, call
 M.retr = M.retr2 after creating M. This switches from a QR-based
 computation to an SVD-based computation. This is notably useful for the
 checkhessian tool.

 By default, k = 1.

 See also: stiefelfactory</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="randrot.html" class="code" title="function R = randrot(n, N)">randrot</a>	Generates uniformly random rotation matrices.</li><li><a href="randskew.html" class="code" title="function S = randskew(n, N)">randskew</a>	Generates random skew symmetric matrices with normal entries.</li><li><a href="../../../manopt/manifolds/stiefel/solve_for_triu.html" class="code" title="function X = solve_for_triu(A, H)">solve_for_triu</a>	Solve the linear matrix equation AX + X'A' = H for X upper triangular.</li><li><a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>	Computes the MD5 hash of input data.</li><li><a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>	Linear combination function for tangent vectors represented as matrices.</li><li><a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>	Multiplying 1-D or 2-D subarrays contained in two N-D arrays.</li><li><a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>	Returns the skew-symmetric parts of the matrices in the 3D matrix X.</li><li><a href="../../../manopt/tools/multisym.html" class="code" title="function Y = multisym(X)">multisym</a>	Returns the symmetric parts of the matrices in the 3D matrix X</li><li><a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>	Transposing arrays of matrices.</li><li><a href="../../../manopt/tools/sylvester_nochecks.html" class="code" title="function [X, unique] = sylvester_nochecks(A, B, C)">sylvester_nochecks</a>	Solve Sylvester equation without input checks.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/generalized_procrustes.html" class="code" title="function [A, R] = generalized_procrustes(A_measure)">generalized_procrustes</a>	Rotationally align clouds of points (generalized Procrustes problem)</li><li><a href="../../../manopt/manifolds/specialeuclidean/specialeuclideanfactory.html" class="code" title="function M = specialeuclideanfactory(n, k)">specialeuclideanfactory</a>	Returns a manifold structure to optimize over the special Euclidean group</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Rhess = ehess2rhess(X, Egrad, Ehess, H)</a></li><li><a href="#_sub2" class="code">function Y = retraction_qr(X, U, t)</a></li><li><a href="#_sub3" class="code">function S = inverse_retraction_qr(X, Y)</a></li><li><a href="#_sub4" class="code">function Y = retraction_polar(X, U, t)</a></li><li><a href="#_sub5" class="code">function S = inverse_retraction_polar(X, Y)</a></li><li><a href="#_sub6" class="code">function Y = exponential(X, U, t)</a></li><li><a href="#_sub7" class="code">function U = logarithm(X, Y)</a></li><li><a href="#_sub8" class="code">function U = randomvec(X)</a></li><li><a href="#_sub9" class="code">function Y = pairmean(X1, X2)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function M = rotationsfactory(n, k)</a>
0002 <span class="comment">% Returns a manifold structure to optimize over rotation matrices.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function M = rotationsfactory(n)</span>
0005 <span class="comment">% function M = rotationsfactory(n, k)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Special orthogonal group (the manifold of rotations): deals with matrices</span>
0008 <span class="comment">% R of size n x n x k (or n x n if k = 1, which is the default) such that</span>
0009 <span class="comment">% each n x n matrix is orthogonal, i.e., X'*X = eye(n) if k = 1, or</span>
0010 <span class="comment">% X(:, :, i)' * X(:, :, i) = eye(n) for i = 1 : k if k &gt; 1. Furthermore,</span>
0011 <span class="comment">% all these matrices have determinant +1.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% This is a description of SO(n)^k with the induced metric from the</span>
0014 <span class="comment">% embedding space (R^nxn)^k, i.e., this manifold is a Riemannian</span>
0015 <span class="comment">% submanifold of (R^nxn)^k endowed with the usual trace inner product.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% This is important:</span>
0018 <span class="comment">% Tangent vectors are represented in the Lie algebra, i.e., as skew</span>
0019 <span class="comment">% symmetric matrices. Use the function M.tangent2ambient(X, H) to switch</span>
0020 <span class="comment">% from the Lie algebra representation to the embedding space</span>
0021 <span class="comment">% representation. This is often necessary when defining</span>
0022 <span class="comment">% problem.ehess(X, H), as the input H will then be a skew-symmetric matrix</span>
0023 <span class="comment">% (but the output must not be, as the output is the Hessian in the</span>
0024 <span class="comment">% embedding Euclidean space.)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% By default, the retraction is only a first-order approximation of the</span>
0027 <span class="comment">% exponential. To force the use of a second-order approximation, call</span>
0028 <span class="comment">% M.retr = M.retr2 after creating M. This switches from a QR-based</span>
0029 <span class="comment">% computation to an SVD-based computation. This is notably useful for the</span>
0030 <span class="comment">% checkhessian tool.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% By default, k = 1.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% See also: stiefelfactory</span>
0035 
0036 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0037 <span class="comment">% Original author: Nicolas Boumal, Dec. 30, 2012.</span>
0038 <span class="comment">% Contributors:</span>
0039 <span class="comment">% Change log:</span>
0040 <span class="comment">%   Jan. 31, 2013 (NB)</span>
0041 <span class="comment">%       Added egrad2rgrad and ehess2rhess</span>
0042 <span class="comment">%   Oct. 21, 2016 (NB)</span>
0043 <span class="comment">%       Added M.retr2: a second-order retraction based on SVD.</span>
0044 <span class="comment">%   July 18, 2018 (NB)</span>
0045 <span class="comment">%       Fixed a bug in M.retr2 (only relevant for k &gt; 1).</span>
0046 <span class="comment">%       Added inverse retraction as M.invretr.</span>
0047 <span class="comment">%       Retraction and inverse also available as M.retr_qr, M.invretr_qr.</span>
0048 <span class="comment">%       Renamed M.retr2 to M.retr_polar, and implemented M.invretr_polar.</span>
0049 <span class="comment">%       For backward compatibility, M.retr2 is still defined and is now</span>
0050 <span class="comment">%       equal to M.retr_polar. There is no M.invretr2.</span>
0051 <span class="comment">%   Sep.  06, 2018 (NB)</span>
0052 <span class="comment">%       Added M.isotransp, which is equal to M.transp since it is</span>
0053 <span class="comment">%       isometric.</span>
0054 
0055     
0056     <span class="keyword">if</span> ~exist(<span class="string">'k'</span>, <span class="string">'var'</span>) || isempty(k)
0057         k = 1;
0058     <span class="keyword">end</span>
0059     
0060     <span class="keyword">if</span> k == 1
0061         M.name = @() sprintf(<span class="string">'Rotations manifold SO(%d)'</span>, n);
0062     <span class="keyword">elseif</span> k &gt; 1
0063         M.name = @() sprintf(<span class="string">'Product rotations manifold SO(%d)^%d'</span>, n, k);
0064     <span class="keyword">else</span>
0065         error(<span class="string">'k must be an integer no less than 1.'</span>);
0066     <span class="keyword">end</span>
0067     
0068     M.dim = @() k*nchoosek(n, 2);
0069     
0070     M.inner = @(x, d1, d2) d1(:).'*d2(:);
0071     
0072     M.norm = @(x, d) norm(d(:));
0073     
0074     M.typicaldist = @() pi*sqrt(n*k);
0075     
0076     M.proj = @(X, H) <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(<a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X), H));
0077     
0078     M.tangent = @(X, H) <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(H);
0079     
0080     M.tangent2ambient_is_identity = false;
0081     M.tangent2ambient = @(X, U) <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, U);
0082     
0083     M.egrad2rgrad = M.proj;
0084     
0085     M.ehess2rhess = @<a href="#_sub1" class="code" title="subfunction Rhess = ehess2rhess(X, Egrad, Ehess, H)">ehess2rhess</a>;
0086     <a name="_sub1" href="#_subfunctions" class="code">function Rhess = ehess2rhess(X, Egrad, Ehess, H)</a>
0087         <span class="comment">% Reminder : H contains skew-symmeric matrices. The actual</span>
0088         <span class="comment">% direction that the point X is moved along is X*H.</span>
0089         Xt = <a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X);
0090         XtEgrad = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(Xt, Egrad);
0091         symXtEgrad = <a href="../../../manopt/tools/multisym.html" class="code" title="function Y = multisym(X)">multisym</a>(XtEgrad);
0092         XtEhess = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(Xt, Ehess);
0093         Rhess = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>( XtEhess - <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(H, symXtEgrad) );
0094     <span class="keyword">end</span>
0095     
0096     M.retr_qr = @<a href="#_sub2" class="code" title="subfunction Y = retraction_qr(X, U, t)">retraction_qr</a>;
0097     <a name="_sub2" href="#_subfunctions" class="code">function Y = retraction_qr(X, U, t)</a>
0098         <span class="keyword">if</span> nargin == 3
0099             tU = t*U;
0100         <span class="keyword">else</span>
0101             tU = U;
0102         <span class="keyword">end</span>
0103         Y = X + <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, tU);
0104         <span class="keyword">for</span> kk = 1 : k
0105             <span class="comment">% This QR-based retraction is only a first-order approximation</span>
0106             <span class="comment">% of the exponential map, not a second-order one.</span>
0107             [Q, R] = qr(Y(:, :, kk));
0108             <span class="comment">% The instruction with R ensures we are not flipping signs</span>
0109             <span class="comment">% of some columns, which should never happen in modern Matlab</span>
0110             <span class="comment">% versions but may be an issue with older versions.</span>
0111             Y(:, :, kk) = Q * diag(sign(sign(diag(R))+.5));
0112             <span class="comment">% This is guaranteed to always yield orthogonal matrices with</span>
0113             <span class="comment">% determinant +1. Simply look at the eigenvalues of a skew</span>
0114             <span class="comment">% symmetric matrix, then at those of identity plus that matrix,</span>
0115             <span class="comment">% and compute their product for the determinant: it's stricly</span>
0116             <span class="comment">% positive in all cases.</span>
0117         <span class="keyword">end</span>
0118     <span class="keyword">end</span>
0119 
0120     M.invretr_qr = @<a href="#_sub3" class="code" title="subfunction S = inverse_retraction_qr(X, Y)">inverse_retraction_qr</a>;
0121     <a name="_sub3" href="#_subfunctions" class="code">function S = inverse_retraction_qr(X, Y)</a>
0122         
0123         <span class="comment">% Assume k = 1 in this explanation:</span>
0124         <span class="comment">% If Y = Retr_X(XS) where S is a skew-symmetric matrix, then</span>
0125         <span class="comment">%  X(I+S) = YR</span>
0126         <span class="comment">% for some upper triangular matrix R. Multiply with X' on the left:</span>
0127         <span class="comment">%  I + S = (X'Y) R    (*)</span>
0128         <span class="comment">% Since S is skew-symmetric, add the transpose of this equation:</span>
0129         <span class="comment">%  2I + 0 = (X'Y) R + R' (X'Y)'</span>
0130         <span class="comment">% We can solve for R by calling solve_for_triu, then solve for S</span>
0131         <span class="comment">% using equation (*).</span>
0132         R = zeros(n, n, k);
0133         XtY = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X), Y);
0134         H = 2*eye(n);
0135         <span class="keyword">for</span> kk = 1 : k
0136             R(:, :, kk) = <a href="../../../manopt/manifolds/stiefel/solve_for_triu.html" class="code" title="function X = solve_for_triu(A, H)">solve_for_triu</a>(XtY(:, :, kk), H);
0137         <span class="keyword">end</span>
0138         <span class="comment">% In exact arithmetic, taking the skew-symmetric part has the</span>
0139         <span class="comment">% effect of subtracting the identity from each slice; in inexact</span>
0140         <span class="comment">% arithmetic, taking the skew-symmetric part is beneficial to</span>
0141         <span class="comment">% further enforce tangency.</span>
0142         S = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(<a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(XtY, R));
0143         
0144     <span class="keyword">end</span>
0145     
0146     <span class="comment">% A second order retraction is implemented here. To force its use,</span>
0147     <span class="comment">% after creating the factory M, execute M.retr = M.retr2.</span>
0148     M.retr_polar = @<a href="#_sub4" class="code" title="subfunction Y = retraction_polar(X, U, t)">retraction_polar</a>;
0149     <a name="_sub4" href="#_subfunctions" class="code">function Y = retraction_polar(X, U, t)</a>
0150         <span class="keyword">if</span> nargin == 3
0151             tU = t*U;
0152         <span class="keyword">else</span>
0153             tU = U;
0154         <span class="keyword">end</span>
0155         Y = X + <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, tU);
0156         <span class="keyword">for</span> kk = 1 : k
0157             [Uk, ~, Vk] = svd(Y(:, :, kk));
0158             Y(:, :, kk) = Uk*Vk';
0159         <span class="keyword">end</span>
0160     <span class="keyword">end</span>
0161 
0162     M.invretr_polar = @<a href="#_sub5" class="code" title="subfunction S = inverse_retraction_polar(X, Y)">inverse_retraction_polar</a>;
0163     <a name="_sub5" href="#_subfunctions" class="code">function S = inverse_retraction_polar(X, Y)</a>
0164         
0165         <span class="comment">% Assume k = 1 in this explanation:</span>
0166         <span class="comment">% If Y = Retr_X(XS) where S is a skew-symmetric matrix, then</span>
0167         <span class="comment">%  X(I+S) = YM</span>
0168         <span class="comment">% for some symmetric matrix M. Multiply with X' on the left:</span>
0169         <span class="comment">%  I + S = (X'Y) M    (*)</span>
0170         <span class="comment">% Since S is skew-symmetric, add the transpose of this equation:</span>
0171         <span class="comment">%  2I + 0 = (X'Y) M + M (X'Y)'</span>
0172         <span class="comment">% We can solve for M by calling sylvester, then solve for S</span>
0173         <span class="comment">% using equation (*).</span>
0174         MM = zeros(n, n, k);
0175         XtY = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X), Y);
0176         H = 2*eye(n);
0177         <span class="keyword">for</span> kk = 1 : k
0178             MM(:, :, kk) = <a href="../../../manopt/tools/sylvester_nochecks.html" class="code" title="function [X, unique] = sylvester_nochecks(A, B, C)">sylvester_nochecks</a>(XtY(:, :, kk), XtY(:, :, kk)', H);
0179         <span class="keyword">end</span>
0180         <span class="comment">% In exact arithmetic, taking the skew-symmetric part has the</span>
0181         <span class="comment">% effect of subtracting the identity from each slice; in inexact</span>
0182         <span class="comment">% arithmetic, taking the skew-symmetric part is beneficial to</span>
0183         <span class="comment">% further enforce tangency.</span>
0184         S = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(<a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(XtY, MM));
0185         
0186     <span class="keyword">end</span>
0187 
0188     <span class="comment">% By default, use QR retraction</span>
0189     M.retr = M.retr_qr;
0190     M.invretr = M.invretr_qr;
0191     
0192     <span class="comment">% For backward compatibility:</span>
0193     M.retr2 = M.retr_polar;
0194     
0195     M.exp = @<a href="#_sub6" class="code" title="subfunction Y = exponential(X, U, t)">exponential</a>;
0196     <a name="_sub6" href="#_subfunctions" class="code">function Y = exponential(X, U, t)</a>
0197         <span class="keyword">if</span> nargin == 3
0198             exptU = t*U;
0199         <span class="keyword">else</span>
0200             exptU = U;
0201         <span class="keyword">end</span>
0202         <span class="keyword">for</span> kk = 1 : k
0203             exptU(:, :, kk) = expm(exptU(:, :, kk));
0204         <span class="keyword">end</span>
0205         Y = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(X, exptU);
0206     <span class="keyword">end</span>
0207     
0208     M.log = @<a href="#_sub7" class="code" title="subfunction U = logarithm(X, Y)">logarithm</a>;
0209     <a name="_sub7" href="#_subfunctions" class="code">function U = logarithm(X, Y)</a>
0210         U = <a href="../../../manopt/tools/multiprod.html" class="code" title="function c = multiprod(a, b, idA, idB)">multiprod</a>(<a href="../../../manopt/tools/multitransp.html" class="code" title="function b = multitransp(a, dim)">multitransp</a>(X), Y);
0211         <span class="keyword">for</span> kk = 1 : k
0212             <span class="comment">% The result of logm should be real in theory, but it is</span>
0213             <span class="comment">% numerically useful to force it.</span>
0214             U(:, :, kk) = real(logm(U(:, :, kk)));
0215         <span class="keyword">end</span>
0216         <span class="comment">% Ensure the tangent vector is in the Lie algebra.</span>
0217         U = <a href="../../../manopt/tools/multiskew.html" class="code" title="function Y = multiskew(X)">multiskew</a>(U);
0218     <span class="keyword">end</span>
0219 
0220     M.hash = @(X) [<span class="string">'z'</span> <a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>(X(:))];
0221     
0222     M.rand = @() <a href="randrot.html" class="code" title="function R = randrot(n, N)">randrot</a>(n, k);
0223     
0224     M.randvec = @<a href="#_sub8" class="code" title="subfunction U = randomvec(X) ">randomvec</a>;
0225     <a name="_sub8" href="#_subfunctions" class="code">function U = randomvec(X) </a><span class="comment">%#ok&lt;INUSD&gt;</span>
0226         U = <a href="randskew.html" class="code" title="function S = randskew(n, N)">randskew</a>(n, k);
0227         nrmU = sqrt(U(:).'*U(:));
0228         U = U / nrmU;
0229     <span class="keyword">end</span>
0230     
0231     M.lincomb = @<a href="../../../manopt/tools/matrixlincomb.html" class="code" title="function v = matrixlincomb(x, a1, d1, a2, d2) %#ok<INUSL>">matrixlincomb</a>;
0232     
0233     M.zerovec = @(x) zeros(n, n, k);
0234     
0235     M.transp = @(x1, x2, d) d;
0236     M.isotransp = M.transp; <span class="comment">% the transport is isometric</span>
0237     
0238     M.pairmean = @<a href="#_sub9" class="code" title="subfunction Y = pairmean(X1, X2)">pairmean</a>;
0239     <a name="_sub9" href="#_subfunctions" class="code">function Y = pairmean(X1, X2)</a>
0240         V = M.log(X1, X2);
0241         Y = M.exp(X1, .5*V);
0242     <span class="keyword">end</span>
0243     
0244     M.dist = @(x, y) M.norm(x, M.log(x, y));
0245     
0246     M.vec = @(x, u_mat) u_mat(:);
0247     M.mat = @(x, u_vec) reshape(u_vec, [n, n, k]);
0248     M.vecmatareisometries = @() true;
0249 
0250 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 10-Sep-2018 11:48:06 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>