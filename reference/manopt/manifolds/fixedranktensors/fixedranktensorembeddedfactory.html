<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fixedranktensorembeddedfactory</title>
  <meta name="keywords" content="fixedranktensorembeddedfactory">
  <meta name="description" content="Manifold of tensors with fixed multilinear rank in Tucker format">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">manifolds</a> &gt; <a href="index.html">fixedranktensors</a> &gt; fixedranktensorembeddedfactory.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\manifolds\fixedranktensors&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fixedranktensorembeddedfactory
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Manifold of tensors with fixed multilinear rank in Tucker format</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function M = fixedranktensorembeddedfactory(tensor_size, tensor_rank) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Manifold of tensors with fixed multilinear rank in Tucker format
 as a submanifold of a Euclidean space.

 function M = fixedranktensorembeddedfactory(tensor_size, tensor_rank)

 NOTE: Tensor Toolbox version 2.6 or higher is required for this factory:
 see https://www.tensortoolbox.org/ or https://gitlab.com/tensors/tensor_toolbox

 The set of tensors with fixed multilinear rank in Tucker format is endowed
 with a Riemannian manifold structure as an embedded submanifold of a
 Euclidean space. This function returns a structure M representing this
 manifold for use with Manopt.

 The inputs tensore_size and tensor_rank are vectors of length d, where
 d is the order (the number of modes) of the tensors considered.
 The entries of tensor_size are the tensor dimensions in each mode.
 The entries of tensor_rank are the multilinear ranks (Tucker ranks,
 matricization ranks) in each mode.

 A point on the manifold is represented as a structure with two fields:
 X: a ttensor object (see Tensor Toolbox), the actual point on the manifold.
 Cpinv: a cell list of the pseudoinverses of all matricizations of X.core.
 (This preprocessing makes subsequent operations more efficient.)

 A tangent vector is represented as a structure with two fields: 
 G: variation in the core tensor
 V: a cell list of variations in the core matrices

 Vectors in the ambient space (e.g., vector E for the function M.proj
 and vectors egrad and ehess for the functions M.egrad2rgrad and
 M.ehess2rhess) can be given as either full tensors (tensor objects
 in the Tensor Toolbox) or sparse tensors (sptensor objects in the
 Tensor Toolbox).

 For details, refer to the article
 &quot;A Riemannian trust-region method for low-rank tensor completion&quot;
 Gennadij Heidel and Volker Schulz, doi:10.1002/nla.2175.

 Please cite the Manopt and MATLAB Tensor Toolbox papers as well as the
 research paper:
     @Article{heidel2018riemannian,
       Title   = {A {R}iemannian trust-region method for low-rank tensor completion},
       Author  = {G. Heidel and V. Schulz},
       Journal = {Numerical Linear Algebra with Applications},
       Year    = {2018},
       Volume  = {23},
       Number  = {6},
       Pages   = {e1275},
       Doi     = {10.1002/nla.2175}
     }

 See also: <a href="fixedrankfactory_tucker_preconditioned.html" class="code" title="function M = fixedrankfactory_tucker_preconditioned(tensor_size, tensor_rank)">fixedrankfactory_tucker_preconditioned</a> fixedrankembeddedfactory</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>	Computes the MD5 hash of input data.</li><li><a href="../../../manopt/tools/lincomb.html" class="code" title="function vec = lincomb(M, x, vecs, coeffs)">lincomb</a>	Computes a linear combination of tangent vectors in the Manopt framework.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/low_rank_tensor_completion_embedded.html" class="code" title="function low_rank_tensor_completion_embedded()">low_rank_tensor_completion_embedded</a>	Given partial observation of a low rank tensor (possibly including noise),</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function ip = iproduct(X, eta, zeta)</a></li><li><a href="#_sub2" class="code">function Eproj = projection(X, E)</a></li><li><a href="#_sub3" class="code">function rgrad = egrad2rgrad(X, egrad)</a></li><li><a href="#_sub4" class="code">function Hess = ehess2rhess(X, egrad, ehess, eta)</a></li><li><a href="#_sub5" class="code">function xi = tangent(X, eta)</a></li><li><a href="#_sub6" class="code">function E = tan2amb(X, eta)</a></li><li><a href="#_sub7" class="code">function Y = retraction(X, xi, alpha)</a></li><li><a href="#_sub8" class="code">function h = hashing(X)</a></li><li><a href="#_sub9" class="code">function X = random()</a></li><li><a href="#_sub10" class="code">function eta = randomvec(X)</a></li><li><a href="#_sub11" class="code">function xi = lincomb(X, lambda1, eta1, lambda2, eta2)</a></li><li><a href="#_sub12" class="code">function eta = zerovector(X)</a></li><li><a href="#_sub13" class="code">function eta = transport(X, Y, xi)</a></li><li><a href="#_sub14" class="code">function eta = normrep(X, eta_vec)</a></li><li><a href="#_sub15" class="code">function T = hosvd(X, r)</a></li><li><a href="#_sub16" class="code">function eta = curvature_term(E, X, xi)</a></li><li><a href="#_sub17" class="code">function spf = mfname(n, r, d)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function M = fixedranktensorembeddedfactory(tensor_size, tensor_rank)</a>
0002 <span class="comment">% Manifold of tensors with fixed multilinear rank in Tucker format</span>
0003 <span class="comment">% as a submanifold of a Euclidean space.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% function M = fixedranktensorembeddedfactory(tensor_size, tensor_rank)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% NOTE: Tensor Toolbox version 2.6 or higher is required for this factory:</span>
0008 <span class="comment">% see https://www.tensortoolbox.org/ or https://gitlab.com/tensors/tensor_toolbox</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% The set of tensors with fixed multilinear rank in Tucker format is endowed</span>
0011 <span class="comment">% with a Riemannian manifold structure as an embedded submanifold of a</span>
0012 <span class="comment">% Euclidean space. This function returns a structure M representing this</span>
0013 <span class="comment">% manifold for use with Manopt.</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% The inputs tensore_size and tensor_rank are vectors of length d, where</span>
0016 <span class="comment">% d is the order (the number of modes) of the tensors considered.</span>
0017 <span class="comment">% The entries of tensor_size are the tensor dimensions in each mode.</span>
0018 <span class="comment">% The entries of tensor_rank are the multilinear ranks (Tucker ranks,</span>
0019 <span class="comment">% matricization ranks) in each mode.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% A point on the manifold is represented as a structure with two fields:</span>
0022 <span class="comment">% X: a ttensor object (see Tensor Toolbox), the actual point on the manifold.</span>
0023 <span class="comment">% Cpinv: a cell list of the pseudoinverses of all matricizations of X.core.</span>
0024 <span class="comment">% (This preprocessing makes subsequent operations more efficient.)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% A tangent vector is represented as a structure with two fields:</span>
0027 <span class="comment">% G: variation in the core tensor</span>
0028 <span class="comment">% V: a cell list of variations in the core matrices</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Vectors in the ambient space (e.g., vector E for the function M.proj</span>
0031 <span class="comment">% and vectors egrad and ehess for the functions M.egrad2rgrad and</span>
0032 <span class="comment">% M.ehess2rhess) can be given as either full tensors (tensor objects</span>
0033 <span class="comment">% in the Tensor Toolbox) or sparse tensors (sptensor objects in the</span>
0034 <span class="comment">% Tensor Toolbox).</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% For details, refer to the article</span>
0037 <span class="comment">% &quot;A Riemannian trust-region method for low-rank tensor completion&quot;</span>
0038 <span class="comment">% Gennadij Heidel and Volker Schulz, doi:10.1002/nla.2175.</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% Please cite the Manopt and MATLAB Tensor Toolbox papers as well as the</span>
0041 <span class="comment">% research paper:</span>
0042 <span class="comment">%     @Article{heidel2018riemannian,</span>
0043 <span class="comment">%       Title   = {A {R}iemannian trust-region method for low-rank tensor completion},</span>
0044 <span class="comment">%       Author  = {G. Heidel and V. Schulz},</span>
0045 <span class="comment">%       Journal = {Numerical Linear Algebra with Applications},</span>
0046 <span class="comment">%       Year    = {2018},</span>
0047 <span class="comment">%       Volume  = {23},</span>
0048 <span class="comment">%       Number  = {6},</span>
0049 <span class="comment">%       Pages   = {e1275},</span>
0050 <span class="comment">%       Doi     = {10.1002/nla.2175}</span>
0051 <span class="comment">%     }</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% See also: fixedrankfactory_tucker_preconditioned fixedrankembeddedfactory</span>
0054 
0055 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0056 <span class="comment">% Original author: Gennadij Heidel, January 24, 2019.</span>
0057 <span class="comment">% Contributors:</span>
0058 <span class="comment">% Change log:</span>
0059 
0060 <span class="comment">% References to papers in the code:</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% Kressner et al.:</span>
0063 <span class="comment">% &quot;Low-rank tensor completion by Riemannian optimization&quot;</span>
0064 <span class="comment">% D. Kressner, M. Steinlechner, B. Vandereycken</span>
0065 <span class="comment">% doi:10.1007/s10543-013-0455-z</span>
0066 <span class="comment">%</span>
0067 <span class="comment">% De Lathauwer et al.:</span>
0068 <span class="comment">% &quot;A multilinear singular value decomposition&quot;</span>
0069 <span class="comment">% L. De Lathauwer, B. De Moor, J. Vandewalle</span>
0070 <span class="comment">% doi:10.1137/S0895479896305696</span>
0071 
0072     assert(exist(<span class="string">'ttensor'</span>, <span class="string">'file'</span>) == 2, sprintf( <span class="keyword">...</span>
0073         [<span class="string">'It seems the Tensor Toolbox is not installed.\nIt is needed '</span>, <span class="keyword">...</span>
0074          <span class="string">'for the execution of fixedranktensorembeddedfactory.m.\n'</span>, <span class="keyword">...</span>
0075          <span class="string">'Please download the toolbox at https://www.tensortoolbox.org/'</span>, <span class="keyword">...</span>
0076          <span class="string">'\nor https://gitlab.com/tensors/tensor_toolbox.'</span>]));
0077 
0078     <span class="comment">% Tensor size and rank</span>
0079     d = length(tensor_size);
0080     <span class="keyword">if</span> d ~= length(tensor_rank)
0081         error([<span class="string">'Tensor dimensions and ranks do not match: '</span> <span class="keyword">...</span>
0082                <span class="string">'the two inputs should have the same length.'</span>]);
0083     <span class="keyword">end</span>
0084     n = tensor_size;
0085     r = tensor_rank;
0086     
0087     <span class="comment">% Generate a string that describes the used manifold</span>
0088     manifold_name = <a href="#_sub17" class="code" title="subfunction spf = mfname(n, r, d)">mfname</a>(n, r, d);
0089     M.name = @() manifold_name;
0090     
0091     <span class="comment">% Dimension of the manifold</span>
0092     mfdim = prod(r) + sum(r.*(n-r));
0093     M.dim = @() mfdim;
0094     
0095     <span class="comment">% Efficient inner product on tangent space exploiting orthogonality</span>
0096     M.inner = @<a href="#_sub1" class="code" title="subfunction ip = iproduct(X, eta, zeta)">iproduct</a>;
0097     <a name="_sub1" href="#_subfunctions" class="code">function ip = iproduct(X, eta, zeta)</a>
0098         ip = innerprod(eta.G, zeta.G);
0099         <span class="keyword">for</span> i = 1:d
0100             ip = ip + innerprod(X.X.core, <span class="keyword">...</span>
0101                                 ttm(X.X.core, eta.V{i}'*zeta.V{i}, i));
0102         <span class="keyword">end</span>
0103     <span class="keyword">end</span>
0104 
0105     M.norm = @(X, eta) sqrt(<a href="#_sub1" class="code" title="subfunction ip = iproduct(X, eta, zeta)">iproduct</a>(X, eta, eta));
0106     
0107     M.dist = @(x, y) error(<span class="string">'fixedranktensorembeddedfactory.dist not implemented yet.'</span>);
0108     
0109     <span class="comment">% This number is heuristic</span>
0110     M.typicaldist = @() 10*mean(n)*mean(r);
0111     
0112     <span class="comment">% Orthogonal projection of a vector E in the ambient space to the</span>
0113     <span class="comment">% tangent space at X.</span>
0114     M.proj = @<a href="#_sub2" class="code" title="subfunction Eproj = projection(X, E)">projection</a>;
0115     <a name="_sub2" href="#_subfunctions" class="code">function Eproj = projection(X, E)</a>
0116         <span class="keyword">if</span> ~isstruct(E)
0117             uList = X.X.U;
0118             
0119             <span class="comment">% cf. Kressner et al., p. 454, bottom</span>
0120             G = ttm(E, uList, <span class="string">'t'</span>);
0121 
0122             <span class="comment">% cf. Kressner et al., p. 454, bottom</span>
0123             V = cell(1, d);
0124             <span class="keyword">for</span> i = 1:d
0125                 <span class="comment">% modes vector without ith mode for ttm multiplication</span>
0126                 modes = 1:d;
0127                 modes(i) = [];
0128 
0129                 <span class="comment">% list of basis matrices U without the index i</span>
0130                 uListWoI = uList;
0131                 uListWoI(:, i) = [];
0132                 
0133                 <span class="comment">% the term of V_i before the multiplication by the orthogonal projector</span>
0134                 beforeProj = tenmat(ttm(E, uListWoI, modes, <span class="string">'t'</span>), i) * X.Cpinv{i};
0135 
0136                 <span class="comment">% orthogonal projection</span>
0137                 V{i} = double(beforeProj - X.X.U{i}*(X.X.U{i}'*beforeProj));
0138             <span class="keyword">end</span>
0139             
0140             Eproj.G = G;
0141             Eproj.V = V;
0142         <span class="keyword">else</span>
0143             error([<span class="string">'fixedranktensorembeddedfactory.proj only '</span> <span class="keyword">...</span>
0144                    <span class="string">'implemented for ambient tensors so far.'</span>]);
0145         <span class="keyword">end</span>
0146         
0147     <span class="keyword">end</span>
0148     
0149     <span class="comment">% The Riemannian gradient is the projection of the Euclidean gradient</span>
0150     M.egrad2rgrad = @<a href="#_sub3" class="code" title="subfunction rgrad = egrad2rgrad(X, egrad)">egrad2rgrad</a>;
0151     <a name="_sub3" href="#_subfunctions" class="code">function rgrad = egrad2rgrad(X, egrad)</a>
0152         rgrad = <a href="#_sub2" class="code" title="subfunction Eproj = projection(X, E)">projection</a>(X, egrad);
0153     <span class="keyword">end</span>
0154     
0155     <span class="comment">% The Riemannian Hessian is the projection of the Euclidean Hessian</span>
0156     <span class="comment">% plus a curvature term: see code below in this file.</span>
0157     M.ehess2rhess = @<a href="#_sub4" class="code" title="subfunction Hess = ehess2rhess(X, egrad, ehess, eta)">ehess2rhess</a>;
0158     <a name="_sub4" href="#_subfunctions" class="code">function Hess = ehess2rhess(X, egrad, ehess, eta) </a>
0159         Hess = <a href="../../../manopt/tools/lincomb.html" class="code" title="function vec = lincomb(M, x, vecs, coeffs)">lincomb</a>(X, 1, <a href="#_sub2" class="code" title="subfunction Eproj = projection(X, E)">projection</a>(X, ehess), <span class="keyword">...</span>
0160                           1, <a href="#_sub16" class="code" title="subfunction eta = curvature_term(E, X, xi)">curvature_term</a>(egrad, X, eta));
0161     <span class="keyword">end</span>
0162 
0163     <span class="comment">% Re-orthogonalize basis matrix variations in the tangent vector.</span>
0164     <span class="comment">% When applied to a tangent vector, this should do nothing up to</span>
0165     <span class="comment">% numerical errors.</span>
0166     M.tangent = @<a href="#_sub5" class="code" title="subfunction xi = tangent(X, eta)">tangent</a>;
0167     <a name="_sub5" href="#_subfunctions" class="code">function xi = tangent(X, eta)</a>
0168         xi = eta;
0169         <span class="keyword">for</span> i = 1:d
0170             xi.V{i} = eta.V{i} - X.X.U{i}*(X.X.U{i}'*eta.V{i});
0171         <span class="keyword">end</span>
0172     <span class="keyword">end</span>
0173 
0174     <span class="comment">% Generate full n1-by-...-by-nd tensor in the ambient space from</span>
0175     <span class="comment">% a tangent vector.</span>
0176     M.tangent2ambient = @<a href="#_sub6" class="code" title="subfunction E = tan2amb(X, eta)">tan2amb</a>;
0177     <a name="_sub6" href="#_subfunctions" class="code">function E = tan2amb(X, eta)</a>
0178         E = ttm(eta.G, X.X.U);
0179         
0180         <span class="keyword">for</span> i = 1:d
0181             <span class="comment">% modes vector without ith mode for ttm multiplication</span>
0182             modes = 1:d;
0183             modes(i) = [];
0184 
0185             <span class="comment">% list of basis matrices U without the index i</span>
0186             uListWoI = X.X.U;
0187             uListWoI(:, i) = [];
0188 
0189             E = E + ttm(ttm(X.X.core, eta.V{i}, i), uListWoI, modes);
0190         <span class="keyword">end</span>
0191         
0192     <span class="keyword">end</span>
0193     
0194     <span class="comment">% Efficient retraction, see Kressner at al., 2014</span>
0195     M.retr = @<a href="#_sub7" class="code" title="subfunction Y = retraction(X, xi, alpha)">retraction</a>;
0196     <a name="_sub7" href="#_subfunctions" class="code">function Y = retraction(X, xi, alpha)</a>
0197         <span class="comment">% if no alpha is given, assume it to be 1</span>
0198         <span class="keyword">if</span> nargin &lt; 3
0199             alpha = 1.0;
0200         <span class="keyword">end</span>
0201 
0202         Q = cell(1, d);
0203         R = cell(1, d);
0204         <span class="keyword">for</span> i = 1:d
0205             [Q{i}, R{i}] = qr([X.X.U{i}, xi.V{i}], 0);
0206         <span class="keyword">end</span>
0207 
0208         S = zeros(2*r);
0209 
0210         <span class="comment">% First block C+alpha*G, see Kressner et al., Fig. 2</span>
0211         sBlock = double(X.X.core + alpha*xi.G);
0212         <span class="keyword">for</span> i = 1:d
0213             sBlock = cat(i, sBlock, zeros(size(sBlock)));
0214         <span class="keyword">end</span>
0215         S = S + sBlock;
0216 
0217         <span class="comment">% Adjacent Blocks alpha*C, see Kressner et al., Fig. 2</span>
0218         <span class="keyword">for</span> i = 1:d
0219             sBlock = double(alpha*X.X.core);
0220             modes = 1:d;
0221             modes(i) = [];
0222             <span class="keyword">for</span> j=modes
0223                 sBlock = cat(j, sBlock, zeros(size(sBlock)));
0224             <span class="keyword">end</span>
0225             sBlock = cat(i, zeros(size(sBlock)), sBlock);
0226             S = S + sBlock;
0227         <span class="keyword">end</span>
0228 
0229         <span class="comment">% no concatenation in tensor toolbox --&gt; detour over Matlab arrays</span>
0230         S = tensor(S);
0231 
0232         <span class="comment">% absorb R factors in core tensor</span>
0233         S = ttm(S, R);
0234 
0235         <span class="comment">% actual retraction</span>
0236         sHosvd = <a href="#_sub15" class="code" title="subfunction T = hosvd(X, r)">hosvd</a>(S, r);
0237 
0238         <span class="comment">% absorb Q factors in basis matrices</span>
0239         U = cell(1, d);
0240         <span class="keyword">for</span> i = 1:d
0241             U{i} = Q{i} * sHosvd.U{i};
0242         <span class="keyword">end</span>
0243 
0244         Z = ttensor(sHosvd.core, U);
0245         Y.X = Z;
0246         Y.Cpinv = cell(1, d);
0247         <span class="keyword">for</span> i = 1:d
0248             <span class="comment">% Should consider replacing use of pinv with another</span>
0249             <span class="comment">% preprocessed form.</span>
0250            Y.Cpinv{i} = pinv(double(tenmat(Y.X.core, i)));
0251         <span class="keyword">end</span>
0252     <span class="keyword">end</span>
0253     
0254     M.hash = @<a href="#_sub8" class="code" title="subfunction h = hashing(X)">hashing</a>;
0255     <a name="_sub8" href="#_subfunctions" class="code">function h = hashing(X)</a>
0256         v = zeros(2*d+1, 1);
0257         <span class="keyword">for</span> i = 1:d
0258             v(i) = sum(X.X.U{i}(:));
0259         <span class="keyword">end</span>
0260         v(d+1) = sum(X.X.core(:));
0261         <span class="keyword">for</span> i = 1:d
0262             v(d+1+i) = sum(X.Cpinv{i}(:));
0263         <span class="keyword">end</span>
0264         h = [<span class="string">'z'</span> <a href="../../../manopt/tools/hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>(v)];
0265     <span class="keyword">end</span>
0266     
0267     <span class="comment">% Random tensor on manifold</span>
0268     M.rand = @<a href="#_sub9" class="code" title="subfunction X = random()">random</a>;
0269     <a name="_sub9" href="#_subfunctions" class="code">function X = random()</a>
0270         U = cell(1, d);
0271         R = cell(1, d);
0272         <span class="keyword">for</span> i = 1:d
0273             [U{i}, R{i}] = qr(rand(n(i), r(i)), 0);
0274         <span class="keyword">end</span>
0275         C = tenrand(r);
0276         C = ttm(C,R);
0277         
0278         <span class="comment">% Perform an HSOVD of the core to ensure all-orthogonality</span>
0279         Z = <a href="#_sub15" class="code" title="subfunction T = hosvd(X, r)">hosvd</a>(C, r);
0280         <span class="keyword">for</span> i = 1:d
0281             U{i} = U{i}*Z.U{i};
0282         <span class="keyword">end</span>
0283         
0284         Y = ttensor(Z.core, U);
0285         X.X = Y;
0286         Cpinv = cell(1, d);
0287         <span class="keyword">for</span> i = 1:d
0288             Cpinv{i} = pinv(double(tenmat(X.X.core, i)));
0289         <span class="keyword">end</span>
0290         X.Cpinv = Cpinv;
0291     <span class="keyword">end</span>
0292     
0293     <span class="comment">% Random unit norm tangent vector</span>
0294     M.randvec = @<a href="#_sub10" class="code" title="subfunction eta = randomvec(X)">randomvec</a>;
0295     <a name="_sub10" href="#_subfunctions" class="code">function eta = randomvec(X)</a>
0296         G = tensor(randn(r));
0297         xi.G = G;
0298         
0299         V = cell(1, d);
0300         <span class="keyword">for</span> i = 1:d
0301             V{i} = randn(n(i), r(i));
0302         <span class="keyword">end</span>
0303         xi.V = V;
0304         
0305         xi = M.tangent(X, xi);
0306         nrm = M.norm(X, xi);
0307         
0308         eta.G = xi.G / nrm;
0309         <span class="keyword">for</span> i = 1:d
0310             xi.V{i} = xi.V{i} / nrm;
0311         <span class="keyword">end</span>
0312         eta.V = xi.V;
0313     <span class="keyword">end</span>
0314     
0315     <span class="comment">% Evaluate lambda1*eta1* + lambda2*eta2 in the tangent space</span>
0316     M.lincomb = @<a href="../../../manopt/tools/lincomb.html" class="code" title="function vec = lincomb(M, x, vecs, coeffs)">lincomb</a>;
0317     <a name="_sub11" href="#_subfunctions" class="code">function xi = lincomb(X, lambda1, eta1, lambda2, eta2) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
0318         <span class="keyword">if</span> nargin == 3
0319             V = cell(1, d);
0320             <span class="keyword">for</span> i = 1:d
0321                 V{i} = lambda1*eta1.V{i};
0322             <span class="keyword">end</span>
0323             xi.G = lambda1*eta1.G;
0324             xi.V = V;
0325         <span class="keyword">elseif</span> nargin == 5
0326             V = cell(1, d);
0327             <span class="keyword">for</span> i = 1:d
0328                 V{i} = lambda1*eta1.V{i} + lambda2*eta2.V{i};
0329             <span class="keyword">end</span>
0330             xi.G = lambda1*eta1.G + lambda2*eta2.G;
0331             xi.V = V;
0332         <span class="keyword">else</span>
0333             error(<span class="string">'fixedranktensorembeddedfactory.lincomb takes 3 or 5 inputs.'</span>);
0334         <span class="keyword">end</span>
0335     <span class="keyword">end</span>
0336     
0337     M.zerovec = @<a href="#_sub12" class="code" title="subfunction eta = zerovector(X) ">zerovector</a>;
0338     <a name="_sub12" href="#_subfunctions" class="code">function eta = zerovector(X) </a><span class="comment">%#ok&lt;INUSD&gt;</span>
0339         G = tenzeros(r);
0340         V = cell(1, d);
0341         <span class="keyword">for</span> i = 1:d
0342             V{i} = zeros(n(i), r(i));
0343         <span class="keyword">end</span>
0344         eta.G = G;
0345         eta.V = V;
0346     <span class="keyword">end</span>
0347 
0348     <span class="comment">% Efficient vector transport by orthogonal projection,</span>
0349     <span class="comment">% see Kressner at al.</span>
0350     M.transp = @<a href="#_sub13" class="code" title="subfunction eta = transport(X, Y, xi)">transport</a>;
0351     <a name="_sub13" href="#_subfunctions" class="code">function eta = transport(X, Y, xi)</a>
0352 
0353         <span class="comment">% Follow notation from Kressner et al.</span>
0354         C = X.X.core;
0355         U = X.X.U;
0356         uList = U;
0357         U_tilde = Y.X.U;
0358         uTildeList = U_tilde;
0359         G = xi.G;
0360         V = xi.V;
0361 
0362         G_tilde = ttm(ttm(G, U), U_tilde, <span class="string">'t'</span>);
0363 
0364         <span class="keyword">for</span> i = 1:d
0365 
0366             <span class="comment">% List of basis matrices U without the index i</span>
0367             uListWoI = U;
0368             uListWoI{i} = V{i};
0369 
0370             G_tilde = G_tilde + ttm(ttm(C, uListWoI), U_tilde, <span class="string">'t'</span>);
0371         <span class="keyword">end</span>
0372 
0373         V_tilde = cell(1, d);
0374         <span class="keyword">for</span> i = 1:d
0375 
0376             <span class="comment">% Modes vector without ith mode for ttm multiplication</span>
0377             modesWoI = 1:d;
0378             modesWoI(i) = [];
0379 
0380             <span class="comment">% List of basis matrices U without the index i</span>
0381             uTildeListWoI = uTildeList;
0382             uTildeListWoI(:, i) = [];
0383 
0384             beforeProj = ttm(ttm(G, U), uTildeListWoI, modesWoI, <span class="string">'t'</span>);
0385 
0386             <span class="keyword">for</span> k = 1:d
0387                 uListWoK = uList;
0388                 uListWoK{k} = V{k};
0389 
0390                 beforeProj = beforeProj + <span class="keyword">...</span>
0391                        ttm(ttm(C, uListWoK), uTildeListWoI, modesWoI, <span class="string">'t'</span>);
0392             <span class="keyword">end</span>
0393 
0394             beforeProj = tenmat(beforeProj, i) * Y.Cpinv{i};
0395 
0396             V_tilde{i} = double(beforeProj - U_tilde{i}*(U_tilde{i}'*beforeProj));
0397         <span class="keyword">end</span>
0398 
0399         eta.G = G_tilde;
0400         eta.V = V_tilde;
0401     <span class="keyword">end</span>
0402     
0403     M.vec = @(X, eta) [eta.V{1}(:); eta.V{2}(:); eta.V{3}(:);eta.G(:)];
0404 
0405     M.mat = @<a href="#_sub14" class="code" title="subfunction eta = normrep(X, eta_vec) ">normrep</a>;
0406     <a name="_sub14" href="#_subfunctions" class="code">function eta = normrep(X, eta_vec) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
0407         
0408         V = cell(1, d);
0409         first_ind = 1;
0410         <span class="keyword">for</span> i = 1:d
0411             V{i} = reshape(eta_vec(first_ind : first_ind + n(i)*r(i)-1), n(i), r(i));
0412             first_ind = first_ind + n(i)*r(i);
0413         <span class="keyword">end</span>
0414         G = tensor(reshape(eta_vec(first_ind : end), r));
0415         
0416         eta.G = G;
0417         eta.V = V;
0418     <span class="keyword">end</span>
0419 
0420     <span class="comment">% vec and mat are not isometries</span>
0421     M.vecmatareisometries = @() false;
0422     
0423 <span class="keyword">end</span>
0424 
0425 <span class="comment">% Higher-order SVD, see De Lathauwer et al., 2000</span>
0426 <a name="_sub15" href="#_subfunctions" class="code">function T = hosvd(X, r)</a>
0427     <span class="keyword">if</span> ndims(X) == length(r)
0428         d = ndims(X);
0429     <span class="keyword">else</span>
0430         error(<span class="string">'Dimensions of tensor and multilinear rank vector do not match.'</span>)
0431     <span class="keyword">end</span>
0432 
0433     <span class="comment">% Store matrices U of r left singular vectors of X and store them</span>
0434     <span class="comment">% in a cell array</span>
0435     uList = cell(1, d);
0436     <span class="keyword">for</span> i = 1:d
0437         <span class="comment">% Cast to double because svds of tenmat is undefined</span>
0438         A = double(tenmat(X, i));
0439         [U, ~, ~] = svds(A, r(i));
0440         uList{i} = U;
0441     <span class="keyword">end</span>
0442 
0443     C = ttm(X, uList, <span class="string">'t'</span>);
0444 
0445     T = ttensor(C, uList);
0446 <span class="keyword">end</span>
0447 
0448 <span class="comment">% Curvature term for Riemannian Hessian,</span>
0449 <span class="comment">% see Heidel/Schulz, 2018, Corollary 3.7</span>
0450 <a name="_sub16" href="#_subfunctions" class="code">function eta = curvature_term(E, X, xi)</a>
0451     G = tenzeros(size(X.X.core));
0452     d = length(size(X.X.core));
0453     V = cell(1, d);
0454 
0455     <span class="keyword">for</span> i = 1:d
0456         modesWoI = 1:d;
0457         modesWoI(i) = [];
0458 
0459         uListWoI = X.X.U;
0460         uListWoI(:,i) = [];
0461         
0462         EUit = ttm(E, uListWoI, modesWoI, <span class="string">'t'</span>);
0463         Gi = double(tenmat(xi.G, i));
0464         Ci = double(tenmat(X.X.core, i));
0465         
0466         G = G + ttm(EUit,xi.V{i}, i, <span class="string">'t'</span>)<span class="keyword">...</span>
0467               - ttm(X.X.core, <span class="keyword">...</span>
0468                     double(xi.V{i}'*(tenmat(EUit,i)*X.Cpinv{i})), i); 
0469         
0470         Cplusi2 = X.Cpinv{i}'*X.Cpinv{i};
0471         Vi = (tenmat(EUit, i)*Gi')*Cplusi2 + <span class="keyword">...</span>
0472              (tenmat(EUit, i)*X.Cpinv{i})*(Ci*Gi')*Cplusi2;
0473         <span class="keyword">for</span> k = 1:length(modesWoI)
0474             modesWoIWoK = modesWoI;
0475             modesWoIWoK(k) = [];
0476             
0477             uListWoIWoK = uListWoI;
0478             uListWoIWoK(:, k) = [];
0479 
0480             EUiEUkdott = ttm(ttm(E, uListWoIWoK, modesWoIWoK, <span class="string">'t'</span>), <span class="keyword">...</span>
0481                              xi.V{modesWoI(k)}, modesWoI(k), <span class="string">'t'</span>);
0482             Vi = Vi + tenmat(EUiEUkdott, i)*X.Cpinv{i};
0483         <span class="keyword">end</span>
0484         V{i} = double(Vi - X.X.U{i}*(X.X.U{i}'*Vi));
0485     <span class="keyword">end</span>
0486 
0487     eta.G = G;
0488     eta.V = V;
0489 <span class="keyword">end</span>
0490 
0491 <a name="_sub17" href="#_subfunctions" class="code">function spf = mfname(n, r, d)</a>
0492     s = <span class="string">'C'</span>;
0493     <span class="keyword">for</span> i = 1:d
0494         s = strcat(s, <span class="string">' x U'</span>,int2str(i));
0495     <span class="keyword">end</span>
0496     s = strcat(s, <span class="string">' Tucker manifold of '</span>);
0497     <span class="keyword">for</span> i = 1:10
0498        <span class="keyword">if</span> n(i) &lt; 10^i
0499            digits = i;
0500            <span class="keyword">break</span>;
0501        <span class="keyword">end</span>
0502     <span class="keyword">end</span>
0503     s = strcat(s, <span class="string">'%'</span>, int2str(digits+1), <span class="string">'d-by-'</span>);
0504     <span class="keyword">for</span> i = 2:d-1
0505         s = strcat(s, <span class="string">'%d-by-'</span>);
0506     <span class="keyword">end</span>
0507     s = strcat(s, <span class="string">'%d tensors of rank '</span>);
0508     <span class="keyword">for</span> i = 1:10
0509        <span class="keyword">if</span> r(i)&lt;10^i
0510            digits = i;
0511            <span class="keyword">break</span>;
0512        <span class="keyword">end</span>
0513     <span class="keyword">end</span>
0514     s = strcat(s, <span class="string">'%'</span>, int2str(digits+1), <span class="string">'d-by-'</span>);
0515     <span class="keyword">for</span> i = 2:d-1
0516         s = strcat(s, <span class="string">'%d-by-'</span>);
0517     <span class="keyword">end</span>
0518     s = strcat(s, <span class="string">'%d'</span>);
0519     spf = sprintf(s, n, r);
0520 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-May-2020 18:46:12 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>