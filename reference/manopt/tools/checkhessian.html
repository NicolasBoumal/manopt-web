<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of checkhessian</title>
  <meta name="keywords" content="checkhessian">
  <meta name="description" content="Checks the consistency of the cost function and the Hessian.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="index.html">tools</a> &gt; checkhessian.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\tools&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>checkhessian
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Checks the consistency of the cost function and the Hessian.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function checkhessian(problem, x, d) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Checks the consistency of the cost function and the Hessian.

 function checkhessian(problem)
 function checkhessian(problem, x)
 function checkhessian(problem, x, d)

 checkhessian performs a numerical test to check that the directional
 derivatives and Hessian defined in the problem structure agree up to
 second order with the cost function at some point x, along some direction
 d. The test is based on a truncated Taylor series (see online Manopt
 documentation).
 
 It is also tested that the result of applying the Hessian along that
 direction is indeed a tangent vector, and that the Hessian operator is
 symmetric w.r.t. the Riemannian metric.
 
 Both x and d are optional and will be sampled at random if omitted.

 The slope test requires the exponential map of the manifold, or at least
 a second-order retraction. If M.exp() is not available, the retraction is
 used and a message is issued to instruct the user to check whether M.retr
 is second-order or not. If it is not, the slope test is only valid at
 critical points of the cost function (which can be computed by
 optimization.)

 See also: <a href="checkdiff.html" class="code" title="function checkdiff(problem, x, d, force_gradient)">checkdiff</a> <a href="checkgradient.html" class="code" title="function checkgradient(problem, x, d)">checkgradient</a> <a href="checkretraction.html" class="code" title="function checkretraction(M, x, v)">checkretraction</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="../../manopt/core/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>	Checks whether the cost function can be computed for a problem structure.</li><li><a href="../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>	Checks whether the gradient can be computed for a problem structure.</li><li><a href="../../manopt/core/canGetHessian.html" class="code" title="function candoit = canGetHessian(problem)">canGetHessian</a>	Checks whether the Hessian can be computed for a problem structure.</li><li><a href="../../manopt/core/getCost.html" class="code" title="function cost = getCost(problem, x, storedb, key)">getCost</a>	Computes the cost function at x.</li><li><a href="../../manopt/core/getGradient.html" class="code" title="function grad = getGradient(problem, x, storedb, key)">getGradient</a>	Computes the gradient of the cost function at x.</li><li><a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>	Computes the Hessian of the cost function at x along d.</li><li><a href="identify_linear_piece.html" class="code" title="function [range, poly] = identify_linear_piece(x, y, window_length)">identify_linear_piece</a>	Identify a segment of the curve (x, y) that appears to be linear.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../examples/doubly_stochastic_denoising.html" class="code" title="function doubly_stochastic_denoising()">doubly_stochastic_denoising</a>	Find a doubly stochastic matrix closest to a given matrix, in Frobenius norm.</li><li><a href="../../manopt/autodiff/basic_examples_AD/basic_example_AD.html" class="code" title="function basic_example_AD()">basic_example_AD</a>	A basic example that shows how to apply automatic differentiation to</li><li><a href="../../manopt/autodiff/basic_examples_AD/complex_example_AD.html" class="code" title="function complex_example_AD()">complex_example_AD</a>	A basic example that shows how to define the cost funtion for</li><li><a href="../../manopt/autodiff/basic_examples_AD/complextest_AD1.html" class="code" title="function complextest_AD1()">complextest_AD1</a>	Test AD for a complex optimization problem on a product manifold (struct)</li><li><a href="../../manopt/autodiff/basic_examples_AD/complextest_AD2.html" class="code" title="function complextest_AD2()">complextest_AD2</a>	Test AD for a complex optimization problem on a power manifold (cell)</li><li><a href="../../manopt/autodiff/basic_examples_AD/complextest_AD3.html" class="code" title="function complextest_AD3()">complextest_AD3</a>	Test AD for a complex optimization problem on a manifold which is stored</li><li><a href="../../manopt/autodiff/basic_examples_AD/realtest_AD1.html" class="code" title="function realtest_AD1()">realtest_AD1</a>	Test AD for a real optimization problem on a product manifold (struct)</li><li><a href="../../manopt/autodiff/basic_examples_AD/realtest_AD2.html" class="code" title="function realtest_AD2()">realtest_AD2</a>	Test AD for a real optimization problem on a power manifold (cell)</li><li><a href="../../manopt/autodiff/basic_examples_AD/realtest_AD3.html" class="code" title="function realtest_AD3()">realtest_AD3</a>	Test AD for a real optimization problem on a manifold which is stored in</li><li><a href="../../manopt/manifolds/ttfixedrank/TTeMPS_1.1/examples/linearsystem_compare.html" class="code" title="">linearsystem_compare</a>	Example code for the algorithms described in</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function checkhessian(problem, x, d)</a>
0002 <span class="comment">% Checks the consistency of the cost function and the Hessian.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function checkhessian(problem)</span>
0005 <span class="comment">% function checkhessian(problem, x)</span>
0006 <span class="comment">% function checkhessian(problem, x, d)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% checkhessian performs a numerical test to check that the directional</span>
0009 <span class="comment">% derivatives and Hessian defined in the problem structure agree up to</span>
0010 <span class="comment">% second order with the cost function at some point x, along some direction</span>
0011 <span class="comment">% d. The test is based on a truncated Taylor series (see online Manopt</span>
0012 <span class="comment">% documentation).</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% It is also tested that the result of applying the Hessian along that</span>
0015 <span class="comment">% direction is indeed a tangent vector, and that the Hessian operator is</span>
0016 <span class="comment">% symmetric w.r.t. the Riemannian metric.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% Both x and d are optional and will be sampled at random if omitted.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% The slope test requires the exponential map of the manifold, or at least</span>
0021 <span class="comment">% a second-order retraction. If M.exp() is not available, the retraction is</span>
0022 <span class="comment">% used and a message is issued to instruct the user to check whether M.retr</span>
0023 <span class="comment">% is second-order or not. If it is not, the slope test is only valid at</span>
0024 <span class="comment">% critical points of the cost function (which can be computed by</span>
0025 <span class="comment">% optimization.)</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% See also: checkdiff checkgradient checkretraction</span>
0028 
0029 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0030 <span class="comment">% Original author: Nicolas Boumal, Dec. 30, 2012.</span>
0031 <span class="comment">% Contributors:</span>
0032 <span class="comment">% Change log:</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%   April 3, 2015 (NB):</span>
0035 <span class="comment">%       Works with the new StoreDB class system.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%   Nov. 1, 2016 (NB):</span>
0038 <span class="comment">%       Issues a call to getGradient rather than getDirectionalDerivative.</span>
0039 <span class="comment">%</span>
0040 <span class="comment">%   March 26, 2017 (JB):</span>
0041 <span class="comment">%       Detects if the approximated quadratic model is exact</span>
0042 <span class="comment">%       and provides the user with the corresponding feedback.</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%   Dec. 6, 2017 (NB):</span>
0045 <span class="comment">%       Added message in case tangent2ambient might be necessary in</span>
0046 <span class="comment">%       defining ehess (this was a common difficulty for users.)</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%   Aug. 2, 2018 (NB):</span>
0049 <span class="comment">%       Using storedb.remove() to avoid unnecessary cache build-up.</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   Sep. 6, 2018 (NB):</span>
0052 <span class="comment">%       Now checks whether M.exp() is available; uses retraction otherwise</span>
0053 <span class="comment">%       and issues a message that the user should check whether the</span>
0054 <span class="comment">%       retraction is second-order or not.</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%   Feb. 1, 2020 (NB):</span>
0057 <span class="comment">%       Added an explicit linearity check.</span>
0058 
0059         
0060     <span class="comment">% Verify that the problem description is sufficient.</span>
0061     <span class="keyword">if</span> ~<a href="../../manopt/core/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>(problem)
0062         error(<span class="string">'It seems no cost was provided.'</span>);
0063     <span class="keyword">end</span>
0064     <span class="keyword">if</span> ~<a href="../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>(problem)
0065         warning(<span class="string">'manopt:checkhessian:nograd'</span>, <span class="keyword">...</span>
0066                 <span class="string">'It seems no gradient was provided.'</span>);
0067     <span class="keyword">end</span>
0068     <span class="keyword">if</span> ~<a href="../../manopt/core/canGetHessian.html" class="code" title="function candoit = canGetHessian(problem)">canGetHessian</a>(problem)
0069         warning(<span class="string">'manopt:checkhessian:nohess'</span>, <span class="keyword">...</span>
0070                 <span class="string">'It seems no Hessian was provided.'</span>);
0071     <span class="keyword">end</span>
0072     
0073     x_isprovided = exist(<span class="string">'x'</span>, <span class="string">'var'</span>) &amp;&amp; ~isempty(x);
0074     d_isprovided = exist(<span class="string">'d'</span>, <span class="string">'var'</span>) &amp;&amp; ~isempty(d);
0075     
0076     <span class="keyword">if</span> ~x_isprovided &amp;&amp; d_isprovided
0077         error(<span class="string">'If d is provided, x must be too, since d is tangent at x.'</span>);
0078     <span class="keyword">end</span>
0079     
0080     <span class="comment">% If x and / or d are not specified, pick them at random.</span>
0081     <span class="keyword">if</span> ~x_isprovided
0082         x = problem.M.rand();
0083     <span class="keyword">end</span>
0084     <span class="keyword">if</span> ~d_isprovided
0085         d = problem.M.randvec(x);
0086     <span class="keyword">end</span>
0087     
0088     <span class="comment">%% Check that the directional derivative and the Hessian at x along d</span>
0089     <span class="comment">%% yield a second order model of the cost function.</span>
0090     
0091     <span class="comment">% Compute the value f0 at f, directional derivative df0 at x along d,</span>
0092     <span class="comment">% and Hessian along [d, d].</span>
0093     storedb = <a href="../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>();
0094     xkey = storedb.getNewKey();
0095     f0 = <a href="../../manopt/core/getCost.html" class="code" title="function cost = getCost(problem, x, storedb, key)">getCost</a>(problem, x, storedb, xkey);
0096     gradx = <a href="../../manopt/core/getGradient.html" class="code" title="function grad = getGradient(problem, x, storedb, key)">getGradient</a>(problem, x, storedb, xkey);
0097     df0 = problem.M.inner(x, d, gradx);
0098     hessxd = <a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>(problem, x, d, storedb, xkey);
0099     d2f0 = problem.M.inner(x, d, hessxd);
0100     
0101     
0102     <span class="comment">% Pick a stepping function: exponential or retraction?</span>
0103     <span class="keyword">if</span> isfield(problem.M, <span class="string">'exp'</span>)
0104         stepper = problem.M.exp;
0105         extra_message = <span class="string">''</span>;
0106     <span class="keyword">else</span>
0107         stepper = problem.M.retr;
0108         fprintf([<span class="string">'* M.exp() is not available: using M.retr() instead.\n'</span> <span class="keyword">...</span>
0109                  <span class="string">'* Please check the manifold documentation to see if\n'</span> <span class="keyword">...</span>
0110                  <span class="string">'* the retraction is second order. If not, the slope\n'</span> <span class="keyword">...</span>
0111                  <span class="string">'* test is allowed to fail at non-critical x.\n'</span>]);
0112         extra_message = [<span class="string">'(But do mind the message above: the slope may\n'</span> <span class="keyword">...</span>
0113                          <span class="string">'be allowed to be 2 at non-critical points x.)\n'</span>];
0114     <span class="keyword">end</span>
0115     
0116     
0117     <span class="comment">% Compute the value of f at points on the geodesic (or approximation</span>
0118     <span class="comment">% of it) originating from x, along direction d, for stepsizes in a</span>
0119     <span class="comment">% large range given by h.</span>
0120     h = logspace(-8, 0, 51);
0121     value = zeros(size(h));
0122     <span class="keyword">for</span> i = 1 : length(h)
0123         y = stepper(x, d, h(i));
0124         ykey = storedb.getNewKey();
0125         value(i) = <a href="../../manopt/core/getCost.html" class="code" title="function cost = getCost(problem, x, storedb, key)">getCost</a>(problem, y, storedb, ykey);
0126         storedb.remove(ykey); <span class="comment">% no need to keep it in memory</span>
0127     <span class="keyword">end</span>
0128     
0129     <span class="comment">% Compute the quadratic approximation of the cost function using f0,</span>
0130     <span class="comment">% df0 and d2f0 at the same points.</span>
0131     model = polyval([.5*d2f0 df0 f0], h);
0132     
0133     <span class="comment">% Compute the approximation error</span>
0134     err = abs(model - value);
0135     
0136     <span class="comment">% And plot it.</span>
0137     loglog(h, err);
0138     title(sprintf([<span class="string">'Hessian check.\nThe slope of the continuous line '</span> <span class="keyword">...</span>
0139                    <span class="string">'should match that of the dashed\n(reference) line '</span> <span class="keyword">...</span>
0140                    <span class="string">'over at least a few orders of magnitude for h.'</span>]));
0141     xlabel(<span class="string">'h'</span>);
0142     ylabel(<span class="string">'Approximation error'</span>);
0143     
0144     line(<span class="string">'xdata'</span>, [1e-8 1e0], <span class="string">'ydata'</span>, [1e-16 1e8], <span class="keyword">...</span>
0145          <span class="string">'color'</span>, <span class="string">'k'</span>, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>, <span class="keyword">...</span>
0146          <span class="string">'YLimInclude'</span>, <span class="string">'off'</span>, <span class="string">'XLimInclude'</span>, <span class="string">'off'</span>);
0147     
0148     
0149     <span class="keyword">if</span> ~all( err &lt; 1e-12 )
0150         <span class="comment">% In a numerically reasonable neighborhood, the error should</span>
0151         <span class="comment">% decrease as the cube of the stepsize, i.e., in loglog scale, the</span>
0152         <span class="comment">% error should have a slope of 3.</span>
0153         isModelExact = false;
0154         window_len = 10;
0155         [range, poly] = <a href="identify_linear_piece.html" class="code" title="function [range, poly] = identify_linear_piece(x, y, window_length)">identify_linear_piece</a>(log10(h), log10(err), window_len);
0156     <span class="keyword">else</span>
0157         <span class="comment">% The 2nd order model is exact: all errors are (numerically) zero</span>
0158         <span class="comment">% Fit line from all points, use log scale only in h.</span>
0159         isModelExact = true;
0160         range = 1:numel(h);
0161         poly = polyfit(log10(h), err, 1);
0162         <span class="comment">% Set mean error in log scale for plot</span>
0163         poly(end) = log10(poly(end));
0164         <span class="comment">% Change title to something more descriptive for this special case.</span>
0165         title(sprintf(<span class="keyword">...</span>
0166               [<span class="string">'Hessian check.\n'</span><span class="keyword">...</span>
0167                <span class="string">'It seems the quadratic model is exact:\n'</span><span class="keyword">...</span>
0168                <span class="string">'Model error is numerically zero for all h.'</span>]));
0169     <span class="keyword">end</span>
0170     hold all;
0171     loglog(h(range), 10.^polyval(poly, log10(h(range))), <span class="string">'LineWidth'</span>, 3);
0172     hold off;
0173     
0174     <span class="keyword">if</span> ~isModelExact
0175         fprintf(<span class="string">'The slope should be 3. It appears to be: %g.\n'</span>, poly(1));
0176         fprintf([<span class="string">'If it is far from 3, then directional derivatives,\n'</span> <span class="keyword">...</span>
0177                  <span class="string">'the gradient or the Hessian might be erroneous.\n'</span>, <span class="keyword">...</span>
0178                  extra_message]);
0179     <span class="keyword">else</span>
0180         fprintf([<span class="string">'The quadratic model appears to be exact '</span> <span class="keyword">...</span>
0181                  <span class="string">'(within numerical precision),\n'</span><span class="keyword">...</span>
0182                  <span class="string">'hence the slope computation is irrelevant.\n'</span>]);
0183     <span class="keyword">end</span>
0184 
0185     
0186     <span class="comment">%% Check that the Hessian at x along direction d is a tangent vector.</span>
0187     <span class="keyword">if</span> isfield(problem.M, <span class="string">'tangent'</span>)
0188         hess = <a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>(problem, x, d, storedb, xkey);
0189         phess = problem.M.tangent(x, hess);
0190         residual = problem.M.lincomb(x, 1, hess, -1, phess);
0191         err = problem.M.norm(x, residual);
0192         fprintf(<span class="string">'Tangency residual should be zero, or very close; '</span>);
0193         fprintf(<span class="string">'residual: %g.\n'</span>, err);
0194         fprintf([<span class="string">'If it is far from 0, then the Hessian is not in the '</span> <span class="keyword">...</span>
0195                  <span class="string">'tangent space.\n'</span>]);
0196     <span class="keyword">else</span>
0197         fprintf([<span class="string">'Unfortunately, Manopt was unable to verify that the '</span><span class="keyword">...</span>
0198                  <span class="string">'output of the Hessian call is indeed a tangent '</span> <span class="keyword">...</span>
0199                  <span class="string">'vector.\nPlease verify this manually.'</span>]);
0200     <span class="keyword">end</span>    
0201     
0202     <span class="comment">%% Check that the Hessian at x is linear and symmetric.</span>
0203     d1 = problem.M.randvec(x);
0204     d2 = problem.M.randvec(x);
0205     h1 = <a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>(problem, x, d1, storedb, xkey);
0206     h2 = <a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>(problem, x, d2, storedb, xkey);
0207     
0208     <span class="comment">% Linearity check</span>
0209     a = randn(1);
0210     b = randn(1);
0211     ad1pbd2 = problem.M.lincomb(x, a, d1, b, d2);
0212     had1pbd2 = <a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>(problem, x, ad1pbd2, storedb, xkey);
0213     ahd1pbhd2 = problem.M.lincomb(x, a, h1, b, h2);
0214     errvec = problem.M.lincomb(x, 1, had1pbd2, -1, ahd1pbhd2);
0215     errvecnrm = problem.M.norm(x, errvec);
0216     had1pbd2nrm = problem.M.norm(x, had1pbd2);
0217     fprintf([<span class="string">'||a*H[d1] + b*H[d2] - H[a*d1+b*d2]|| should be zero, or '</span> <span class="keyword">...</span>
0218              <span class="string">'very close.\n\tValue: %g (norm of H[a*d1+b*d2]: %g)\n'</span>], <span class="keyword">...</span>
0219              errvecnrm, had1pbd2nrm);
0220     fprintf(<span class="string">'If it is far from 0, then the Hessian is not linear.\n'</span>);
0221     
0222     <span class="comment">% Symmetry check</span>
0223     v1 = problem.M.inner(x, d1, h2);
0224     v2 = problem.M.inner(x, h1, d2);
0225     value = v1-v2;
0226     fprintf([<span class="string">'&lt;d1, H[d2]&gt; - &lt;H[d1], d2&gt; should be zero, or very close.'</span> <span class="keyword">...</span>
0227              <span class="string">'\n\tValue: %g - %g = %g.\n'</span>], v1, v2, value);
0228     fprintf(<span class="string">'If it is far from 0, then the Hessian is not symmetric.\n'</span>);
0229     
0230     <span class="comment">%% Check if the manifold at hand is one of those for which there should</span>
0231     <span class="comment">%  be a call to M.tangent2ambient, as this is a common mistake. If so,</span>
0232     <span class="comment">%  issue an additional message. Ideally, one would just need to check</span>
0233     <span class="comment">%  for the presence of tangent2ambient, but productmanifold (for</span>
0234     <span class="comment">%  example) generates one of those in all cases, even if it is just an</span>
0235     <span class="comment">%  identity map.</span>
0236     <span class="keyword">if</span> isfield(problem.M, <span class="string">'tangent2ambient_is_identity'</span>) &amp;&amp; <span class="keyword">...</span>
0237                                      ~problem.M.tangent2ambient_is_identity
0238         
0239         fprintf(<span class="string">'\n\n=== Special message ===\n'</span>);
0240         fprintf([<span class="string">'For this manifold, tangent vectors are represented\n'</span> <span class="keyword">...</span>
0241                  <span class="string">'differently from their ambient space representation.\n'</span> <span class="keyword">...</span>
0242                  <span class="string">'In practice, this means that when defining\n'</span> <span class="keyword">...</span>
0243                  <span class="string">'v = problem.ehess(x, u), one may need to call\n'</span> <span class="keyword">...</span>
0244                  <span class="string">'u = problem.M.tangent2ambient(x, u) first, so as to\n'</span><span class="keyword">...</span>
0245                  <span class="string">'transform u into an ambient vector, if this is more\n'</span> <span class="keyword">...</span>
0246                  <span class="string">'convenient. The output of ehess should be an ambient\n'</span> <span class="keyword">...</span>
0247                  <span class="string">'vector (it will be transformed to a tangent vector\n'</span> <span class="keyword">...</span>
0248                  <span class="string">'automatically).\n'</span>]);
0249         
0250     <span class="keyword">end</span>
0251 
0252     <span class="keyword">if</span> ~<a href="../../manopt/core/canGetHessian.html" class="code" title="function candoit = canGetHessian(problem)">canGetHessian</a>(problem)
0253         norm_grad = problem.M.norm(x, gradx);
0254         fprintf([<span class="string">'\nWhen using checkhessian with a finite difference '</span> <span class="keyword">...</span>
0255                  <span class="string">'approximation, the norm of the residual\nshould be '</span> <span class="keyword">...</span>
0256                  <span class="string">'compared against the norm of the gradient at the '</span> <span class="keyword">...</span>
0257                  <span class="string">'point under consideration (%.2g).\nFurthermore, it '</span> <span class="keyword">...</span>
0258                  <span class="string">'is expected that the FD operator is only approximately'</span> <span class="keyword">...</span>
0259                  <span class="string">' symmetric.\nOf course, the slope can also be off.\n'</span>], <span class="keyword">...</span>
0260                  norm_grad);
0261     <span class="keyword">end</span>
0262     
0263 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 05-Sep-2021 17:57:00 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>