<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of multiprod</title>
  <meta name="keywords" content="multiprod">
  <meta name="description" content="Multiplying 1-D or 2-D subarrays contained in two N-D arrays.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="index.html">tools</a> &gt; multiprod.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\tools&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>multiprod
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Multiplying 1-D or 2-D subarrays contained in two N-D arrays.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function c = multiprod(a, b, idA, idB) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Multiplying 1-D or 2-D subarrays contained in two N-D arrays.
 
   C = MULTIPROD(A,B) is equivalent  to C = MULTIPROD(A,B,[1 2],[1 2])
   C = MULTIPROD(A,B,[D1 D2]) is eq. to C = MULTIPROD(A,B,[D1 D2],[D1 D2])
   C = MULTIPROD(A,B,D1) is equival. to C = MULTIPROD(A,B,D1,D1)

   MULTIPROD performs multiple matrix products, with array expansion (AX)
   enabled. Its first two arguments A and B are &quot;block arrays&quot; of any
   size, containing one or more 1-D or 2-D subarrays, called &quot;blocks&quot; (*).
   For instance, a 5x6x3 array may be viewed as an array containing five
   6x3 blocks. In this case, its size is denoted by 5x(6x3). The 1 or 2
   adjacent dimensions along which the blocks are contained are called the
   &quot;internal dimensions&quot; (IDs) of the array (°).

   1) 2-D by 2-D BLOCK(S) (*)
         C = MULTIPROD(A, B, [DA1 DA2], [DB1 DB2]) contains the products
         of the PxQ matrices in A by the RxS matrices in B. [DA1 DA2] are
         the IDs of A; [DB1 DB2] are the IDs of B.

   2) 2-D by 1-D BLOCK(S) (*)
         C = MULTIPROD(A, B, [DA1 DA2], DB1) contains the products of the
         PxQ matrices in A by the R-element vectors in B. The latter are
         considered to be Rx1 matrices. [DA1 DA2] are the IDs of A; DB1 is
         the ID of B.

   3) 1-D by 2-D BLOCK(S) (*)
         C = MULTIPROD(A, B, DA1, [DB1 DB2]) contains the products of the 
         Q-element vectors in A by the RxS matrices in B. The vectors in A
         are considered to be 1xQ matrices. DA1 is the ID of A; [DB1 DB2]
         are the IDs of B.

   4) 1-D BY 1-D BLOCK(S) (*)
      (a) If either SIZE(A, DA1) == 1 or SIZE(B, DB1) == 1, or both,
             C = MULTIPROD(A, B, DA1, DB1) returns products of scalars by 
             vectors, or vectors by scalars or scalars by scalars.
      (b) If SIZE(A, DA1) == SIZE(B, DB1), 
             C = MULTIPROD(A, B, [0 DA1], [DB1 0]) or 
             C = MULTIPROD(A, B, DA1, DB1) virtually turns the vectors
             contained in A and B into 1xP and Px1 matrices, respectively,
             then returns their products, similar to scalar products.
             Namely, C = DOT2(A, B, DA1, DB1) is equivalent to 
             C = MULTIPROD(CONJ(A), B, [0 DA1], [DB1 0]).
      (c) Without limitations on the length of the vectors in A and B,
             C = MULTIPROD(A, B, [DA1 0], [0 DB1]) turns the vectors
             contained in A and B into Px1 and 1xQ matrices, respectively,
             then returns their products, similar to outer products.
             Namely, C = OUTER(A, B, DA1, DB1) is equivalent to
             C = MULTIPROD(CONJ(A), B, [DA1 0], [0 DB1]).

   Common constraints for all syntaxes:
      The external dimensions of A and B must either be identical or 
      compatible with AX rules. The internal dimensions of each block
      array must be adjacent (DA2 == DA1 + 1 and DB2 == DB1 + 1 are
      required). DA1 and DB1 are allowed to be larger than NDIMS(A) and
      NDIMS(B). In syntaxes 1, 2, and 3, Q == R is required, unless the
      blocks in A or B are scalars. 

   Array expansion (AX):
      AX is a powerful generalization to N-D of the concept of scalar
      expansion. Indeed, A and B may be scalars, vectors, matrices or
      multi-dimensional arrays. Scalar expansion is the virtual
      replication or annihilation of a scalar which allows you to combine
      it, element by element, with an array X of any size (e.g. X+10,
      X*10, or []-10). Similarly, in MULTIPROD, the purpose of AX is to
      automatically match the size of the external dimensions (EDs) of A
      and B, so that block-by-block products can be performed. ED matching
      is achieved by means of a dimension shift followed by a singleton
      expansion:
      1) Dimension shift (see SHIFTDIM).
            Whenever DA1 ~= DB1, a shift is applied to impose DA1 == DB1.
            If DA1 &gt; DB1, B is shifted to the right by DA1 - DB1 steps.
            If DB1 &gt; DA1, A is shifted to the right by DB1 - DA1 steps.
      2) Singleton expansion (SX).
            Whenever an ED of either A or B is singleton and the
            corresponding ED of the other array is not, the mismatch is
            fixed by virtually replicating the array (or diminishing it to
            length 0) along that dimension.
 
   MULTIPROD is a generalization for N-D arrays of the matrix
   multiplication function MTIMES, with AX enabled. Vector inner, outer,
   and cross products generalized for N-D arrays and with AX enabled are
   performed by DOT2, OUTER, and CROSS2 (MATLAB Central, file #8782).
   Elementwise multiplications (see TIMES) and other elementwise binary
   operations with AX enabled are performed by BAXFUN (MATLAB Central,
   file #23084). Together, these functions make up the &quot;ARRAYLAB toolbox&quot;.

   Input and output format:
      The size of the EDs of C is determined by AX. Block size is
      determined as follows, for each of the above-listed syntaxes:
      1) C contains PxS matrices along IDs MAX([DA1 DA2], [DB1 DB2]).
      2) Array     Block size     ID(s)
         ----------------------------------------------------
         A         PxQ  (2-D)     [DA1 DA2]
         B         R    (1-D)     DB1
         C (a)     P    (1-D)     MAX(DA1, DB1)
         C (b)     PxQ  (2-D)     MAX([DA1 DA2], [DB1 DB1+1])
         ----------------------------------------------------
         (a) The 1-D blocks in B are not scalars (R &gt; 1).
         (b) The 1-D blocks in B are scalars (R = 1).
      3) Array     Block size     ID(s)
         ----------------------------------------------------
         A           Q  (1-D)     DA1
         B         RxS  (2-D)     [DB1 DB2]
         C (a)       S  (1-D)     MAX(DA1, DB1)
         C (b)     RxS  (2-D)     MAX([DA1 DA1+1], [DB1 DB2])
         ----------------------------------------------------
         (a) The 1-D blocks in A are not scalars (Q &gt; 1).
         (b) The 1-D blocks in A are scalars (Q = 1).
      4)     Array     Block size         ID(s)
         --------------------------------------------------------------
         (a) A         P        (1-D)     DA1
             B         Q        (1-D)     DB1
             C         MAX(P,Q) (1-D)     MAX(DA1, DB1)
         --------------------------------------------------------------
         (b) A         P        (1-D)     DA1
             B         P        (1-D)     DB1
             C         1        (1-D)     MAX(DA1, DB1)
         --------------------------------------------------------------
         (c) A         P        (1-D)     DA1
             B         Q        (1-D)     DB1
             C         PxQ      (2-D)     MAX([DA1 DA1+1], [DB1 DB1+1])
         --------------------------------------------------------------

   Terminological notes:
   (*) 1-D and 2-D blocks are generically referred to as &quot;vectors&quot; and 
       &quot;matrices&quot;, respectively. However, both may be also called
       &quot;scalars&quot; if they have a single element. Moreover, matrices with a
       single row or column (e.g. 1x3 or 3x1) may be also called &quot;row
       vectors&quot; or &quot;column vectors&quot;.
   (°) Not to be confused with the &quot;inner dimensions&quot; of the two matrices
       involved in a product X * Y, defined as the 2nd dimension of X and
       the 1st of Y (DA2 and DB1 in syntaxes 1, 2, 3).

   Examples:
    1) If  A is .................... a 5x(6x3)x2 array,
       and B is .................... a 5x(3x4)x2 array,
       C = MULTIPROD(A, B, [2 3]) is a 5x(6x4)x2 array.

       A single matrix A pre-multiplies each matrix in B
       If  A is ........................... a (1x3)    single matrix,
       and B is ........................... a 10x(3x4) 3-D array,
       C = MULTIPROD(A, B, [1 2], [3 4]) is a 10x(1x4) 3-D array.

       Each matrix in A pre-multiplies each matrix in B (all possible
       combinations)
       If  A is .................... a (6x3)x5   array,
       and B is .................... a (3x4)x1x2 array,
       C = MULTIPROD(A, B, [1 2]) is a (6x4)x5x2 array.

   2a) If  A is ........................... a 5x(6x3)x2 4-D array,
       and B is ........................... a 5x(3)x2   3-D array,
       C = MULTIPROD(A, B, [2 3], [2]) is   a 5x(6)x2   3-D array.

   2b) If  A is ........................... a 5x(6x3)x2 4-D array,
       and B is ........................... a 5x(1)x2   3-D array,
       C = MULTIPROD(A, B, [2 3], [2]) is   a 5x(6x3)x2 4-D array.

   4a) If both A and B are .................. 5x(6)x2   3-D arrays,
       C = MULTIPROD(A, B, 2) is .......... a 5x(1)x2   3-D array, while
   4b) C = MULTIPROD(A, B, [2 0], [0 2]) is a 5x(6x6)x2 4-D array

   See also DOT2, OUTER, CROSS2, BAXFUN, <a href="multitransp.html" class="code" title="function b = multitransp(a, dim)">MULTITRANSP</a>, <a href="multitrace.html" class="code" title="function tr = multitrace(A)">MULTITRACE</a>, <a href="multiscale.html" class="code" title="function A = multiscale(scale, A)">MULTISCALE</a>.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../examples/essential_svd.html" class="code" title="function essential_svd">essential_svd</a>	Sample solution of an optimization problem on the essential manifold.</li><li><a href="../../examples/generalized_procrustes.html" class="code" title="function [A, R] = generalized_procrustes(A_measure)">generalized_procrustes</a>	Rotationally align clouds of points (generalized Procrustes problem)</li><li><a href="../../examples/robust_pca.html" class="code" title="function [U, cost] = robust_pca(X, d)">robust_pca</a>	Computes a robust version of PCA (principal component analysis) on data.</li><li><a href="../../manopt/manifolds/essential/essential_costE2cost.html" class="code" title="function val = essential_costE2cost(X, costE)">essential_costE2cost</a>	Cost evaluation at X given function handle in the Essential matrix E.</li><li><a href="../../manopt/manifolds/essential/essential_egradE2egrad.html" class="code" title="function egrad = essential_egradE2egrad(X, egradE)">essential_egradE2egrad</a>	Converts the gradient in essential matrix E to the gradient in X.</li><li><a href="../../manopt/manifolds/essential/essential_ehessE2ehess.html" class="code" title="function ehess = essential_ehessE2ehess(X, egradE, ehessE, S)">essential_ehessE2ehess</a>	Converts the Hessian in essential matrix E to the Hessian in X.</li><li><a href="../../manopt/manifolds/essential/essentialfactory.html" class="code" title="function M = essentialfactory(k, strSigned)">essentialfactory</a>	Manifold structure to optimize over the space of essential matrices.</li><li><a href="../../manopt/manifolds/grassmann/grassmanncomplexfactory.html" class="code" title="function M = grassmanncomplexfactory(n, p, k)">grassmanncomplexfactory</a>	Returns a manifold struct to optimize over the set of subspaces in C^n.</li><li><a href="../../manopt/manifolds/grassmann/grassmannfactory.html" class="code" title="function M = grassmannfactory(n, p, k)">grassmannfactory</a>	Returns a manifold struct to optimize over the space of vector subspaces.</li><li><a href="../../manopt/manifolds/rotations/rotationsfactory.html" class="code" title="function M = rotationsfactory(n, k)">rotationsfactory</a>	Returns a manifold structure to optimize over rotation matrices.</li><li><a href="../../manopt/manifolds/stiefel/stiefelcomplexfactory.html" class="code" title="function M = stiefelcomplexfactory(n, p, k)">stiefelcomplexfactory</a>	Returns a manifold struct. to optimize over complex orthonormal matrices.</li><li><a href="../../manopt/manifolds/stiefel/stiefelfactory.html" class="code" title="function M = stiefelfactory(n, p, k)">stiefelfactory</a>	Returns a manifold structure to optimize over orthonormal matrices.</li><li><a href="../../manopt/manifolds/stiefel/stiefelstackedfactory.html" class="code" title="function M = stiefelstackedfactory(m, d, k)">stiefelstackedfactory</a>	Stiefel(k, d)^m, represented as matrices of size m*d-by-k.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function c = squash2D_mtimes(a, b, idA, idB, sizeA, sizeB, squashOK)</a></li><li><a href="#_sub2" class="code">function [sizeA, sizeB, shiftC, delC, sizeisnew, idA, idB,</a></li><li><a href="#_sub3" class="code">function [sizeA, sizeisnew] = adjustsize(sizeA0, shiftA, addA, delA, swapA)</a></li><li><a href="#_sub4" class="code">function [newsize, flag] = addsing(size0, dim, ns)</a></li><li><a href="#_sub5" class="code">function [newsize, flag] = delsing(size0, dim, ns)</a></li><li><a href="#_sub6" class="code">function [newsize, flag] = swapdim(size0, dim)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function c = multiprod(a, b, idA, idB)</a>
0002 <span class="comment">% Multiplying 1-D or 2-D subarrays contained in two N-D arrays.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   C = MULTIPROD(A,B) is equivalent  to C = MULTIPROD(A,B,[1 2],[1 2])</span>
0005 <span class="comment">%   C = MULTIPROD(A,B,[D1 D2]) is eq. to C = MULTIPROD(A,B,[D1 D2],[D1 D2])</span>
0006 <span class="comment">%   C = MULTIPROD(A,B,D1) is equival. to C = MULTIPROD(A,B,D1,D1)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%   MULTIPROD performs multiple matrix products, with array expansion (AX)</span>
0009 <span class="comment">%   enabled. Its first two arguments A and B are &quot;block arrays&quot; of any</span>
0010 <span class="comment">%   size, containing one or more 1-D or 2-D subarrays, called &quot;blocks&quot; (*).</span>
0011 <span class="comment">%   For instance, a 5x6x3 array may be viewed as an array containing five</span>
0012 <span class="comment">%   6x3 blocks. In this case, its size is denoted by 5x(6x3). The 1 or 2</span>
0013 <span class="comment">%   adjacent dimensions along which the blocks are contained are called the</span>
0014 <span class="comment">%   &quot;internal dimensions&quot; (IDs) of the array (°).</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   1) 2-D by 2-D BLOCK(S) (*)</span>
0017 <span class="comment">%         C = MULTIPROD(A, B, [DA1 DA2], [DB1 DB2]) contains the products</span>
0018 <span class="comment">%         of the PxQ matrices in A by the RxS matrices in B. [DA1 DA2] are</span>
0019 <span class="comment">%         the IDs of A; [DB1 DB2] are the IDs of B.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%   2) 2-D by 1-D BLOCK(S) (*)</span>
0022 <span class="comment">%         C = MULTIPROD(A, B, [DA1 DA2], DB1) contains the products of the</span>
0023 <span class="comment">%         PxQ matrices in A by the R-element vectors in B. The latter are</span>
0024 <span class="comment">%         considered to be Rx1 matrices. [DA1 DA2] are the IDs of A; DB1 is</span>
0025 <span class="comment">%         the ID of B.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%   3) 1-D by 2-D BLOCK(S) (*)</span>
0028 <span class="comment">%         C = MULTIPROD(A, B, DA1, [DB1 DB2]) contains the products of the</span>
0029 <span class="comment">%         Q-element vectors in A by the RxS matrices in B. The vectors in A</span>
0030 <span class="comment">%         are considered to be 1xQ matrices. DA1 is the ID of A; [DB1 DB2]</span>
0031 <span class="comment">%         are the IDs of B.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%   4) 1-D BY 1-D BLOCK(S) (*)</span>
0034 <span class="comment">%      (a) If either SIZE(A, DA1) == 1 or SIZE(B, DB1) == 1, or both,</span>
0035 <span class="comment">%             C = MULTIPROD(A, B, DA1, DB1) returns products of scalars by</span>
0036 <span class="comment">%             vectors, or vectors by scalars or scalars by scalars.</span>
0037 <span class="comment">%      (b) If SIZE(A, DA1) == SIZE(B, DB1),</span>
0038 <span class="comment">%             C = MULTIPROD(A, B, [0 DA1], [DB1 0]) or</span>
0039 <span class="comment">%             C = MULTIPROD(A, B, DA1, DB1) virtually turns the vectors</span>
0040 <span class="comment">%             contained in A and B into 1xP and Px1 matrices, respectively,</span>
0041 <span class="comment">%             then returns their products, similar to scalar products.</span>
0042 <span class="comment">%             Namely, C = DOT2(A, B, DA1, DB1) is equivalent to</span>
0043 <span class="comment">%             C = MULTIPROD(CONJ(A), B, [0 DA1], [DB1 0]).</span>
0044 <span class="comment">%      (c) Without limitations on the length of the vectors in A and B,</span>
0045 <span class="comment">%             C = MULTIPROD(A, B, [DA1 0], [0 DB1]) turns the vectors</span>
0046 <span class="comment">%             contained in A and B into Px1 and 1xQ matrices, respectively,</span>
0047 <span class="comment">%             then returns their products, similar to outer products.</span>
0048 <span class="comment">%             Namely, C = OUTER(A, B, DA1, DB1) is equivalent to</span>
0049 <span class="comment">%             C = MULTIPROD(CONJ(A), B, [DA1 0], [0 DB1]).</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   Common constraints for all syntaxes:</span>
0052 <span class="comment">%      The external dimensions of A and B must either be identical or</span>
0053 <span class="comment">%      compatible with AX rules. The internal dimensions of each block</span>
0054 <span class="comment">%      array must be adjacent (DA2 == DA1 + 1 and DB2 == DB1 + 1 are</span>
0055 <span class="comment">%      required). DA1 and DB1 are allowed to be larger than NDIMS(A) and</span>
0056 <span class="comment">%      NDIMS(B). In syntaxes 1, 2, and 3, Q == R is required, unless the</span>
0057 <span class="comment">%      blocks in A or B are scalars.</span>
0058 <span class="comment">%</span>
0059 <span class="comment">%   Array expansion (AX):</span>
0060 <span class="comment">%      AX is a powerful generalization to N-D of the concept of scalar</span>
0061 <span class="comment">%      expansion. Indeed, A and B may be scalars, vectors, matrices or</span>
0062 <span class="comment">%      multi-dimensional arrays. Scalar expansion is the virtual</span>
0063 <span class="comment">%      replication or annihilation of a scalar which allows you to combine</span>
0064 <span class="comment">%      it, element by element, with an array X of any size (e.g. X+10,</span>
0065 <span class="comment">%      X*10, or []-10). Similarly, in MULTIPROD, the purpose of AX is to</span>
0066 <span class="comment">%      automatically match the size of the external dimensions (EDs) of A</span>
0067 <span class="comment">%      and B, so that block-by-block products can be performed. ED matching</span>
0068 <span class="comment">%      is achieved by means of a dimension shift followed by a singleton</span>
0069 <span class="comment">%      expansion:</span>
0070 <span class="comment">%      1) Dimension shift (see SHIFTDIM).</span>
0071 <span class="comment">%            Whenever DA1 ~= DB1, a shift is applied to impose DA1 == DB1.</span>
0072 <span class="comment">%            If DA1 &gt; DB1, B is shifted to the right by DA1 - DB1 steps.</span>
0073 <span class="comment">%            If DB1 &gt; DA1, A is shifted to the right by DB1 - DA1 steps.</span>
0074 <span class="comment">%      2) Singleton expansion (SX).</span>
0075 <span class="comment">%            Whenever an ED of either A or B is singleton and the</span>
0076 <span class="comment">%            corresponding ED of the other array is not, the mismatch is</span>
0077 <span class="comment">%            fixed by virtually replicating the array (or diminishing it to</span>
0078 <span class="comment">%            length 0) along that dimension.</span>
0079 <span class="comment">%</span>
0080 <span class="comment">%   MULTIPROD is a generalization for N-D arrays of the matrix</span>
0081 <span class="comment">%   multiplication function MTIMES, with AX enabled. Vector inner, outer,</span>
0082 <span class="comment">%   and cross products generalized for N-D arrays and with AX enabled are</span>
0083 <span class="comment">%   performed by DOT2, OUTER, and CROSS2 (MATLAB Central, file #8782).</span>
0084 <span class="comment">%   Elementwise multiplications (see TIMES) and other elementwise binary</span>
0085 <span class="comment">%   operations with AX enabled are performed by BAXFUN (MATLAB Central,</span>
0086 <span class="comment">%   file #23084). Together, these functions make up the &quot;ARRAYLAB toolbox&quot;.</span>
0087 <span class="comment">%</span>
0088 <span class="comment">%   Input and output format:</span>
0089 <span class="comment">%      The size of the EDs of C is determined by AX. Block size is</span>
0090 <span class="comment">%      determined as follows, for each of the above-listed syntaxes:</span>
0091 <span class="comment">%      1) C contains PxS matrices along IDs MAX([DA1 DA2], [DB1 DB2]).</span>
0092 <span class="comment">%      2) Array     Block size     ID(s)</span>
0093 <span class="comment">%         ----------------------------------------------------</span>
0094 <span class="comment">%         A         PxQ  (2-D)     [DA1 DA2]</span>
0095 <span class="comment">%         B         R    (1-D)     DB1</span>
0096 <span class="comment">%         C (a)     P    (1-D)     MAX(DA1, DB1)</span>
0097 <span class="comment">%         C (b)     PxQ  (2-D)     MAX([DA1 DA2], [DB1 DB1+1])</span>
0098 <span class="comment">%         ----------------------------------------------------</span>
0099 <span class="comment">%         (a) The 1-D blocks in B are not scalars (R &gt; 1).</span>
0100 <span class="comment">%         (b) The 1-D blocks in B are scalars (R = 1).</span>
0101 <span class="comment">%      3) Array     Block size     ID(s)</span>
0102 <span class="comment">%         ----------------------------------------------------</span>
0103 <span class="comment">%         A           Q  (1-D)     DA1</span>
0104 <span class="comment">%         B         RxS  (2-D)     [DB1 DB2]</span>
0105 <span class="comment">%         C (a)       S  (1-D)     MAX(DA1, DB1)</span>
0106 <span class="comment">%         C (b)     RxS  (2-D)     MAX([DA1 DA1+1], [DB1 DB2])</span>
0107 <span class="comment">%         ----------------------------------------------------</span>
0108 <span class="comment">%         (a) The 1-D blocks in A are not scalars (Q &gt; 1).</span>
0109 <span class="comment">%         (b) The 1-D blocks in A are scalars (Q = 1).</span>
0110 <span class="comment">%      4)     Array     Block size         ID(s)</span>
0111 <span class="comment">%         --------------------------------------------------------------</span>
0112 <span class="comment">%         (a) A         P        (1-D)     DA1</span>
0113 <span class="comment">%             B         Q        (1-D)     DB1</span>
0114 <span class="comment">%             C         MAX(P,Q) (1-D)     MAX(DA1, DB1)</span>
0115 <span class="comment">%         --------------------------------------------------------------</span>
0116 <span class="comment">%         (b) A         P        (1-D)     DA1</span>
0117 <span class="comment">%             B         P        (1-D)     DB1</span>
0118 <span class="comment">%             C         1        (1-D)     MAX(DA1, DB1)</span>
0119 <span class="comment">%         --------------------------------------------------------------</span>
0120 <span class="comment">%         (c) A         P        (1-D)     DA1</span>
0121 <span class="comment">%             B         Q        (1-D)     DB1</span>
0122 <span class="comment">%             C         PxQ      (2-D)     MAX([DA1 DA1+1], [DB1 DB1+1])</span>
0123 <span class="comment">%         --------------------------------------------------------------</span>
0124 <span class="comment">%</span>
0125 <span class="comment">%   Terminological notes:</span>
0126 <span class="comment">%   (*) 1-D and 2-D blocks are generically referred to as &quot;vectors&quot; and</span>
0127 <span class="comment">%       &quot;matrices&quot;, respectively. However, both may be also called</span>
0128 <span class="comment">%       &quot;scalars&quot; if they have a single element. Moreover, matrices with a</span>
0129 <span class="comment">%       single row or column (e.g. 1x3 or 3x1) may be also called &quot;row</span>
0130 <span class="comment">%       vectors&quot; or &quot;column vectors&quot;.</span>
0131 <span class="comment">%   (°) Not to be confused with the &quot;inner dimensions&quot; of the two matrices</span>
0132 <span class="comment">%       involved in a product X * Y, defined as the 2nd dimension of X and</span>
0133 <span class="comment">%       the 1st of Y (DA2 and DB1 in syntaxes 1, 2, 3).</span>
0134 <span class="comment">%</span>
0135 <span class="comment">%   Examples:</span>
0136 <span class="comment">%    1) If  A is .................... a 5x(6x3)x2 array,</span>
0137 <span class="comment">%       and B is .................... a 5x(3x4)x2 array,</span>
0138 <span class="comment">%       C = MULTIPROD(A, B, [2 3]) is a 5x(6x4)x2 array.</span>
0139 <span class="comment">%</span>
0140 <span class="comment">%       A single matrix A pre-multiplies each matrix in B</span>
0141 <span class="comment">%       If  A is ........................... a (1x3)    single matrix,</span>
0142 <span class="comment">%       and B is ........................... a 10x(3x4) 3-D array,</span>
0143 <span class="comment">%       C = MULTIPROD(A, B, [1 2], [3 4]) is a 10x(1x4) 3-D array.</span>
0144 <span class="comment">%</span>
0145 <span class="comment">%       Each matrix in A pre-multiplies each matrix in B (all possible</span>
0146 <span class="comment">%       combinations)</span>
0147 <span class="comment">%       If  A is .................... a (6x3)x5   array,</span>
0148 <span class="comment">%       and B is .................... a (3x4)x1x2 array,</span>
0149 <span class="comment">%       C = MULTIPROD(A, B, [1 2]) is a (6x4)x5x2 array.</span>
0150 <span class="comment">%</span>
0151 <span class="comment">%   2a) If  A is ........................... a 5x(6x3)x2 4-D array,</span>
0152 <span class="comment">%       and B is ........................... a 5x(3)x2   3-D array,</span>
0153 <span class="comment">%       C = MULTIPROD(A, B, [2 3], [2]) is   a 5x(6)x2   3-D array.</span>
0154 <span class="comment">%</span>
0155 <span class="comment">%   2b) If  A is ........................... a 5x(6x3)x2 4-D array,</span>
0156 <span class="comment">%       and B is ........................... a 5x(1)x2   3-D array,</span>
0157 <span class="comment">%       C = MULTIPROD(A, B, [2 3], [2]) is   a 5x(6x3)x2 4-D array.</span>
0158 <span class="comment">%</span>
0159 <span class="comment">%   4a) If both A and B are .................. 5x(6)x2   3-D arrays,</span>
0160 <span class="comment">%       C = MULTIPROD(A, B, 2) is .......... a 5x(1)x2   3-D array, while</span>
0161 <span class="comment">%   4b) C = MULTIPROD(A, B, [2 0], [0 2]) is a 5x(6x6)x2 4-D array</span>
0162 <span class="comment">%</span>
0163 <span class="comment">%   See also DOT2, OUTER, CROSS2, BAXFUN, MULTITRANSP, MULTITRACE, MULTISCALE.</span>
0164 
0165 <span class="comment">% $ Version: 2.1 $</span>
0166 <span class="comment">% CODE      by:            Paolo de Leva</span>
0167 <span class="comment">%                          (Univ. of Rome, Foro Italico, IT)    2009 Jan 24</span>
0168 <span class="comment">%           optimized by:  Paolo de Leva</span>
0169 <span class="comment">%                          Jinhui Bai (Georgetown Univ., D.C.)  2009 Jan 24</span>
0170 <span class="comment">% COMMENTS  by:            Paolo de Leva                        2009 Feb 24</span>
0171 <span class="comment">% OUTPUT    tested by:     Paolo de Leva                        2009 Feb 24</span>
0172 <span class="comment">% -------------------------------------------------------------------------</span>
0173 
0174 assert(nargin &gt;= 2 &amp;&amp; nargin &lt;= 4, <span class="string">'Takes from 2 to 4 inputs.'</span>);
0175 
0176 <span class="keyword">switch</span> nargin <span class="comment">% Setting IDA and/or IDB</span>
0177     <span class="keyword">case</span> 2, idA = [1 2]; idB = [1 2];
0178     <span class="keyword">case</span> 3, idB = idA;
0179 <span class="keyword">end</span>
0180 
0181 <span class="comment">% ESC 1 - Special simple case (both A and B are 2D), solved using C = A * B</span>
0182 
0183      <span class="keyword">if</span> ndims(a)==2 &amp;&amp; ndims(b)==2 &amp;&amp; <span class="keyword">...</span>
0184          isequal(idA,[1 2]) &amp;&amp; isequal(idB,[1 2])
0185          c = a * b; <span class="keyword">return</span>
0186      <span class="keyword">end</span>
0187 
0188 <span class="comment">% MAIN 0 - Checking and evaluating array size, block size, and IDs</span>
0189 
0190      sizeA0 = size(a);
0191      sizeB0 = size(b);
0192      [sizeA, sizeB, shiftC, delC, sizeisnew, idA, idB, <span class="keyword">...</span>
0193      squashOK, sxtimesOK, timesOK, mtimesOK, sumOK] = <span class="keyword">...</span>
0194                                            sizeval(idA,idB, sizeA0,sizeB0);
0195 
0196 <span class="comment">% MAIN 1 - Applying dimension shift (first step of AX) and</span>
0197 <span class="comment">%          turning both A and B into arrays of either 1-D or 2-D blocks</span>
0198 
0199      <span class="keyword">if</span> sizeisnew(1), a = reshape(a, sizeA); <span class="keyword">end</span>    
0200      <span class="keyword">if</span> sizeisnew(2), b = reshape(b, sizeB); <span class="keyword">end</span>
0201 
0202 <span class="comment">% MAIN 2 - Performing products with or without SX (second step of AX)</span>
0203 
0204      <span class="keyword">if</span> squashOK <span class="comment">% SQUASH + MTIMES (fastest engine)</span>
0205          c = <a href="#_sub1" class="code" title="subfunction c = squash2D_mtimes(a, b, idA, idB, sizeA, sizeB, squashOK)">squash2D_mtimes</a>(a,b, idA,idB, sizeA,sizeB, squashOK); 
0206      <span class="keyword">elseif</span> timesOK <span class="comment">% TIMES (preferred w.r. to SX + TIMES)</span>
0207          <span class="keyword">if</span> sumOK, c = sum(a .* b, sumOK);
0208          <span class="keyword">else</span>      c =     a .* b; <span class="keyword">end</span>
0209      <span class="keyword">elseif</span> sxtimesOK <span class="comment">% SX + TIMES</span>
0210          <span class="keyword">if</span> sumOK, c = sum(bsxfun(@times, a, b), sumOK);
0211          <span class="keyword">else</span>      c =     bsxfun(@times, a, b); <span class="keyword">end</span>
0212      <span class="keyword">elseif</span> mtimesOK <span class="comment">% MTIMES (rarely used)</span>
0213          c = a * b;
0214      <span class="keyword">end</span>
0215 
0216 <span class="comment">% MAIN 3 - Reshaping C (by inserting or removing singleton dimensions)</span>
0217 
0218      [sizeC sizeCisnew] = <a href="#_sub3" class="code" title="subfunction [sizeA, sizeisnew] = adjustsize(sizeA0, shiftA, addA, delA, swapA)">adjustsize</a>(size(c), shiftC, false, delC, false);
0219      <span class="keyword">if</span> sizeCisnew, c = reshape(c, sizeC); <span class="keyword">end</span>
0220 
0221 
0222 <a name="_sub1" href="#_subfunctions" class="code">function c = squash2D_mtimes(a, b, idA, idB, sizeA, sizeB, squashOK)</a>
0223 <span class="comment">% SQUASH2D_MTIMES  Multiproduct with single-block expansion (SBX).</span>
0224 <span class="comment">%    Actually, no expansion is performed. The multi-block array is</span>
0225 <span class="comment">%    rearranged from N-D to 2-D, then MTIMES is applied, and eventually the</span>
0226 <span class="comment">%    result is rearranged back to N-D. No additional memory is required.</span>
0227 <span class="comment">%    One and only one of the two arrays must be single-block, and its IDs</span>
0228 <span class="comment">%    must be [1 2] (MAIN 1 removes leading singletons). Both arrays</span>
0229 <span class="comment">%    must contain 2-D blocks (MAIN 1 expands 1-D blocks to 2-D).</span>
0230 
0231     <span class="keyword">if</span> squashOK == 1 <span class="comment">% A is multi-block, B is single-block (squashing A)</span>
0232 
0233         <span class="comment">% STEP 1 - Moving IDA(2) to last dimension</span>
0234         nd = length(sizeA);
0235         d2 = idA(2);    
0236         order = [1:(d2-1) (d2+1):nd d2]; <span class="comment">% Partial shifting</span>
0237         a = permute(a, order); <span class="comment">% ...xQ</span>
0238 
0239         <span class="comment">% STEP 2 - Squashing A from N-D to 2-D</span>
0240         q = sizeB(1);
0241         s = sizeB(2);
0242         lengthorder = length(order);
0243         collapsedsize = sizeA(order(1:lengthorder-1)); 
0244         n = prod(collapsedsize);
0245         a = reshape(a, [n, q]); <span class="comment">% NxQ</span>
0246         fullsize = [collapsedsize s]; <span class="comment">% Size to reshape C back to N-D</span>
0247 
0248     <span class="keyword">else</span> <span class="comment">% B is multi-block, A is single-block (squashing B)</span>
0249 
0250         <span class="comment">% STEP 1 - Moving IDB(1) to first dimension</span>
0251         nd = length(sizeB);
0252         d1 = idB(1);    
0253         order = [d1 1:(d1-1) (d1+1):nd]; <span class="comment">% Partial shifting</span>
0254         b = permute(b, order); <span class="comment">% Qx...</span>
0255 
0256         <span class="comment">% STEP 2 - Squashing B from N-D to 2-D</span>
0257         p = sizeA(1);
0258         q = sizeA(2);
0259         lengthorder = length(order);
0260         collapsedsize = sizeB(order(2:lengthorder)); 
0261         n = prod(collapsedsize);
0262         b = reshape(b, [q, n]); <span class="comment">% QxN</span>
0263         fullsize = [p collapsedsize]; <span class="comment">% Size to reshape C back to N-D</span>
0264 
0265     <span class="keyword">end</span>
0266 
0267     <span class="comment">% FINAL STEPS - Multiplication, reshape to N-D, inverse permutation</span>
0268     invorder(order) = 1 : lengthorder;
0269     c = permute (reshape(a*b, fullsize), invorder);
0270 
0271 
0272 <a name="_sub2" href="#_subfunctions" class="code">function [sizeA, sizeB, shiftC, delC, sizeisnew, idA, idB, </a><span class="keyword">...</span>
0273           squashOK, sxtimesOK, timesOK, mtimesOK, sumOK] = <span class="keyword">...</span>
0274                                           sizeval(idA0,idB0, sizeA0,sizeB0)
0275 <span class="comment">%SIZEVAL   Evaluation of array size, block size, and IDs</span>
0276 <span class="comment">%    Possible values for IDA and IDB:</span>
0277 <span class="comment">%        [DA1 DA2], [DB1 DB2]</span>
0278 <span class="comment">%        [DA1 DA2], [DB1]</span>
0279 <span class="comment">%        [DA1],     [DB1 DB2]</span>
0280 <span class="comment">%        [DA1],     [DB1]</span>
0281 <span class="comment">%        [DA1 0],   [0 DB1]</span>
0282 <span class="comment">%        [0 DA1],   [DB1 0]</span>
0283 <span class="comment">%</span>
0284 <span class="comment">%    sizeA/B     Equal to sizeA0/B0 if RESHAPE is not needed in MAIN 1</span>
0285 <span class="comment">%    shiftC, delC    Variables controlling MAIN 3.</span>
0286 <span class="comment">%    sizeisnew   1x2 logical array; activates reshaping of A and B.</span>
0287 <span class="comment">%    idA/B       May change only if squashOK ~= 0</span>
0288 <span class="comment">%    squashOK    If only A or B is a multi-block array (M-B) and the other</span>
0289 <span class="comment">%                is single-block (1-B), it will be rearranged from N-D to</span>
0290 <span class="comment">%                2-D. If both A and B are 1-B or M-B arrays, squashOK = 0.</span>
0291 <span class="comment">%                If only A (or B) is a M-B array, squashOK = 1 (or 2).</span>
0292 <span class="comment">%    sxtimesOK, timesOK, mtimesOK    Flags controlling MAIN 2 (TRUE/FALSE).</span>
0293 <span class="comment">%    sumOK       Dimension along which SUM is performed. If SUM is not</span>
0294 <span class="comment">%                needed, sumOK = 0.</span>
0295 
0296 <span class="comment">% Initializing output arguments</span>
0297 
0298     idA = idA0;
0299     idB = idB0;
0300      squashOK = 0;
0301     sxtimesOK = false;
0302       timesOK = false;
0303      mtimesOK = false;
0304         sumOK = 0;
0305     shiftC = 0;
0306     delC = 0;
0307 
0308 <span class="comment">% Checking for gross input errors</span>
0309 
0310     NidA = numel(idA);
0311     NidB = numel(idB);
0312     idA1 = idA(1);
0313     idB1 = idB(1);
0314     <span class="keyword">if</span>  NidA&gt;2 || NidB&gt;2 || NidA==0 || NidB==0 || <span class="keyword">...</span>
0315            ~isreal(idA1) ||    ~isreal(idB1)   || <span class="keyword">...</span>
0316         ~isnumeric(idA1) || ~isnumeric(idB1)   || <span class="keyword">...</span>
0317                  0&gt;idA1  ||          0&gt;idB1    || <span class="keyword">...</span><span class="comment"> % negative </span>
0318          idA1~=fix(idA1) ||  idB1~=fix(idB1)   || <span class="keyword">...</span><span class="comment"> % non-integer</span>
0319          ~isfinite(idA1) ||  ~isfinite(idB1) <span class="comment">% Inf or NaN</span>
0320         error(<span class="string">'MULTIPROD:InvalidDimensionArgument'</span>, <span class="keyword">...</span>
0321         [<span class="string">'Internal-dimension arguments (e.g., [IDA1 IDA2]) must\n'</span>, <span class="keyword">...</span>
0322          <span class="string">'contain only one or two non-negative finite integers'</span>]);
0323     <span class="keyword">end</span>
0324 
0325 <span class="comment">% Checking Syntaxes containing zeros (4b/c)</span>
0326 
0327     declared_outer = false;
0328     idA2 = idA(NidA); <span class="comment">% It may be IDA1 = IDA2 (1-D block)</span>
0329     idB2 = idB(NidB);
0330 
0331     <span class="keyword">if</span> any(idA==0) || any(idB==0)
0332         
0333         <span class="comment">% &quot;Inner products&quot;: C = MULTIPROD(A, B, [0 DA1], [DB1 0])</span>
0334         <span class="keyword">if</span> idA1==0 &amp;&amp; idA2&gt;0 &amp;&amp; idB1&gt;0 &amp;&amp; idB2==0
0335             idA1 = idA2;
0336             idB2 = idB1;
0337         <span class="comment">% &quot;Outer products&quot;: C = MULTIPROD(A, B, [DA1 0], [0 DB1])</span>
0338         <span class="keyword">elseif</span> idA1&gt;0 &amp;&amp; idA2==0 &amp;&amp; idB1==0 &amp;&amp; idB2&gt;0
0339             declared_outer = true;
0340             idA2 = idA1;
0341             idB1 = idB2;
0342         <span class="keyword">else</span>
0343             error(<span class="string">'MULTIPROD:InvalidDimensionArgument'</span>, <span class="keyword">...</span>
0344             [<span class="string">'Misused zeros in the internal-dimension arguments\n'</span>, <span class="keyword">...</span>
0345             <span class="string">'(see help heads 4b and 4c)'</span>]);
0346         <span class="keyword">end</span>
0347         NidA = 1; 
0348         NidB = 1;
0349         idA = idA1;
0350         idB = idB1;
0351 
0352     <span class="keyword">elseif</span> (NidA==2 &amp;&amp; idA2~=idA1+1) || <span class="keyword">...</span><span class="comment">  % Non-adjacent IDs</span>
0353            (NidB==2 &amp;&amp; idB2~=idB1+1)
0354         error(<span class="string">'MULTIPROD:InvalidDimensionArgument'</span>, <span class="keyword">...</span>
0355         [<span class="string">'If an array contains 2-D blocks, its two internal dimensions'</span>, <span class="keyword">...</span><span class="comment"> </span>
0356         <span class="string">'must be adjacent (e.g. IDA2 == IDA1+1)'</span>]);
0357     <span class="keyword">end</span>
0358 
0359 <span class="comment">% ESC - Case for which no reshaping is needed (both A and B are scalars)</span>
0360 
0361     scalarA = isequal(sizeA0, [1 1]);
0362     scalarB = isequal(sizeB0, [1 1]);
0363     <span class="keyword">if</span> scalarA &amp;&amp; scalarB
0364         sizeA = sizeA0;
0365         sizeB = sizeB0;
0366         sizeisnew = [false false];
0367         timesOK = true; <span class="keyword">return</span>
0368     <span class="keyword">end</span>
0369 
0370 <span class="comment">% Computing and checking adjusted sizes</span>
0371 <span class="comment">% The lengths of ADJSIZEA and ADJSIZEB must be &gt;= IDA(END) and IDB(END)</span>
0372 
0373     NsA = idA2 - length(sizeA0); <span class="comment">% Number of added trailing singletons</span>
0374     NsB = idB2 - length(sizeB0);
0375     adjsizeA = [sizeA0 ones(1,NsA)];
0376     adjsizeB = [sizeB0 ones(1,NsB)];
0377     extsizeA = adjsizeA([1:idA1-1, idA2+1:end]); <span class="comment">% Size of EDs</span>
0378     extsizeB = adjsizeB([1:idB1-1, idB2+1:end]);
0379     p = adjsizeA(idA1);
0380     q = adjsizeA(idA2);
0381     r = adjsizeB(idB1);
0382     s = adjsizeB(idB2);    
0383     scalarsinA = (p==1 &amp;&amp; q==1);
0384     scalarsinB = (r==1 &amp;&amp; s==1);
0385     singleA = all(extsizeA==1);
0386     singleB = all(extsizeB==1);
0387     <span class="keyword">if</span> q~=r &amp;&amp; ~scalarsinA &amp;&amp; ~scalarsinB &amp;&amp; ~declared_outer
0388        error(<span class="string">'MULTIPROD:InnerDimensionsMismatch'</span>, <span class="keyword">...</span>
0389              <span class="string">'Inner matrix dimensions must agree.'</span>);
0390     <span class="keyword">end</span>
0391 
0392 <span class="comment">% STEP 1/3 - DIMENSION SHIFTING (FIRST STEP OF AX)</span>
0393 <span class="comment">%   Pipeline 1 (using TIMES) never needs left, and may need right shifting.</span>
0394 <span class="comment">%   Pipeline 2 (using MTIMES) may need left shifting of A and right of B.</span>
0395 
0396     shiftA = 0;
0397     shiftB = 0;
0398     diffBA = idB1 - idA1;    
0399     <span class="keyword">if</span> scalarA <span class="comment">% Do nothing</span>
0400     <span class="keyword">elseif</span> singleA &amp;&amp; ~scalarsinB, shiftA = -idA1 + 1; <span class="comment">%  Left shifting A</span>
0401     <span class="keyword">elseif</span> idB1 &gt; idA1,            shiftA = diffBA;    <span class="comment">% Right shifting A</span>
0402     <span class="keyword">end</span>    
0403     <span class="keyword">if</span> scalarB <span class="comment">% Do nothing</span>
0404     <span class="keyword">elseif</span> singleB &amp;&amp; ~scalarsinA, shiftB = -idB1 + 1; <span class="comment">%  Left shifting B</span>
0405     <span class="keyword">elseif</span> idA1 &gt; idB1,            shiftB = -diffBA;   <span class="comment">% Right shifting B</span>
0406     <span class="keyword">end</span>
0407 
0408 <span class="comment">% STEP 2/3 - SELECTION OF PROPER ENGINE AND BLOCK SIZE ADJUSTMENTS</span>
0409 
0410     addA  = 0; addB  = 0;
0411     delA  = 0; delB  = 0;
0412     swapA = 0; swapB = 0;
0413     idC1 = max(idA1, idB1);
0414     idC2 = idC1 + 1;
0415     checktimes = false;
0416 
0417     <span class="keyword">if</span> (singleA||singleB) &amp;&amp;~scalarsinA &amp;&amp;~scalarsinB <span class="comment">% Engine using MTIMES</span>
0418 
0419         <span class="keyword">if</span> singleA &amp;&amp; singleB 
0420             mtimesOK = true;
0421             shiftC=idC1-1; <span class="comment">% Right shifting C</span>
0422             idC1=1; idC2=2;
0423         <span class="keyword">elseif</span> singleA
0424             squashOK = 2;
0425             idB = [idB1, idB1+1] + shiftB;
0426         <span class="keyword">else</span> <span class="comment">% singleB</span>
0427             squashOK = 1;
0428             idA = [idA1, idA1+1] + shiftA;
0429         <span class="keyword">end</span>
0430 
0431         <span class="keyword">if</span> NidA==2 &amp;&amp; NidB==2 <span class="comment">% 1) 2-D BLOCKS BY 2-D BLOCKS</span>
0432             <span class="comment">% OK</span>
0433         <span class="keyword">elseif</span> NidA==2        <span class="comment">% 2) 2-D BLOCKS BY 1-D BLOCKS</span>
0434             addB=idB1+1; delC=idC2;
0435         <span class="keyword">elseif</span> NidB==2        <span class="comment">% 3) 1-D BLOCKS BY 2-D BLOCKS</span>
0436             addA=idA1; delC=idC1;
0437         <span class="keyword">else</span>                  <span class="comment">% 4) 1-D BLOCKS BY 1-D BLOCKS</span>
0438             <span class="keyword">if</span> declared_outer
0439                 addA=idA1+1; addB=idB1;
0440             <span class="keyword">else</span>
0441                 addA=idA1; addB=idB1+1; delC=idC2;
0442             <span class="keyword">end</span>
0443         <span class="keyword">end</span>    
0444 
0445     <span class="keyword">else</span> <span class="comment">% Engine using TIMES (also used if SCALARA || SCALARB)</span>
0446         
0447         sxtimesOK = true;
0448 
0449         <span class="keyword">if</span> NidA==2 &amp;&amp; NidB==2 <span class="comment">% 1) 2-D BLOCKS BY 2-D BLOCKS</span>
0450 
0451             <span class="keyword">if</span> scalarA || scalarB
0452                 timesOK=true;                
0453             <span class="keyword">elseif</span> scalarsinA &amp;&amp; scalarsinB <span class="comment">% scal-by-scal</span>
0454                 checktimes=true;
0455             <span class="keyword">elseif</span> scalarsinA || scalarsinB || <span class="keyword">...</span><span class="comment"> % scal-by-mat</span>
0456                 (q==1 &amp;&amp; r==1)  <span class="comment">% vec-by-vec (&quot;outer&quot;)</span>
0457             <span class="keyword">elseif</span> p==1 &amp;&amp; s==1 <span class="comment">% vec-by-vec (&quot;inner&quot;)</span>
0458                 swapA=idA1; sumOK=idC1; checktimes=true;
0459             <span class="keyword">elseif</span> s==1 <span class="comment">% mat-by-vec</span>
0460                 swapB=idB1; sumOK=idC2;
0461             <span class="keyword">elseif</span> p==1 <span class="comment">% vec-by-mat</span>
0462                 swapA=idA1; sumOK=idC1;
0463             <span class="keyword">else</span> <span class="comment">% mat-by-mat</span>
0464                 addA=idA2+1; addB=idB1; sumOK=idC2; delC=idC2;
0465             <span class="keyword">end</span>
0466 
0467         <span class="keyword">elseif</span> NidA==2 <span class="comment">% 2) 2-D BLOCKS BY 1-D BLOCKS</span>
0468 
0469             <span class="keyword">if</span> scalarA || scalarB
0470                 timesOK=true;                
0471             <span class="keyword">elseif</span> scalarsinA &amp;&amp; scalarsinB <span class="comment">% scal-by-scal</span>
0472                 addB=idB1; checktimes=true;
0473             <span class="keyword">elseif</span> scalarsinA <span class="comment">% scal-by-vec</span>
0474                 delA=idA1;
0475             <span class="keyword">elseif</span> scalarsinB <span class="comment">% mat-by-scal</span>
0476                 addB=idB1;
0477             <span class="keyword">elseif</span> p==1 <span class="comment">% vec-by-vec (&quot;inner&quot;)</span>
0478                 delA=idA1; sumOK=idC1; checktimes=true;
0479             <span class="keyword">else</span> <span class="comment">% mat-by-vec</span>
0480                 addB=idB1; sumOK=idC2; delC=idC2;
0481             <span class="keyword">end</span>
0482 
0483         <span class="keyword">elseif</span> NidB==2 <span class="comment">% 3) 1-D BLOCKS BY 2-D BLOCKS</span>
0484 
0485             <span class="keyword">if</span> scalarA || scalarB
0486                 timesOK=true;                
0487             <span class="keyword">elseif</span> scalarsinA &amp;&amp; scalarsinB <span class="comment">% scal-by-scal</span>
0488                 addA=idA1+1; checktimes=true;
0489             <span class="keyword">elseif</span> scalarsinB <span class="comment">% vec-by-scal</span>
0490                 delB=idB2;
0491             <span class="keyword">elseif</span> scalarsinA <span class="comment">% scal-by-mat</span>
0492                 addA=idA1+1;
0493             <span class="keyword">elseif</span> s==1 <span class="comment">% vec-by-vec (&quot;inner&quot;)</span>
0494                 delB=idB2; sumOK=idC1; checktimes=true;
0495             <span class="keyword">else</span> <span class="comment">% vec-by-mat</span>
0496                 addA=idA1+1; sumOK=idC1; delC=idC1;
0497             <span class="keyword">end</span>
0498 
0499         <span class="keyword">else</span> <span class="comment">% 4) 1-D BLOCKS BY 1-D BLOCKS</span>
0500 
0501             <span class="keyword">if</span> scalarA || scalarB
0502                 timesOK=true;                
0503             <span class="keyword">elseif</span> declared_outer <span class="comment">% vec-by-vec (&quot;outer&quot;)</span>
0504                 addA=idA1+1; addB=idB1;
0505             <span class="keyword">elseif</span> scalarsinA &amp;&amp; scalarsinB <span class="comment">% scal-by-scal</span>
0506                 checktimes=true;
0507             <span class="keyword">elseif</span> scalarsinA || scalarsinB <span class="comment">% vec-by-scal</span>
0508             <span class="keyword">else</span> <span class="comment">% vec-by-vec</span>
0509                 sumOK=idC1; checktimes=true;
0510             <span class="keyword">end</span>
0511         <span class="keyword">end</span>
0512     <span class="keyword">end</span>
0513 
0514 <span class="comment">% STEP 3/3 - Adjusting the size of A and B. The size of C is adjusted</span>
0515 <span class="comment">%            later, because it is not known yet.</span>
0516 
0517     [sizeA, sizeisnew(1)] = <a href="#_sub3" class="code" title="subfunction [sizeA, sizeisnew] = adjustsize(sizeA0, shiftA, addA, delA, swapA)">adjustsize</a>(sizeA0, shiftA, addA, delA, swapA);
0518     [sizeB, sizeisnew(2)] = <a href="#_sub3" class="code" title="subfunction [sizeA, sizeisnew] = adjustsize(sizeA0, shiftA, addA, delA, swapA)">adjustsize</a>(sizeB0, shiftB, addB, delB, swapB);
0519 
0520     <span class="keyword">if</span> checktimes <span class="comment">% Faster than calling BBXFUN</span>
0521         diff = length(sizeB) - length(sizeA);
0522         <span class="keyword">if</span> isequal([sizeA ones(1,diff)], [sizeB ones(1,-diff)])
0523             timesOK = true;
0524         <span class="keyword">end</span>
0525     <span class="keyword">end</span>
0526 
0527 
0528 <a name="_sub3" href="#_subfunctions" class="code">function [sizeA, sizeisnew] = adjustsize(sizeA0, shiftA, addA, delA, swapA)</a>
0529 <span class="comment">% ADJUSTSIZE  Adjusting size of a block array.</span>
0530 
0531     <span class="comment">% Dimension shifting (by adding or deleting trailing singleton dim.)</span>
0532     <span class="keyword">if</span>     shiftA&gt;0, [sizeA,newA1] = <a href="#_sub4" class="code" title="subfunction [newsize, flag] = addsing(size0, dim, ns)">addsing</a>(sizeA0, 1, shiftA);
0533     <span class="keyword">elseif</span> shiftA&lt;0, [sizeA,newA1] = <a href="#_sub5" class="code" title="subfunction [newsize, flag] = delsing(size0, dim, ns)">delsing</a>(sizeA0, 1,-shiftA); 
0534     <span class="keyword">else</span>   sizeA = sizeA0;  newA1  = false;
0535     <span class="keyword">end</span>
0536     <span class="comment">% Modifying block size (by adding, deleting, or moving singleton dim.)</span>
0537     <span class="keyword">if</span>      addA, [sizeA,newA2] = <a href="#_sub4" class="code" title="subfunction [newsize, flag] = addsing(size0, dim, ns)">addsing</a>(sizeA, addA+shiftA, 1); <span class="comment">% 1D--&gt;2D</span>
0538     <span class="keyword">elseif</span>  delA, [sizeA,newA2] = <a href="#_sub5" class="code" title="subfunction [newsize, flag] = delsing(size0, dim, ns)">delsing</a>(sizeA, delA+shiftA, 1); <span class="comment">% 2D--&gt;1D</span>
0539     <span class="keyword">elseif</span> swapA, [sizeA,newA2] = <a href="#_sub6" class="code" title="subfunction [newsize, flag] = swapdim(size0, dim)">swapdim</a>(sizeA,swapA+shiftA); <span class="comment">% ID Swapping</span>
0540     <span class="keyword">else</span>                 newA2  = false;
0541     <span class="keyword">end</span>
0542     sizeisnew = newA1 || newA2;
0543 
0544 
0545 <a name="_sub4" href="#_subfunctions" class="code">function [newsize, flag] = addsing(size0, dim, ns)</a>
0546 <span class="comment">%ADDSING   Adding NS singleton dimensions to the size of an array.</span>
0547 <span class="comment">%   Warning: NS is assumed to be a positive integer.</span>
0548 <span class="comment">%   Example: If the size of A is ..... SIZE0 = [5 9 3]</span>
0549 <span class="comment">%            NEWSIZE = ADDSING(SIZE0, 3, 2) is [5 9 1 1 3]</span>
0550 
0551     <span class="keyword">if</span> dim &gt; length(size0)
0552         newsize = size0;
0553         flag = false;
0554     <span class="keyword">else</span> 
0555         newsize = [size0(1:dim-1), ones(1,ns), size0(dim:end)];
0556         flag = true;
0557     <span class="keyword">end</span>
0558 
0559 
0560 <a name="_sub5" href="#_subfunctions" class="code">function [newsize, flag] = delsing(size0, dim, ns)</a>
0561 <span class="comment">%DELSING   Removing NS singleton dimensions from the size of an array.</span>
0562 <span class="comment">%   Warning: Trailing singletons are not removed</span>
0563 <span class="comment">%   Example: If the size of A is SIZE0 = [1 1 1 5 9 3]</span>
0564 <span class="comment">%            NEWSIZE = DELSING(SIZE, 1, 3) is  [5 9 3]</span>
0565 
0566     <span class="keyword">if</span> dim &gt; length(size0)-ns <span class="comment">% Trailing singletons are not removed</span>
0567         newsize = size0;
0568         flag = false;
0569     <span class="keyword">else</span> <span class="comment">% Trailing singl. added, so NEWSIZE is guaranteed to be 2D or more</span>
0570         newsize = size0([1:dim-1, dim+ns:<span class="keyword">end</span>, dim]);
0571         flag = true;
0572     <span class="keyword">end</span>
0573 
0574 
0575 <a name="_sub6" href="#_subfunctions" class="code">function [newsize, flag] = swapdim(size0, dim)</a>
0576 <span class="comment">%SWAPDIM   Swapping two adjacent dimensions of an array (DIM and DIM+1).</span>
0577 <span class="comment">%   Used only when both A and B are multi-block arrays with 2-D blocks.</span>
0578 <span class="comment">%   Example: If the size of A is .......... 5x(6x3)</span>
0579 <span class="comment">%            NEWSIZE = SWAPIDS(SIZE0, 2) is 5x(3x6)</span>
0580 
0581     newsize = [size0 1]; <span class="comment">% Guarantees that dimension DIM+1 exists.</span>
0582     newsize = newsize([1:dim-1, dim+1, dim, dim+2:end]);
0583     flag = true;</pre></div>
<hr><address>Generated on Fri 08-Sep-2017 12:43:19 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>