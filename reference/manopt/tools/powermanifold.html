<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of powermanifold</title>
  <meta name="keywords" content="powermanifold">
  <meta name="description" content="Returns a structure describing a power manifold M^n = M x M x ... x M.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="index.html">tools</a> &gt; powermanifold.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\tools&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>powermanifold
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Returns a structure describing a power manifold M^n = M x M x ... x M.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function Mn = powermanifold(M, n) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Returns a structure describing a power manifold M^n = M x M x ... x M.

 function Mn = powermanifold(M, n)

 Input: a manifold structure M and an integer n &gt;= 1.
 
 Output: a manifold structure Mn representing M x ... x M (n copies of M)
 with the metric of M extended element-wise. Points and vectors are stored
 as cells of size nx1.

 This code is for prototyping uses. The structures returned are often
 inefficient representations of power manifolds owing to their use of
 for-loops, but they should allow to rapidly try out an idea.

 Example (an inefficient representation of the oblique manifold (3, 10)):
 Mn = powermanifold(spherefactory(3), 10)
 disp(Mn.name());
 x = Mn.rand()

 See also: <a href="productmanifold.html" class="code" title="function M = productmanifold(elements)">productmanifold</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>	Computes the MD5 hash of input data.</li><li><a href="lincomb.html" class="code" title="function vec = lincomb(M, x, vecs, coeffs)">lincomb</a>	Computes a linear combination of tangent vectors in the Manopt framework.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../manopt/autodiff/basic_examples_AD/complextest_AD2.html" class="code" title="function complextest_AD2()">complextest_AD2</a>	Test AD for a complex optimization problem on a power manifold (cell)</li><li><a href="../../manopt/autodiff/basic_examples_AD/complextest_AD3.html" class="code" title="function complextest_AD3()">complextest_AD3</a>	Test AD for a complex optimization problem on a manifold which is stored</li><li><a href="../../manopt/autodiff/basic_examples_AD/realtest_AD2.html" class="code" title="function realtest_AD2()">realtest_AD2</a>	Test AD for a real optimization problem on a power manifold (cell)</li><li><a href="../../manopt/autodiff/basic_examples_AD/realtest_AD3.html" class="code" title="function realtest_AD3()">realtest_AD3</a>	Test AD for a real optimization problem on a manifold which is stored in</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function val = inner(x, u, v)</a></li><li><a href="#_sub2" class="code">function d = dist(x, y)</a></li><li><a href="#_sub3" class="code">function d = typicaldist()</a></li><li><a href="#_sub4" class="code">function u = proj(x, u)</a></li><li><a href="#_sub5" class="code">function u = tangent(x, u)</a></li><li><a href="#_sub6" class="code">function u = tangent2ambient(x, u)</a></li><li><a href="#_sub7" class="code">function g = egrad2rgrad(x, g)</a></li><li><a href="#_sub8" class="code">function h = ehess2rhess(x, eg, eh, h)</a></li><li><a href="#_sub9" class="code">function x = expo(x, u, t)</a></li><li><a href="#_sub10" class="code">function x = retr(x, u, t)</a></li><li><a href="#_sub11" class="code">function u = loga(x, y)</a></li><li><a href="#_sub12" class="code">function str = hash(x)</a></li><li><a href="#_sub13" class="code">function x = lincomb(x, a1, u1, a2, u2)</a></li><li><a href="#_sub14" class="code">function x = rand()</a></li><li><a href="#_sub15" class="code">function u = randvec(x)</a></li><li><a href="#_sub16" class="code">function u = zerovec(x)</a></li><li><a href="#_sub17" class="code">function u = transp(x1, x2, u)</a></li><li><a href="#_sub18" class="code">function y = pairmean(x1, x2)</a></li><li><a href="#_sub19" class="code">function u_vec = vec(x, u_mat, len_vec, M, n)</a></li><li><a href="#_sub20" class="code">function u_mat = mat(x, u_vec, len_vec, M, n)</a></li><li><a href="#_sub21" class="code">function I = lie_identity()</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function Mn = powermanifold(M, n)</a>
0002 <span class="comment">% Returns a structure describing a power manifold M^n = M x M x ... x M.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function Mn = powermanifold(M, n)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Input: a manifold structure M and an integer n &gt;= 1.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Output: a manifold structure Mn representing M x ... x M (n copies of M)</span>
0009 <span class="comment">% with the metric of M extended element-wise. Points and vectors are stored</span>
0010 <span class="comment">% as cells of size nx1.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% This code is for prototyping uses. The structures returned are often</span>
0013 <span class="comment">% inefficient representations of power manifolds owing to their use of</span>
0014 <span class="comment">% for-loops, but they should allow to rapidly try out an idea.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% Example (an inefficient representation of the oblique manifold (3, 10)):</span>
0017 <span class="comment">% Mn = powermanifold(spherefactory(3), 10)</span>
0018 <span class="comment">% disp(Mn.name());</span>
0019 <span class="comment">% x = Mn.rand()</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% See also: productmanifold</span>
0022 
0023 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0024 <span class="comment">% Original author: Nicolas Boumal, Dec. 30, 2012.</span>
0025 <span class="comment">% Contributors:</span>
0026 <span class="comment">% Change log:</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%   July  4, 2013 (NB):</span>
0029 <span class="comment">%       Added support for vec, mat, tangent.</span>
0030 <span class="comment">%       Added support for egrad2rgrad and ehess2rhess.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%   Feb. 10, 2020 (NB):</span>
0033 <span class="comment">%       Added warnings about calling egrad2rgrad and ehess2rhess without</span>
0034 <span class="comment">%       storedb and key, even if the base manifold allows them.</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%   Jan. 4, 2021 (NB):</span>
0037 <span class="comment">%       Changes for compatibility with Octave 6.1.0: see len_vec.</span>
0038 
0039     
0040     assert(n &gt;= 1, <span class="string">'n must be an integer larger than or equal to 1.'</span>);
0041     
0042     Mn.name = @() sprintf(<span class="string">'[%s]^%d'</span>, M.name(), n);
0043     
0044     Mn.dim = @() n*M.dim();
0045     
0046     Mn.inner = @<a href="#_sub1" class="code" title="subfunction val = inner(x, u, v)">inner</a>;
0047     <a name="_sub1" href="#_subfunctions" class="code">function val = inner(x, u, v)</a>
0048         val = 0;
0049         <span class="keyword">for</span> i = 1 : n
0050             val = val + M.inner(x{i}, u{i}, v{i});
0051         <span class="keyword">end</span>
0052     <span class="keyword">end</span>
0053 
0054     Mn.norm = @(x, d) sqrt(Mn.inner(x, d, d));
0055 
0056     Mn.dist = @<a href="#_sub2" class="code" title="subfunction d = dist(x, y)">dist</a>;
0057     <a name="_sub2" href="#_subfunctions" class="code">function d = dist(x, y)</a>
0058         sqd = 0;
0059         <span class="keyword">for</span> i = 1 : n
0060             sqd = sqd + M.dist(x{i}, y{i})^2;
0061         <span class="keyword">end</span>
0062         d = sqrt(sqd);
0063     <span class="keyword">end</span>
0064 
0065     Mn.typicaldist = @<a href="#_sub3" class="code" title="subfunction d = typicaldist()">typicaldist</a>;
0066     <a name="_sub3" href="#_subfunctions" class="code">function d = typicaldist()</a>
0067         sqd = 0;
0068         <span class="keyword">for</span> i = 1 : n
0069             sqd = sqd + M.typicaldist()^2;
0070         <span class="keyword">end</span>
0071         d = sqrt(sqd);
0072     <span class="keyword">end</span>
0073     
0074     Mn.proj = @<a href="#_sub4" class="code" title="subfunction u = proj(x, u)">proj</a>;
0075     <a name="_sub4" href="#_subfunctions" class="code">function u = proj(x, u)</a>
0076         <span class="keyword">for</span> i = 1 : n
0077             u{i} = M.proj(x{i}, u{i});
0078         <span class="keyword">end</span>
0079     <span class="keyword">end</span>
0080     
0081     Mn.tangent = @<a href="#_sub5" class="code" title="subfunction u = tangent(x, u)">tangent</a>;
0082     <a name="_sub5" href="#_subfunctions" class="code">function u = tangent(x, u)</a>
0083         <span class="keyword">for</span> i = 1 : n
0084             u{i} = M.tangent(x{i}, u{i});
0085         <span class="keyword">end</span>
0086     <span class="keyword">end</span>
0087     
0088     <span class="keyword">if</span> isfield(M, <span class="string">'tangent2ambient_is_identity'</span>)
0089         Mn.tangent2ambient_is_identity = M.tangent2ambient_is_identity;
0090     <span class="keyword">else</span>
0091         Mn.tangent2ambient_is_identity = true;
0092     <span class="keyword">end</span>
0093     
0094     <span class="keyword">if</span> isfield(M, <span class="string">'tangent2ambient'</span>)
0095         Mn.tangent2ambient = @<a href="#_sub6" class="code" title="subfunction u = tangent2ambient(x, u)">tangent2ambient</a>;
0096     <span class="keyword">else</span>
0097         Mn.tangent2ambient = @(x, u) u;
0098     <span class="keyword">end</span>
0099     <a name="_sub6" href="#_subfunctions" class="code">function u = tangent2ambient(x, u)</a>
0100         <span class="keyword">for</span> i = 1 : n
0101             u{i} = M.tangent2ambient(x{i}, u{i});
0102         <span class="keyword">end</span>
0103     <span class="keyword">end</span>
0104     
0105     <span class="keyword">if</span> nargin(M.egrad2rgrad) &gt; 2
0106         warning(<span class="string">'manopt:powermanifold:egrad2rgrad'</span>, <span class="keyword">...</span>
0107                [<span class="string">'Power manifolds call M.egrad2rgrad with only two '</span>, <span class="keyword">...</span>
0108                 <span class="string">'inputs:\nstoredb and key won''t be available.'</span>]);
0109     <span class="keyword">end</span>
0110     Mn.egrad2rgrad = @<a href="#_sub7" class="code" title="subfunction g = egrad2rgrad(x, g)">egrad2rgrad</a>;
0111     <a name="_sub7" href="#_subfunctions" class="code">function g = egrad2rgrad(x, g)</a>
0112         <span class="keyword">for</span> i = 1 : n
0113             g{i} = M.egrad2rgrad(x{i}, g{i});
0114         <span class="keyword">end</span>
0115     <span class="keyword">end</span>
0116     
0117     <span class="keyword">if</span> nargin(M.ehess2rhess) &gt; 4
0118         warning(<span class="string">'manopt:powermanifold:ehess2rhess'</span>, <span class="keyword">...</span>
0119                [<span class="string">'Power manifolds call M.ehess2rhess with only four '</span>, <span class="keyword">...</span>
0120                 <span class="string">'inputs:\nstoredb and key won''t be available.'</span>]);
0121     <span class="keyword">end</span>
0122     Mn.ehess2rhess = @<a href="#_sub8" class="code" title="subfunction h = ehess2rhess(x, eg, eh, h)">ehess2rhess</a>;
0123     <a name="_sub8" href="#_subfunctions" class="code">function h = ehess2rhess(x, eg, eh, h)</a>
0124         <span class="keyword">for</span> i = 1 : n
0125             h{i} = M.ehess2rhess(x{i}, eg{i}, eh{i}, h{i});
0126         <span class="keyword">end</span>
0127     <span class="keyword">end</span>
0128     
0129     Mn.exp = @<a href="#_sub9" class="code" title="subfunction x = expo(x, u, t)">expo</a>;
0130     <a name="_sub9" href="#_subfunctions" class="code">function x = expo(x, u, t)</a>
0131         <span class="keyword">if</span> nargin &lt; 3
0132             t = 1.0;
0133         <span class="keyword">end</span>
0134         <span class="keyword">for</span> i = 1 : n
0135             x{i} = M.exp(x{i}, u{i}, t);
0136         <span class="keyword">end</span>
0137     <span class="keyword">end</span>
0138     
0139     Mn.retr = @<a href="#_sub10" class="code" title="subfunction x = retr(x, u, t)">retr</a>;
0140     <a name="_sub10" href="#_subfunctions" class="code">function x = retr(x, u, t)</a>
0141         <span class="keyword">if</span> nargin &lt; 3
0142             t = 1.0;
0143         <span class="keyword">end</span>
0144         <span class="keyword">for</span> i = 1 : n
0145             x{i} = M.retr(x{i}, u{i}, t);
0146         <span class="keyword">end</span>
0147     <span class="keyword">end</span>
0148     
0149     <span class="keyword">if</span> isfield(M, <span class="string">'log'</span>)
0150         Mn.log = @<a href="#_sub11" class="code" title="subfunction u = loga(x, y)">loga</a>;
0151     <span class="keyword">end</span>
0152     <a name="_sub11" href="#_subfunctions" class="code">function u = loga(x, y)</a>
0153         u = cell(n, 1);
0154         <span class="keyword">for</span> i = 1 : n
0155             u{i} = M.log(x{i}, y{i});
0156         <span class="keyword">end</span>
0157     <span class="keyword">end</span>
0158     
0159     Mn.hash = @<a href="#_sub12" class="code" title="subfunction str = hash(x)">hash</a>;
0160     <a name="_sub12" href="#_subfunctions" class="code">function str = hash(x)</a>
0161         str = <span class="string">''</span>;
0162         <span class="keyword">for</span> i = 1 : n
0163             str = [str M.hash(x{i})]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0164         <span class="keyword">end</span>
0165         str = [<span class="string">'z'</span> <a href="hashmd5.html" class="code" title="function h = hashmd5(inp)">hashmd5</a>(str)];
0166     <span class="keyword">end</span>
0167 
0168     Mn.lincomb = @<a href="lincomb.html" class="code" title="function vec = lincomb(M, x, vecs, coeffs)">lincomb</a>;
0169     <a name="_sub13" href="#_subfunctions" class="code">function x = lincomb(x, a1, u1, a2, u2)</a>
0170         <span class="keyword">if</span> nargin == 3
0171             <span class="keyword">for</span> i = 1 : n
0172                 x{i} = M.lincomb(x{i}, a1, u1{i});
0173             <span class="keyword">end</span>
0174         <span class="keyword">elseif</span> nargin == 5
0175             <span class="keyword">for</span> i = 1 : n
0176                 x{i} = M.lincomb(x{i}, a1, u1{i}, a2, u2{i});
0177             <span class="keyword">end</span>
0178         <span class="keyword">else</span>
0179             error(<span class="string">'Bad usage of powermanifold.lincomb'</span>);
0180         <span class="keyword">end</span>
0181     <span class="keyword">end</span>
0182 
0183     Mn.rand = @<a href="#_sub14" class="code" title="subfunction x = rand()">rand</a>;
0184     <a name="_sub14" href="#_subfunctions" class="code">function x = rand()</a>
0185         x = cell(n, 1);
0186         <span class="keyword">for</span> i = 1 : n
0187             x{i} = M.rand();
0188         <span class="keyword">end</span>
0189     <span class="keyword">end</span>
0190 
0191     Mn.randvec = @<a href="#_sub15" class="code" title="subfunction u = randvec(x)">randvec</a>;
0192     <a name="_sub15" href="#_subfunctions" class="code">function u = randvec(x)</a>
0193         u = cell(n, 1);
0194         <span class="keyword">for</span> i = 1 : n
0195             u{i} = M.randvec(x{i});
0196         <span class="keyword">end</span>
0197         u = Mn.lincomb(x, 1/sqrt(n), u);
0198     <span class="keyword">end</span>
0199 
0200     Mn.zerovec = @<a href="#_sub16" class="code" title="subfunction u = zerovec(x)">zerovec</a>;
0201     <a name="_sub16" href="#_subfunctions" class="code">function u = zerovec(x)</a>
0202         u = cell(n, 1);
0203         <span class="keyword">for</span> i = 1 : n
0204             u{i} = M.zerovec(x{i});
0205         <span class="keyword">end</span>
0206     <span class="keyword">end</span>
0207 
0208     <span class="keyword">if</span> isfield(M, <span class="string">'transp'</span>)
0209         Mn.transp = @<a href="#_sub17" class="code" title="subfunction u = transp(x1, x2, u)">transp</a>;
0210     <span class="keyword">end</span>
0211     <a name="_sub17" href="#_subfunctions" class="code">function u = transp(x1, x2, u)</a>
0212         <span class="keyword">for</span> i = 1 : n
0213             u{i} = M.transp(x1{i}, x2{i}, u{i});
0214         <span class="keyword">end</span>
0215     <span class="keyword">end</span>
0216 
0217     <span class="keyword">if</span> isfield(M, <span class="string">'pairmean'</span>)
0218         Mn.pairmean = @<a href="#_sub18" class="code" title="subfunction y = pairmean(x1, x2)">pairmean</a>;
0219     <span class="keyword">end</span>
0220     <a name="_sub18" href="#_subfunctions" class="code">function y = pairmean(x1, x2)</a>
0221         y = cell(n, 1);
0222         <span class="keyword">for</span> i = 1 : n
0223             y{i} = M.pairmean(x1{i}, x2{i});
0224         <span class="keyword">end</span>
0225     <span class="keyword">end</span>
0226 
0227     <span class="comment">% Compute the length of a vectorized tangent vector of M at x, assuming</span>
0228     <span class="comment">% this length is independent of the point x (that should be fine).</span>
0229     <span class="keyword">if</span> isfield(M, <span class="string">'vec'</span>)
0230         rand_x = M.rand();
0231         zero_u = M.zerovec(rand_x);
0232         len_vec = length(M.vec(rand_x, zero_u));
0233         
0234         Mn.vec = @(x, u_mat) <a href="#_sub19" class="code" title="subfunction u_vec = vec(x, u_mat, len_vec, M, n)">vec</a>(x, u_mat, len_vec, M, n);
0235         
0236         <span class="keyword">if</span> isfield(M, <span class="string">'mat'</span>)
0237             Mn.mat = @(x, u_vec) <a href="#_sub20" class="code" title="subfunction u_mat = mat(x, u_vec, len_vec, M, n)">mat</a>(x, u_vec, len_vec, M, n);
0238         <span class="keyword">end</span>
0239         
0240     <span class="keyword">end</span>
0241     
0242     <a name="_sub19" href="#_subfunctions" class="code">function u_vec = vec(x, u_mat, len_vec, M, n)</a>
0243         u_vec = zeros(len_vec, n);
0244         <span class="keyword">for</span> i = 1 : n
0245             u_vec(:, i) = M.vec(x{i}, u_mat{i});
0246         <span class="keyword">end</span>
0247         u_vec = u_vec(:);
0248     <span class="keyword">end</span>
0249 
0250     <a name="_sub20" href="#_subfunctions" class="code">function u_mat = mat(x, u_vec, len_vec, M, n)</a>
0251         u_mat = cell(n, 1);
0252         u_vec = reshape(u_vec, len_vec, n);
0253         <span class="keyword">for</span> i = 1 : n
0254             u_mat{i} = M.mat(x{i}, u_vec(:, i));
0255         <span class="keyword">end</span>
0256     <span class="keyword">end</span>
0257 
0258     <span class="keyword">if</span> isfield(M, <span class="string">'vecmatareisometries'</span>)
0259         Mn.vecmatareisometries = M.vecmatareisometries;
0260     <span class="keyword">else</span>
0261         Mn.vecmatareisometries = @() false;
0262     <span class="keyword">end</span>
0263 
0264     <span class="keyword">if</span> isfield(M, <span class="string">'lie_identity'</span>)
0265         Mn.lie_identity = @<a href="#_sub21" class="code" title="subfunction I = lie_identity()">lie_identity</a>;
0266     <span class="keyword">end</span>
0267     <a name="_sub21" href="#_subfunctions" class="code">function I = lie_identity()</a>
0268         I_M = M.lie_identity();
0269         I = cell(n, 1);
0270         <span class="keyword">for</span> k = 1 : n
0271             I{k} = I_M;
0272         <span class="keyword">end</span>
0273     <span class="keyword">end</span>
0274 
0275 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 30-Sep-2022 13:18:25 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>