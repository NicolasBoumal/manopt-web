<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of hessianextreme</title>
  <meta name="keywords" content="hessianextreme">
  <meta name="description" content="Compute an extreme eigenvector / eigenvalue of the Hessian of a problem.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="index.html">tools</a> &gt; hessianextreme.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\tools&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>hessianextreme
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Compute an extreme eigenvector / eigenvalue of the Hessian of a problem.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [y, lambda] = hessianextreme(problem, x, side, y0, options, storedb, key) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute an extreme eigenvector / eigenvalue of the Hessian of a problem.

 [u, lambda] = hessianextreme(problem, x)
 [u, lambda] = hessianextreme(problem, x, side)
 [u, lambda] = hessianextreme(problem, x, side, u0)
 [u, lambda] = hessianextreme(problem, x, side, u0, options)
 [u, lambda] = hessianextreme(problem, x, side, u0, options, storedb)
 [u, lambda] = hessianextreme(problem, x, side, u0, options, storedb, key)
 
 (For side, u0 and options, pass [] to omit any.)

 Given a Manopt problem structure and a point x on the manifold problem.M,
 this function computes a tangent vector u at x of unit norm such that the
 Hessian quadratic form is minimized or maximized:

    minimize or maximize &lt;u, Hess f(x)[u]&gt; such that &lt;u, u&gt; = 1,

 where &lt;.,.&gt; is the Riemannian metric on the tangent space at x. Choose
 between minimizing and maximizing by setting side = 'min' or 'max', with
 'min' being the default. The value attained is returned as lambda, and
 is the minimal or maximal eigenvalue of the Hessian (actually, the last
 value attained when the solver stopped). This is a real number since the
 Hessian is a symmetric operator.

 If u0 is specified, it should be a unit-norm tangent vector at x. It is
 then used as initial guess to solve the above problem. Pass [] to omit.

 The options structure, if provided, will be passed along to manoptsolve.
 As such, you may choose which solver to use to solve the above
 optimization problem by setting options.solver. See manoptsolve's help.
 The other options will be passed along to the chosen solver too.
 Pass [] to omit.

 Often times, it is only necessary to compute a vector u such that the
 quadratic form is negative, if that is at all possible. To do so, set the
 following stopping criterion: options.tolcost = -1e-10; (for example)
 and side = 'min'. The solver will return as soon as the quadratic cost
 defined above drops below the set value (or sooner if another stopping
 criterion triggers first.)

 storedb is a StoreDB object, key is the StoreDB key to point x.

 See also: <a href="hessianspectrum.html" class="code" title="function lambdas = hessianspectrum(problem, x, usepreconstr, storedb, key)">hessianspectrum</a> <a href="manoptsolve.html" class="code" title="function [x, cost, info, options] = manoptsolve(problem, x0, options)">manoptsolve</a> <a href="tangentspherefactory.html" class="code" title="function N = tangentspherefactory(M, x)">tangentspherefactory</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>	Checks whether the gradient can be computed for a problem structure.</li><li><a href="../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>	Computes the cost function and the gradient at x in one call if possible.</li><li><a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>	Computes the Hessian of the cost function at x along d.</li><li><a href="../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>	Merges two options structures with one having precedence over the other.</li><li><a href="../../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>	Riemannian trust-regions solver for optimization on manifolds.</li><li><a href="manoptsolve.html" class="code" title="function [x, cost, info, options] = manoptsolve(problem, x0, options)">manoptsolve</a>	Gateway helper function to call a Manopt solver, chosen in the options.</li><li><a href="tangentspherefactory.html" class="code" title="function N = tangentspherefactory(M, x)">tangentspherefactory</a>	Returns a manifold struct. for the sphere on the tangent space to M at x.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [f, store] = cost(y, store)</a></li><li><a href="#_sub2" class="code">function [g, store] = grad(y, store)</a></li><li><a href="#_sub3" class="code">function [h, store] = hess(y, ydot, store)</a></li><li><a href="#_sub4" class="code">function store = prepare(y, store)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [y, lambda] = hessianextreme(problem, x, side, y0, options, storedb, key)</a>
0002 <span class="comment">% Compute an extreme eigenvector / eigenvalue of the Hessian of a problem.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% [u, lambda] = hessianextreme(problem, x)</span>
0005 <span class="comment">% [u, lambda] = hessianextreme(problem, x, side)</span>
0006 <span class="comment">% [u, lambda] = hessianextreme(problem, x, side, u0)</span>
0007 <span class="comment">% [u, lambda] = hessianextreme(problem, x, side, u0, options)</span>
0008 <span class="comment">% [u, lambda] = hessianextreme(problem, x, side, u0, options, storedb)</span>
0009 <span class="comment">% [u, lambda] = hessianextreme(problem, x, side, u0, options, storedb, key)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% (For side, u0 and options, pass [] to omit any.)</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% Given a Manopt problem structure and a point x on the manifold problem.M,</span>
0014 <span class="comment">% this function computes a tangent vector u at x of unit norm such that the</span>
0015 <span class="comment">% Hessian quadratic form is minimized or maximized:</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%    minimize or maximize &lt;u, Hess f(x)[u]&gt; such that &lt;u, u&gt; = 1,</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% where &lt;.,.&gt; is the Riemannian metric on the tangent space at x. Choose</span>
0020 <span class="comment">% between minimizing and maximizing by setting side = 'min' or 'max', with</span>
0021 <span class="comment">% 'min' being the default. The value attained is returned as lambda, and</span>
0022 <span class="comment">% is the minimal or maximal eigenvalue of the Hessian (actually, the last</span>
0023 <span class="comment">% value attained when the solver stopped). This is a real number since the</span>
0024 <span class="comment">% Hessian is a symmetric operator.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% If u0 is specified, it should be a unit-norm tangent vector at x. It is</span>
0027 <span class="comment">% then used as initial guess to solve the above problem. Pass [] to omit.</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% The options structure, if provided, will be passed along to manoptsolve.</span>
0030 <span class="comment">% As such, you may choose which solver to use to solve the above</span>
0031 <span class="comment">% optimization problem by setting options.solver. See manoptsolve's help.</span>
0032 <span class="comment">% The other options will be passed along to the chosen solver too.</span>
0033 <span class="comment">% Pass [] to omit.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% Often times, it is only necessary to compute a vector u such that the</span>
0036 <span class="comment">% quadratic form is negative, if that is at all possible. To do so, set the</span>
0037 <span class="comment">% following stopping criterion: options.tolcost = -1e-10; (for example)</span>
0038 <span class="comment">% and side = 'min'. The solver will return as soon as the quadratic cost</span>
0039 <span class="comment">% defined above drops below the set value (or sooner if another stopping</span>
0040 <span class="comment">% criterion triggers first.)</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% storedb is a StoreDB object, key is the StoreDB key to point x.</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% See also: hessianspectrum manoptsolve tangentspherefactory</span>
0045 
0046 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0047 <span class="comment">% Original author: Nicolas Boumal, Aug. 13, 2014.</span>
0048 <span class="comment">% Contributors:</span>
0049 <span class="comment">% Change log:</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   April 3, 2015 (NB):</span>
0052 <span class="comment">%       Works with the new StoreDB class system.</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%   May 7, 2015 (NB):</span>
0055 <span class="comment">%       Default solver options: verbosity = 0 and defaults to trustregions.</span>
0056 
0057     
0058     <span class="comment">% By default, minimize</span>
0059     <span class="keyword">if</span> ~exist(<span class="string">'side'</span>, <span class="string">'var'</span>) || isempty(side)
0060         side = <span class="string">'min'</span>;
0061     <span class="keyword">end</span>
0062     
0063     <span class="comment">% If no initial guess was specified, prepare the empty one.</span>
0064     <span class="keyword">if</span> ~exist(<span class="string">'y0'</span>, <span class="string">'var'</span>)
0065         y0 = [];
0066     <span class="keyword">end</span>
0067 
0068     <span class="comment">% Merge default solver options with potential user-specified options.</span>
0069     <span class="comment">% Set local defaults here</span>
0070     localdefaults.verbosity = 0;
0071     localdefaults.solver = @<a href="../../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>;
0072     <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>) || isempty(options)
0073         options = struct();
0074     <span class="keyword">end</span>
0075     options = <a href="../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>(localdefaults, options);
0076 
0077     <span class="comment">% Allow omission of the key, and even of storedb.</span>
0078     <span class="keyword">if</span> ~exist(<span class="string">'key'</span>, <span class="string">'var'</span>)
0079         <span class="keyword">if</span> ~exist(<span class="string">'storedb'</span>, <span class="string">'var'</span>)
0080             storedb = <a href="../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>();
0081         <span class="keyword">end</span>
0082         key = storedb.getNewKey();
0083     <span class="keyword">end</span>
0084     
0085     <span class="comment">% Convert the side into a sign.</span>
0086     <span class="comment">% Since Manopt minimizes, 'min' asks for no sign change.</span>
0087     <span class="keyword">switch</span> lower(side)
0088         <span class="keyword">case</span> <span class="string">'min'</span>
0089             sign = +1;
0090         <span class="keyword">case</span> <span class="string">'max'</span>
0091             sign = -1;
0092         <span class="keyword">otherwise</span>
0093             error(<span class="string">'The side should be either ''min'' or ''max''.'</span>);
0094     <span class="keyword">end</span>
0095 
0096     <span class="comment">% We define a manifold that is actually the unit sphere on the tangent</span>
0097     <span class="comment">% space to problem.M at x. A generalization would be to consider</span>
0098     <span class="comment">% Stiefel or Grassmann on the tangent space, but this would require</span>
0099     <span class="comment">% manipulating collections of tangent vectors, which in full generality</span>
0100     <span class="comment">% may be more complex (from a programming point of view).</span>
0101     <span class="comment">% Points are represented as tangent vectors of unit norm.</span>
0102     <span class="comment">% Tangent vectors are represented as tangent vectors orthogonal to the</span>
0103     <span class="comment">% root point, with respect to the Riemannian metric on the tangent</span>
0104     <span class="comment">% space.</span>
0105     
0106     <span class="comment">% M is the original manifold. x is a point on M.</span>
0107     M = problem.M;
0108     
0109     <span class="comment">% N is the manifold we build. y will be a point on N, thus also a</span>
0110     <span class="comment">% tangent vector to M at x. This is a typical Riemannian submanifold of</span>
0111     <span class="comment">% a Euclidean space, hence it is easy to describe in terms of the tools</span>
0112     <span class="comment">% available for M.</span>
0113     N = <a href="tangentspherefactory.html" class="code" title="function N = tangentspherefactory(M, x)">tangentspherefactory</a>(M, x);
0114     
0115     <span class="comment">% It is usually a good idea to force a gradient computation to make</span>
0116     <span class="comment">% sure precomputable things are precomputed.</span>
0117     <span class="keyword">if</span> <a href="../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>(problem)
0118         [unused1, unused2] = <a href="../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>(problem, x, storedb, key); <span class="comment">%#ok</span>
0119     <span class="keyword">end</span>
0120     
0121     <span class="comment">% This is the star operator of this party.</span>
0122     hessian = @(y) <a href="../../manopt/core/getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>(problem, x, y, storedb, key);
0123     
0124     <span class="comment">% Start a Manopt problem structure for the quadratic optimization</span>
0125     <span class="comment">% problem on the sphere N.</span>
0126     new_problem.M = N;
0127     
0128     <span class="comment">% Define the cost function, its gradient and its Hessian.</span>
0129 
0130     new_problem.cost = @<a href="#_sub1" class="code" title="subfunction [f, store] = cost(y, store)">cost</a>;
0131     <a name="_sub1" href="#_subfunctions" class="code">function [f, store] = cost(y, store)</a>
0132         store = <a href="#_sub4" class="code" title="subfunction store = prepare(y, store)">prepare</a>(y, store);
0133         f = sign*store.f;
0134     <span class="keyword">end</span>
0135 
0136     new_problem.grad = @<a href="#_sub2" class="code" title="subfunction [g, store] = grad(y, store)">grad</a>;
0137     <a name="_sub2" href="#_subfunctions" class="code">function [g, store] = grad(y, store)</a>
0138         store = <a href="#_sub4" class="code" title="subfunction store = prepare(y, store)">prepare</a>(y, store);
0139         g = N.lincomb(y, sign*2, store.Hy, sign*(-2)*store.f, y);
0140     <span class="keyword">end</span>
0141 
0142     new_problem.hess = @<a href="#_sub3" class="code" title="subfunction [h, store] = hess(y, ydot, store)">hess</a>;
0143     <a name="_sub3" href="#_subfunctions" class="code">function [h, store] = hess(y, ydot, store)</a>
0144         store = <a href="#_sub4" class="code" title="subfunction store = prepare(y, store)">prepare</a>(y, store);
0145         Hydot = hessian(ydot);
0146         h = N.lincomb(y, sign*2, Hydot, sign*(-2)*store.f, ydot);
0147         h = N.proj(y, h);
0148     <span class="keyword">end</span>
0149 
0150     <span class="comment">% This helper makes sure we do not duplicate Hessian computations.</span>
0151     <a name="_sub4" href="#_subfunctions" class="code">function store = prepare(y, store)</a>
0152         <span class="keyword">if</span> ~isfield(store, <span class="string">'ready'</span>)
0153             Hy = hessian(y);
0154             store.f = M.inner(x, y, Hy);
0155             store.Hy = Hy;
0156             store.ready = true;
0157         <span class="keyword">end</span>
0158     <span class="keyword">end</span>
0159     
0160     <span class="comment">% Call a Manopt solver to solve the quadratic optimization problem on</span>
0161     <span class="comment">% the abstract sphere N.</span>
0162     [y, lambda] = <a href="manoptsolve.html" class="code" title="function [x, cost, info, options] = manoptsolve(problem, x0, options)">manoptsolve</a>(new_problem, y0, options);
0163     lambda = sign*lambda;
0164 
0165 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 02-Jul-2015 18:56:12 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>