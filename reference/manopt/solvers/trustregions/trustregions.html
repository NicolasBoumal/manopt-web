<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of trustregions</title>
  <meta name="keywords" content="trustregions">
  <meta name="description" content="Riemannian trust-regions solver for optimization on manifolds.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">solvers</a> &gt; <a href="index.html">trustregions</a> &gt; trustregions.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\solvers\trustregions&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>trustregions
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Riemannian trust-regions solver for optimization on manifolds.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [x cost info] = trustregions(problem, x, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Riemannian trust-regions solver for optimization on manifolds.

 function [x cost info] = trustregions(problem)
 function [x cost info] = trustregions(problem, x0)
 function [x cost info] = trustregions(problem, x0, options)
 function [x cost info] = trustregions(problem, [], options)

 This is the Riemannian Trust-Region solver (with tCG inner solve), named
 RTR. This solver will attempt to minimize the cost function described in
 the problem structure. It requires the availability of the cost function
 and of its gradient. It will issue calls for the Hessian. If no Hessian
 nor approximate Hessian is provided, a standard approximation of the
 Hessian based on the gradient will be computed. If a preconditioner for
 the Hessian is provided, it will be used.

 For a description of the algorithm and theorems offering convergence
 guarantees, see the references below. Documentation for this solver is
 available online at:

 http://www.manopt.org/solver_documentation_trustregions.html


 The initial iterate is x0 if it is provided. Otherwise, a random point on
 the manifold is picked. To specify options whilst not specifying an
 initial iterate, give x0 as [] (the empty matrix).

 The two outputs 'x' and 'cost' are the last reached point on the manifold
 and its cost. Notice that x is not necessarily the best reached point,
 because this solver is not forced to be a descent method. In particular,
 very close to convergence, it is sometimes preferable to accept very
 slight increases in the cost value (on the order of the machine epsilon)
 in the process of reaching fine convergence. In practice, this is not a
 limiting factor, as normally one does not need fine enough convergence
 that this becomes an issue.
 
 The output 'info' is a struct-array which contains information about the
 iterations:
   iter (integer)
       The (outer) iteration number, or number of steps considered
       (whether accepted or rejected). The initial guess is 0.
    cost (double)
       The corresponding cost value.
    gradnorm (double)
       The (Riemannian) norm of the gradient.
    numinner (integer)
       The number of inner iterations executed to compute this iterate.
       Inner iterations are truncated-CG steps. Each one requires a
       Hessian (or approximate Hessian) evaluation.
    time (double)
       The total elapsed time in seconds to reach the corresponding cost.
    rho (double)
       The performance ratio for the iterate.
    rhonum, rhoden (double)
       Regularized numerator and denominator of the performance ratio:
       rho = rhonum/rhoden. See options.rho_regularization.
    accepted (boolean)
       Whether the proposed iterate was accepted or not.
    stepsize (double)
       The (Riemannian) norm of the vector returned by the inner solver
       tCG and which is retracted to obtain the proposed next iterate. If
       accepted = true for the corresponding iterate, this is the size of
       the step from the previous to the new iterate. If accepted is
       false, the step was not executed and this is the size of the
       rejected step.
    Delta (double)
       The trust-region radius at the outer iteration.
    cauchy (boolean)
       Whether the Cauchy point was used or not (if useRand is true).
   And possibly additional information logged by options.statsfun.
 For example, type [info.gradnorm] to obtain a vector of the successive
 gradient norms reached at each (outer) iteration.

 The options structure is used to overwrite the default values. All
 options have a default value and are hence optional. To force an option
 value, pass an options structure with a field options.optionname, where
 optionname is one of the following and the default value is indicated
 between parentheses:

   tolgradnorm (1e-6)
       The algorithm terminates if the norm of the gradient drops below
       this. For well-scaled problems, a rule of thumb is that you can
       expect to reduce the gradient norm by 8 orders of magnitude
       (sqrt(eps)) compared to the gradient norm at a &quot;typical&quot; point (a
       rough initial iterate for example). Further decrease is sometimes
       possible, but inexact floating point arithmetic will eventually
       limit the final accuracy. If tolgradnorm is set too low, the
       algorithm may end up iterating forever (or at least until another
       stopping criterion triggers).
   maxiter (1000)
       The algorithm terminates if maxiter (outer) iterations were executed.
   maxtime (Inf)
       The algorithm terminates if maxtime seconds elapsed.
    miniter (3)
       Minimum number of outer iterations (used only if useRand is true).
    mininner (1)
       Minimum number of inner iterations (for tCG).
    maxinner (problem.M.dim() : the manifold's dimension)
       Maximum number of inner iterations (for tCG).
    Delta_bar (problem.M.typicaldist() or sqrt(problem.M.dim()))
       Maximum trust-region radius. If you specify this parameter but not
       Delta0, then Delta0 will be set to 1/8 times this parameter.
   Delta0 (Delta_bar/8)
       Initial trust-region radius. If you observe a long plateau at the
       beginning of the convergence plot (gradient norm VS iteration), it
       may pay off to try to tune this parameter to shorten the plateau.
       You should not set this parameter without setting Delta_bar.
    useRand (false)
       Set to true if the trust-region solve is to be initiated with a
       random tangent vector. If set to true, no preconditioner will be
       used. This option is set to true in some scenarios to escape saddle
       points, but is otherwise seldom activated.
    kappa (0.1)
       Inner kappa convergence tolerance.
    theta (1.0)
       Inner theta convergence tolerance.
    rho_prime (0.1)
       Accept/reject ratio : if rho is at least rho_prime, the outer
       iteration is accepted. Otherwise, it is rejected. In case it is
       rejected, the trust-region radius will have been decreased.
       To ensure this, rho_prime must be strictly smaller than 1/4.
   rho_regularization (1e3)
       Close to convergence, evaluating the performance ratio rho is
       numerically challenging. Meanwhile, close to convergence, the
       quadratic model should be a good fit and the steps should be
       accepted. Regularization lets rho go to 1 as the model decrease and
       the actual decrease go to zero. Set this option to zero to disable
       regularization (not recommended). See in-code for the specifics.
   statsfun (none)
       Function handle to a function that will be called after each
       iteration to provide the opportunity to log additional statistics.
       They will be returned in the info struct. See the generic Manopt
       documentation about solvers for further information. statsfun is
       called with the point x that was reached last, after the
       accept/reject decision. See comment below.
   stopfun (none)
       Function handle to a function that will be called at each iteration
       to provide the opportunity to specify additional stopping criteria.
       See the generic Manopt documentation about solvers for further
       information.
   verbosity (2)
       Integer number used to tune the amount of output the algorithm
       generates during execution (mostly as text in the command window).
       The higher, the more output. 0 means silent. 3 and above includes a
       display of the options structure at the beginning of the execution.
   debug (false)
       Set to true to allow the algorithm to perform additional
       computations for debugging purposes. If a debugging test fails, you
       will be informed of it, usually via the command window. Be aware
       that these additional computations appear in the algorithm timings
       too.
   storedepth (20)
       Maximum number of different points x of the manifold for which a
       store structure will be kept in memory in the storedb. If the
       caching features of Manopt are not used, this is irrelevant. If
       memory usage is an issue, you may try to lower this number.
       Profiling may then help to investigate if a performance hit was
       incured as a result.

 Notice that statsfun is called with the point x that was reached last,
 after the accept/reject decision. Hence: if the step was accepted, we get
 that new x, with a store which only saw the call for the cost and for the
 gradient. If the step was rejected, we get the same x as previously, with
 the store structure containing everything that was computed at that point
 (possibly including previous rejects at that same point). Hence, statsfun
 should not be used in conjunction with the store to count operations for
 example. Instead, you could use a global variable and increment that
 variable directly from the cost related functions. It is however possible
 to use statsfun with the store to compute, for example, alternate merit
 functions on the point x.

 See also: steepestdescent conjugategradient manopt/examples</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../manopt/privatetools/applyStatsfun.html" class="code" title="function stats = applyStatsfun(problem, x, storedb, options, stats)">applyStatsfun</a>	Apply the statsfun function to a stats structure (for solvers).</li><li><a href="../../../manopt/privatetools/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>	Checks whether the cost function can be computed for a problem structure.</li><li><a href="../../../manopt/privatetools/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>	Checks whether the gradient can be computed for a problem structure.</li><li><a href="../../../manopt/privatetools/canGetHessian.html" class="code" title="function candoit = canGetHessian(problem)">canGetHessian</a>	Checks whether the Hessian can be computed for a problem structure.</li><li><a href="../../../manopt/privatetools/getCost.html" class="code" title="function [cost, storedb] = getCost(problem, x, storedb)">getCost</a>	Computes the cost function at x.</li><li><a href="../../../manopt/privatetools/getCostGrad.html" class="code" title="function [cost, grad, storedb] = getCostGrad(problem, x, storedb)">getCostGrad</a>	Computes the cost function and the gradient at x in one call if possible.</li><li><a href="../../../manopt/privatetools/getDirectionalDerivative.html" class="code" title="function [diff, storedb] = getDirectionalDerivative(problem, x, d, storedb)">getDirectionalDerivative</a>	Computes the directional derivative of the cost function at x along d.</li><li><a href="../../../manopt/privatetools/getGlobalDefaults.html" class="code" title="function opts = getGlobalDefaults()">getGlobalDefaults</a>	Returns a structure with default option values for Manopt.</li><li><a href="../../../manopt/privatetools/getGradient.html" class="code" title="function [grad, storedb] = getGradient(problem, x, storedb)">getGradient</a>	Computes the gradient of the cost function at x.</li><li><a href="../../../manopt/privatetools/getHessian.html" class="code" title="function [hess, storedb] = getHessian(problem, x, d, storedb)">getHessian</a>	Computes the Hessian of the cost function at x along d.</li><li><a href="../../../manopt/privatetools/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>	Merges two options structures with one having precedence over the other.</li><li><a href="../../../manopt/privatetools/purgeStoredb.html" class="code" title="function storedb = purgeStoredb(storedb, storedepth)">purgeStoredb</a>	Makes sure the storedb database does not exceed some maximum size.</li><li><a href="../../../manopt/privatetools/stoppingcriterion.html" class="code" title="function [stop reason] = stoppingcriterion(problem, x, options, info, last)">stoppingcriterion</a>	Checks for standard stopping criteria, as a helper to solvers.</li><li><a href="tCG.html" class="code" title="function [eta Heta inner_it stop_tCG storedb]= tCG(problem, x, grad, eta, Delta, options, storedb)">tCG</a>	tCG - Truncated (Steihaug-Toint) Conjugate-Gradient method</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../examples/dominant_invariant_subspace.html" class="code" title="function [X, info] = dominant_invariant_subspace(A, p)">dominant_invariant_subspace</a>	Returns an orthonormal basis of the dominant invariant p-subspace of A.</li><li><a href="../../../examples/generalized_procrustes.html" class="code" title="function [A R] = generalized_procrustes(A_measure)">generalized_procrustes</a>	Rotationally align clouds of points (generalized Procrustes problem)</li><li><a href="../../../examples/maxcut.html" class="code" title="function [x cutvalue cutvalue_upperbound Y] = maxcut(L, r)">maxcut</a>	Algorithm to (try to) compute a maximum cut of a graph, via SDP approach.</li><li><a href="../../../examples/maxcut_octave.html" class="code" title="function [x cutvalue cutvalue_upperbound Y] = maxcut_octave(L, r)">maxcut_octave</a>	Algorithm to (try to) compute a maximum cut of a graph, via SDP approach.</li><li><a href="../../../examples/positive_definite_karcher_mean.html" class="code" title="function X = positive_definite_karcher_mean(A)">positive_definite_karcher_mean</a>	Computes a Karcher mean of a collection of positive definite matrices.</li><li><a href="../../../examples/sparse_pca.html" class="code" title="function [Z, P, X, A] = sparse_pca(A, m, gamma)">sparse_pca</a>	Sparse principal component analysis based on optimization over Stiefel.</li><li><a href="../../../examples/truncated_svd.html" class="code" title="function [U S V info] = truncated_svd(A, p)">truncated_svd</a>	Returns an SVD decomposition of A truncated to rank p.</li><li><a href="../../../manopt/solvers/neldermead/centroid.html" class="code" title="function y = centroid(M, x)">centroid</a>	Attempts the computation of a centroid of a set of points on amanifold.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function stats = savestats(problem, x, storedb, options, k, fx,</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [x cost info] = trustregions(problem, x, options)</a>
0002 <span class="comment">% Riemannian trust-regions solver for optimization on manifolds.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function [x cost info] = trustregions(problem)</span>
0005 <span class="comment">% function [x cost info] = trustregions(problem, x0)</span>
0006 <span class="comment">% function [x cost info] = trustregions(problem, x0, options)</span>
0007 <span class="comment">% function [x cost info] = trustregions(problem, [], options)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% This is the Riemannian Trust-Region solver (with tCG inner solve), named</span>
0010 <span class="comment">% RTR. This solver will attempt to minimize the cost function described in</span>
0011 <span class="comment">% the problem structure. It requires the availability of the cost function</span>
0012 <span class="comment">% and of its gradient. It will issue calls for the Hessian. If no Hessian</span>
0013 <span class="comment">% nor approximate Hessian is provided, a standard approximation of the</span>
0014 <span class="comment">% Hessian based on the gradient will be computed. If a preconditioner for</span>
0015 <span class="comment">% the Hessian is provided, it will be used.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% For a description of the algorithm and theorems offering convergence</span>
0018 <span class="comment">% guarantees, see the references below. Documentation for this solver is</span>
0019 <span class="comment">% available online at:</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% http://www.manopt.org/solver_documentation_trustregions.html</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% The initial iterate is x0 if it is provided. Otherwise, a random point on</span>
0025 <span class="comment">% the manifold is picked. To specify options whilst not specifying an</span>
0026 <span class="comment">% initial iterate, give x0 as [] (the empty matrix).</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% The two outputs 'x' and 'cost' are the last reached point on the manifold</span>
0029 <span class="comment">% and its cost. Notice that x is not necessarily the best reached point,</span>
0030 <span class="comment">% because this solver is not forced to be a descent method. In particular,</span>
0031 <span class="comment">% very close to convergence, it is sometimes preferable to accept very</span>
0032 <span class="comment">% slight increases in the cost value (on the order of the machine epsilon)</span>
0033 <span class="comment">% in the process of reaching fine convergence. In practice, this is not a</span>
0034 <span class="comment">% limiting factor, as normally one does not need fine enough convergence</span>
0035 <span class="comment">% that this becomes an issue.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% The output 'info' is a struct-array which contains information about the</span>
0038 <span class="comment">% iterations:</span>
0039 <span class="comment">%   iter (integer)</span>
0040 <span class="comment">%       The (outer) iteration number, or number of steps considered</span>
0041 <span class="comment">%       (whether accepted or rejected). The initial guess is 0.</span>
0042 <span class="comment">%    cost (double)</span>
0043 <span class="comment">%       The corresponding cost value.</span>
0044 <span class="comment">%    gradnorm (double)</span>
0045 <span class="comment">%       The (Riemannian) norm of the gradient.</span>
0046 <span class="comment">%    numinner (integer)</span>
0047 <span class="comment">%       The number of inner iterations executed to compute this iterate.</span>
0048 <span class="comment">%       Inner iterations are truncated-CG steps. Each one requires a</span>
0049 <span class="comment">%       Hessian (or approximate Hessian) evaluation.</span>
0050 <span class="comment">%    time (double)</span>
0051 <span class="comment">%       The total elapsed time in seconds to reach the corresponding cost.</span>
0052 <span class="comment">%    rho (double)</span>
0053 <span class="comment">%       The performance ratio for the iterate.</span>
0054 <span class="comment">%    rhonum, rhoden (double)</span>
0055 <span class="comment">%       Regularized numerator and denominator of the performance ratio:</span>
0056 <span class="comment">%       rho = rhonum/rhoden. See options.rho_regularization.</span>
0057 <span class="comment">%    accepted (boolean)</span>
0058 <span class="comment">%       Whether the proposed iterate was accepted or not.</span>
0059 <span class="comment">%    stepsize (double)</span>
0060 <span class="comment">%       The (Riemannian) norm of the vector returned by the inner solver</span>
0061 <span class="comment">%       tCG and which is retracted to obtain the proposed next iterate. If</span>
0062 <span class="comment">%       accepted = true for the corresponding iterate, this is the size of</span>
0063 <span class="comment">%       the step from the previous to the new iterate. If accepted is</span>
0064 <span class="comment">%       false, the step was not executed and this is the size of the</span>
0065 <span class="comment">%       rejected step.</span>
0066 <span class="comment">%    Delta (double)</span>
0067 <span class="comment">%       The trust-region radius at the outer iteration.</span>
0068 <span class="comment">%    cauchy (boolean)</span>
0069 <span class="comment">%       Whether the Cauchy point was used or not (if useRand is true).</span>
0070 <span class="comment">%   And possibly additional information logged by options.statsfun.</span>
0071 <span class="comment">% For example, type [info.gradnorm] to obtain a vector of the successive</span>
0072 <span class="comment">% gradient norms reached at each (outer) iteration.</span>
0073 <span class="comment">%</span>
0074 <span class="comment">% The options structure is used to overwrite the default values. All</span>
0075 <span class="comment">% options have a default value and are hence optional. To force an option</span>
0076 <span class="comment">% value, pass an options structure with a field options.optionname, where</span>
0077 <span class="comment">% optionname is one of the following and the default value is indicated</span>
0078 <span class="comment">% between parentheses:</span>
0079 <span class="comment">%</span>
0080 <span class="comment">%   tolgradnorm (1e-6)</span>
0081 <span class="comment">%       The algorithm terminates if the norm of the gradient drops below</span>
0082 <span class="comment">%       this. For well-scaled problems, a rule of thumb is that you can</span>
0083 <span class="comment">%       expect to reduce the gradient norm by 8 orders of magnitude</span>
0084 <span class="comment">%       (sqrt(eps)) compared to the gradient norm at a &quot;typical&quot; point (a</span>
0085 <span class="comment">%       rough initial iterate for example). Further decrease is sometimes</span>
0086 <span class="comment">%       possible, but inexact floating point arithmetic will eventually</span>
0087 <span class="comment">%       limit the final accuracy. If tolgradnorm is set too low, the</span>
0088 <span class="comment">%       algorithm may end up iterating forever (or at least until another</span>
0089 <span class="comment">%       stopping criterion triggers).</span>
0090 <span class="comment">%   maxiter (1000)</span>
0091 <span class="comment">%       The algorithm terminates if maxiter (outer) iterations were executed.</span>
0092 <span class="comment">%   maxtime (Inf)</span>
0093 <span class="comment">%       The algorithm terminates if maxtime seconds elapsed.</span>
0094 <span class="comment">%    miniter (3)</span>
0095 <span class="comment">%       Minimum number of outer iterations (used only if useRand is true).</span>
0096 <span class="comment">%    mininner (1)</span>
0097 <span class="comment">%       Minimum number of inner iterations (for tCG).</span>
0098 <span class="comment">%    maxinner (problem.M.dim() : the manifold's dimension)</span>
0099 <span class="comment">%       Maximum number of inner iterations (for tCG).</span>
0100 <span class="comment">%    Delta_bar (problem.M.typicaldist() or sqrt(problem.M.dim()))</span>
0101 <span class="comment">%       Maximum trust-region radius. If you specify this parameter but not</span>
0102 <span class="comment">%       Delta0, then Delta0 will be set to 1/8 times this parameter.</span>
0103 <span class="comment">%   Delta0 (Delta_bar/8)</span>
0104 <span class="comment">%       Initial trust-region radius. If you observe a long plateau at the</span>
0105 <span class="comment">%       beginning of the convergence plot (gradient norm VS iteration), it</span>
0106 <span class="comment">%       may pay off to try to tune this parameter to shorten the plateau.</span>
0107 <span class="comment">%       You should not set this parameter without setting Delta_bar.</span>
0108 <span class="comment">%    useRand (false)</span>
0109 <span class="comment">%       Set to true if the trust-region solve is to be initiated with a</span>
0110 <span class="comment">%       random tangent vector. If set to true, no preconditioner will be</span>
0111 <span class="comment">%       used. This option is set to true in some scenarios to escape saddle</span>
0112 <span class="comment">%       points, but is otherwise seldom activated.</span>
0113 <span class="comment">%    kappa (0.1)</span>
0114 <span class="comment">%       Inner kappa convergence tolerance.</span>
0115 <span class="comment">%    theta (1.0)</span>
0116 <span class="comment">%       Inner theta convergence tolerance.</span>
0117 <span class="comment">%    rho_prime (0.1)</span>
0118 <span class="comment">%       Accept/reject ratio : if rho is at least rho_prime, the outer</span>
0119 <span class="comment">%       iteration is accepted. Otherwise, it is rejected. In case it is</span>
0120 <span class="comment">%       rejected, the trust-region radius will have been decreased.</span>
0121 <span class="comment">%       To ensure this, rho_prime must be strictly smaller than 1/4.</span>
0122 <span class="comment">%   rho_regularization (1e3)</span>
0123 <span class="comment">%       Close to convergence, evaluating the performance ratio rho is</span>
0124 <span class="comment">%       numerically challenging. Meanwhile, close to convergence, the</span>
0125 <span class="comment">%       quadratic model should be a good fit and the steps should be</span>
0126 <span class="comment">%       accepted. Regularization lets rho go to 1 as the model decrease and</span>
0127 <span class="comment">%       the actual decrease go to zero. Set this option to zero to disable</span>
0128 <span class="comment">%       regularization (not recommended). See in-code for the specifics.</span>
0129 <span class="comment">%   statsfun (none)</span>
0130 <span class="comment">%       Function handle to a function that will be called after each</span>
0131 <span class="comment">%       iteration to provide the opportunity to log additional statistics.</span>
0132 <span class="comment">%       They will be returned in the info struct. See the generic Manopt</span>
0133 <span class="comment">%       documentation about solvers for further information. statsfun is</span>
0134 <span class="comment">%       called with the point x that was reached last, after the</span>
0135 <span class="comment">%       accept/reject decision. See comment below.</span>
0136 <span class="comment">%   stopfun (none)</span>
0137 <span class="comment">%       Function handle to a function that will be called at each iteration</span>
0138 <span class="comment">%       to provide the opportunity to specify additional stopping criteria.</span>
0139 <span class="comment">%       See the generic Manopt documentation about solvers for further</span>
0140 <span class="comment">%       information.</span>
0141 <span class="comment">%   verbosity (2)</span>
0142 <span class="comment">%       Integer number used to tune the amount of output the algorithm</span>
0143 <span class="comment">%       generates during execution (mostly as text in the command window).</span>
0144 <span class="comment">%       The higher, the more output. 0 means silent. 3 and above includes a</span>
0145 <span class="comment">%       display of the options structure at the beginning of the execution.</span>
0146 <span class="comment">%   debug (false)</span>
0147 <span class="comment">%       Set to true to allow the algorithm to perform additional</span>
0148 <span class="comment">%       computations for debugging purposes. If a debugging test fails, you</span>
0149 <span class="comment">%       will be informed of it, usually via the command window. Be aware</span>
0150 <span class="comment">%       that these additional computations appear in the algorithm timings</span>
0151 <span class="comment">%       too.</span>
0152 <span class="comment">%   storedepth (20)</span>
0153 <span class="comment">%       Maximum number of different points x of the manifold for which a</span>
0154 <span class="comment">%       store structure will be kept in memory in the storedb. If the</span>
0155 <span class="comment">%       caching features of Manopt are not used, this is irrelevant. If</span>
0156 <span class="comment">%       memory usage is an issue, you may try to lower this number.</span>
0157 <span class="comment">%       Profiling may then help to investigate if a performance hit was</span>
0158 <span class="comment">%       incured as a result.</span>
0159 <span class="comment">%</span>
0160 <span class="comment">% Notice that statsfun is called with the point x that was reached last,</span>
0161 <span class="comment">% after the accept/reject decision. Hence: if the step was accepted, we get</span>
0162 <span class="comment">% that new x, with a store which only saw the call for the cost and for the</span>
0163 <span class="comment">% gradient. If the step was rejected, we get the same x as previously, with</span>
0164 <span class="comment">% the store structure containing everything that was computed at that point</span>
0165 <span class="comment">% (possibly including previous rejects at that same point). Hence, statsfun</span>
0166 <span class="comment">% should not be used in conjunction with the store to count operations for</span>
0167 <span class="comment">% example. Instead, you could use a global variable and increment that</span>
0168 <span class="comment">% variable directly from the cost related functions. It is however possible</span>
0169 <span class="comment">% to use statsfun with the store to compute, for example, alternate merit</span>
0170 <span class="comment">% functions on the point x.</span>
0171 <span class="comment">%</span>
0172 <span class="comment">% See also: steepestdescent conjugategradient manopt/examples</span>
0173 
0174 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0175 <span class="comment">% This code is an adaptation to Manopt of the original GenRTR code:</span>
0176 <span class="comment">% RTR - Riemannian Trust-Region</span>
0177 <span class="comment">% (c) 2004-2007, P.-A. Absil, C. G. Baker, K. A. Gallivan</span>
0178 <span class="comment">% Florida State University</span>
0179 <span class="comment">% School of Computational Science</span>
0180 <span class="comment">% (http://www.math.fsu.edu/~cbaker/GenRTR/?page=download)</span>
0181 <span class="comment">% See accompanying license file.</span>
0182 <span class="comment">% The adaptation was executed by Nicolas Boumal.</span>
0183 <span class="comment">%</span>
0184 <span class="comment">% Change log:</span>
0185 <span class="comment">%</span>
0186 <span class="comment">%   NB April 3, 2013:</span>
0187 <span class="comment">%       tCG now returns the Hessian along the returned direction eta, so</span>
0188 <span class="comment">%       that we do not compute that Hessian redundantly: some savings at</span>
0189 <span class="comment">%       each iteration. Similarly, if the useRand flag is on, we spare an</span>
0190 <span class="comment">%       extra Hessian computation at each outer iteration too, owing to</span>
0191 <span class="comment">%       some modifications in the Cauchy point section of the code specific</span>
0192 <span class="comment">%       to useRand = true.</span>
0193 <span class="comment">%</span>
0194 <span class="comment">%   NB Aug. 22, 2013:</span>
0195 <span class="comment">%       This function is now Octave compatible. The transition called for</span>
0196 <span class="comment">%       two changes which would otherwise not be advisable. (1) tic/toc is</span>
0197 <span class="comment">%       now used as is, as opposed to the safer way:</span>
0198 <span class="comment">%       t = tic(); elapsed = toc(t);</span>
0199 <span class="comment">%       And (2), the (formerly inner) function savestats was moved outside</span>
0200 <span class="comment">%       the main function to not be nested anymore. This is arguably less</span>
0201 <span class="comment">%       elegant, but Octave does not (and likely will not) support nested</span>
0202 <span class="comment">%       functions.</span>
0203 <span class="comment">%</span>
0204 <span class="comment">%   NB Dec. 2, 2013:</span>
0205 <span class="comment">%       The in-code documentation was largely revised and expanded.</span>
0206 <span class="comment">%</span>
0207 <span class="comment">%   NB Dec. 2, 2013:</span>
0208 <span class="comment">%       The former heuristic which triggered when rhonum was very small and</span>
0209 <span class="comment">%       forced rho = 1 has been replaced by a smoother heuristic which</span>
0210 <span class="comment">%       consists in regularizing rhonum and rhoden before computing their</span>
0211 <span class="comment">%       ratio. It is tunable via options.rho_regularization. Furthermore,</span>
0212 <span class="comment">%       the solver now detects if tCG did not obtain a model decrease</span>
0213 <span class="comment">%       (which is theoretically impossible but may happen because of</span>
0214 <span class="comment">%       numerical errors and/or because of a nonlinear/nonsymmetric Hessian</span>
0215 <span class="comment">%       operator, which is the case for finite difference approximations).</span>
0216 <span class="comment">%       When such an anomaly is detected, the step is rejected and the</span>
0217 <span class="comment">%       trust region radius is decreased.</span>
0218 <span class="comment">%</span>
0219 <span class="comment">%   NB Dec. 3, 2013:</span>
0220 <span class="comment">%       The stepsize is now registered at each iteration, at a small</span>
0221 <span class="comment">%       additional cost. The defaults for Delta_bar and Delta0 are better</span>
0222 <span class="comment">%       defined. Setting Delta_bar in the options will automatically set</span>
0223 <span class="comment">%       Delta0 accordingly. In Manopt 1.0.4, the defaults for these options</span>
0224 <span class="comment">%       were not treated appropriately because of an incorrect use of the</span>
0225 <span class="comment">%       isfield() built-in function.</span>
0226 
0227 
0228 <span class="comment">% Verify that the problem description is sufficient for the solver.</span>
0229 <span class="keyword">if</span> ~<a href="../../../manopt/privatetools/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>(problem)
0230     warning(<span class="string">'manopt:getCost'</span>, <span class="keyword">...</span>
0231             <span class="string">'No cost provided. The algorithm will likely abort.'</span>);  
0232 <span class="keyword">end</span>
0233 <span class="keyword">if</span> ~<a href="../../../manopt/privatetools/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>(problem)
0234     warning(<span class="string">'manopt:getGradient'</span>, <span class="keyword">...</span>
0235             <span class="string">'No gradient provided. The algorithm will likely abort.'</span>);    
0236 <span class="keyword">end</span>
0237 <span class="keyword">if</span> ~<a href="../../../manopt/privatetools/canGetHessian.html" class="code" title="function candoit = canGetHessian(problem)">canGetHessian</a>(problem)
0238     warning(<span class="string">'manopt:getHessian:approx'</span>, <span class="keyword">...</span>
0239             <span class="string">'No Hessian provided. Using an approximation instead.'</span>);
0240 <span class="keyword">end</span>
0241 
0242 <span class="comment">% Define some strings for display</span>
0243 tcg_stop_reason = {<span class="string">'negative curvature'</span>,<span class="keyword">...</span>
0244                    <span class="string">'exceeded trust region'</span>,<span class="keyword">...</span>
0245                    <span class="string">'reached target residual-kappa'</span>,<span class="keyword">...</span>
0246                    <span class="string">'reached target residual-theta'</span>,<span class="keyword">...</span>
0247                    <span class="string">'dimension exceeded'</span>,<span class="keyword">...</span>
0248                    <span class="string">'model increased'</span>};
0249 
0250 <span class="comment">% Set local defaults here</span>
0251 localdefaults.verbosity = 2;
0252 localdefaults.maxtime = inf;
0253 localdefaults.miniter = 3;
0254 localdefaults.maxiter = 1000;
0255 localdefaults.mininner = 1;
0256 localdefaults.maxinner = problem.M.dim();
0257 localdefaults.tolgradnorm = 1e-6;
0258 localdefaults.kappa = 0.1;
0259 localdefaults.theta = 1.0;
0260 localdefaults.rho_prime = 0.1;
0261 localdefaults.useRand = false;
0262 localdefaults.rho_regularization = 1e3;
0263 
0264 <span class="comment">% Merge global and local defaults, then merge w/ user options, if any.</span>
0265 localdefaults = <a href="../../../manopt/privatetools/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>(<a href="../../../manopt/privatetools/getGlobalDefaults.html" class="code" title="function opts = getGlobalDefaults()">getGlobalDefaults</a>(), localdefaults);
0266 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>) || isempty(options)
0267     options = struct();
0268 <span class="keyword">end</span>
0269 options = <a href="../../../manopt/privatetools/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>(localdefaults, options);
0270 
0271 <span class="comment">% Set default Delta_bar and Delta0 separately to deal with additional</span>
0272 <span class="comment">% logic: if Delta_bar is provided but not Delta0, let Delta0 automatically</span>
0273 <span class="comment">% be some fraction of the provided Delta_bar.</span>
0274 <span class="keyword">if</span> ~isfield(options, <span class="string">'Delta_bar'</span>)
0275     <span class="keyword">if</span> isfield(problem.M, <span class="string">'typicaldist'</span>)
0276         options.Delta_bar = problem.M.typicaldist();
0277     <span class="keyword">else</span>
0278         options.Delta_bar = sqrt(problem.M.dim());
0279     <span class="keyword">end</span> 
0280 <span class="keyword">end</span>
0281 <span class="keyword">if</span> ~isfield(options,<span class="string">'Delta0'</span>)
0282     options.Delta0 = options.Delta_bar / 8;
0283 <span class="keyword">end</span>
0284 
0285 <span class="comment">% Check some option values</span>
0286 assert(options.rho_prime &lt; 1/4, <span class="keyword">...</span>
0287         <span class="string">'options.rho_prime must be strictly smaller than 1/4.'</span>);
0288 assert(options.Delta_bar &gt; 0, <span class="keyword">...</span>
0289         <span class="string">'options.Delta_bar must be positive.'</span>);
0290 assert(options.Delta0 &gt; 0 &amp;&amp; options.Delta0 &lt; options.Delta_bar, <span class="keyword">...</span>
0291         <span class="string">'options.Delta0 must be positive and smaller than Delta_bar.'</span>);
0292 
0293 <span class="comment">% It is sometimes useful to check what the actual option values are.</span>
0294 <span class="keyword">if</span> options.verbosity &gt;= 3
0295     disp(options);
0296 <span class="keyword">end</span>
0297 
0298 <span class="comment">% Create a store database</span>
0299 storedb = struct();
0300 
0301 tic();
0302 
0303 <span class="comment">% If no initial point x is given by the user, generate one at random.</span>
0304 <span class="keyword">if</span> ~exist(<span class="string">'x'</span>, <span class="string">'var'</span>) || isempty(x)
0305     x = problem.M.rand();
0306 <span class="keyword">end</span>
0307 
0308 <span class="comment">%% Initializations</span>
0309 
0310 <span class="comment">% k counts the outer (TR) iterations. The semantic is that k counts the</span>
0311 <span class="comment">% number of iterations fully executed so far.</span>
0312 k = 0;
0313 
0314 <span class="comment">% initialize solution and companion measures: f(x), fgrad(x)</span>
0315 [fx fgradx storedb] = <a href="../../../manopt/privatetools/getCostGrad.html" class="code" title="function [cost, grad, storedb] = getCostGrad(problem, x, storedb)">getCostGrad</a>(problem, x, storedb);
0316 norm_grad = problem.M.norm(x, fgradx);
0317 
0318 <span class="comment">% initialize trust-region radius</span>
0319 Delta = options.Delta0;
0320 
0321 <span class="comment">% Save stats in a struct array info, and preallocate</span>
0322 <span class="comment">% (see http://people.csail.mit.edu/jskelly/blog/?x=entry:entry091030-033941)</span>
0323 <span class="keyword">if</span> ~exist(<span class="string">'used_cauchy'</span>, <span class="string">'var'</span>)
0324     used_cauchy = [];
0325 <span class="keyword">end</span>
0326 stats = <a href="#_sub1" class="code" title="subfunction stats = savestats(problem, x, storedb, options, k, fx, ">savestats</a>(problem, x, storedb, options, k, fx, norm_grad, Delta);
0327 info(1) = stats;
0328 info(min(10000, options.maxiter+1)).iter = [];
0329 
0330 <span class="comment">% ** Display:</span>
0331 <span class="keyword">if</span> options.verbosity == 2
0332    fprintf([<span class="string">'%3s %3s      %5s                %5s     '</span>,<span class="keyword">...</span>
0333             <span class="string">'f: %e   |grad|: %e\n'</span>],<span class="keyword">...</span>
0334            <span class="string">'   '</span>,<span class="string">'   '</span>,<span class="string">'     '</span>,<span class="string">'     '</span>, fx, norm_grad);
0335 <span class="keyword">elseif</span> options.verbosity &gt; 2
0336    fprintf(<span class="string">'************************************************************************\n'</span>);
0337    fprintf(<span class="string">'%3s %3s    k: %5s     num_inner: %5s     %s\n'</span>,<span class="keyword">...</span>
0338            <span class="string">''</span>,<span class="string">''</span>,<span class="string">'______'</span>,<span class="string">'______'</span>,<span class="string">''</span>);
0339    fprintf(<span class="string">'       f(x) : %e       |grad| : %e\n'</span>, fx, norm_grad);
0340    fprintf(<span class="string">'      Delta : %f\n'</span>, Delta);
0341 <span class="keyword">end</span>
0342 
0343 
0344 <span class="comment">% **********************</span>
0345 <span class="comment">% ** Start of TR loop **</span>
0346 <span class="comment">% **********************</span>
0347 <span class="keyword">while</span> true
0348     
0349     <span class="comment">% Start clock for this outer iteration</span>
0350     tic();
0351 
0352     <span class="comment">% Run standard stopping criterion checks</span>
0353     [stop reason] = <a href="../../../manopt/privatetools/stoppingcriterion.html" class="code" title="function [stop reason] = stoppingcriterion(problem, x, options, info, last)">stoppingcriterion</a>(problem, x, options, info, k+1);
0354     
0355     <span class="comment">% If the stopping criterion that triggered is the tolerance on the</span>
0356     <span class="comment">% gradient norm but we are using randomization, make sure we make at</span>
0357     <span class="comment">% least miniter iterations to give randomization a chance at escaping</span>
0358     <span class="comment">% saddle points.</span>
0359     <span class="keyword">if</span> stop == 2 &amp;&amp; options.useRand &amp;&amp; k &lt; options.miniter
0360         stop = 0;
0361     <span class="keyword">end</span>
0362     
0363     <span class="keyword">if</span> stop
0364         <span class="keyword">if</span> options.verbosity &gt;= 1
0365             fprintf([reason <span class="string">'\n'</span>]);
0366         <span class="keyword">end</span>
0367         <span class="keyword">break</span>;
0368     <span class="keyword">end</span>
0369 
0370     <span class="keyword">if</span> options.verbosity &gt; 2 || options.debug &gt; 0
0371         fprintf(<span class="string">'************************************************************************\n'</span>);
0372     <span class="keyword">end</span>
0373 
0374     <span class="comment">% *************************</span>
0375     <span class="comment">% ** Begin TR Subproblem **</span>
0376     <span class="comment">% *************************</span>
0377   
0378     <span class="comment">% Determine eta0</span>
0379     <span class="keyword">if</span> ~options.useRand
0380         <span class="comment">% Pick the zero vector</span>
0381         eta = problem.M.zerovec(x);
0382     <span class="keyword">else</span>
0383         <span class="comment">% Random vector in T_x M (this has to be very small)</span>
0384         eta = problem.M.lincomb(x, 1e-6, problem.M.randvec(x));
0385         <span class="comment">% Must be inside trust-region</span>
0386         <span class="keyword">while</span> problem.M.norm(x, eta) &gt; Delta
0387             eta = problem.M.lincomb(x, sqrt(sqrt(eps)), eta);
0388         <span class="keyword">end</span>
0389     <span class="keyword">end</span>
0390 
0391     <span class="comment">% solve TR subproblem</span>
0392     [eta Heta numit stop_inner storedb] = <span class="keyword">...</span>
0393                      <a href="tCG.html" class="code" title="function [eta Heta inner_it stop_tCG storedb]= tCG(problem, x, grad, eta, Delta, options, storedb)">tCG</a>(problem, x, fgradx, eta, Delta, options, storedb);
0394     srstr = tcg_stop_reason{stop_inner};
0395     
0396     <span class="comment">% This is only computed for logging purposes, because it may be useful</span>
0397     <span class="comment">% for some user-defined stopping criteria. If this is not cheap for</span>
0398     <span class="comment">% specific application (compared to evaluating the cost), we should</span>
0399     <span class="comment">% reconsider this.</span>
0400     norm_eta = problem.M.norm(x, eta);
0401     
0402     <span class="keyword">if</span> options.debug &gt; 0
0403         testangle = problem.M.inner(x, eta, fgradx) / (norm_eta*norm_grad);
0404     <span class="keyword">end</span>
0405 
0406     <span class="comment">% If using randomized approach, compare result with the Cauchy point.</span>
0407     <span class="comment">% Convergence proofs assume that we achieve at least the reduction of</span>
0408     <span class="comment">% the Cauchy point. After this if-block, either all eta-related</span>
0409     <span class="comment">% quantities have been changed consistently, or none of them have</span>
0410     <span class="comment">% changed.</span>
0411     <span class="keyword">if</span> options.useRand
0412         used_cauchy = false;
0413         <span class="comment">% Check the curvature,</span>
0414         [Hg storedb] = <a href="../../../manopt/privatetools/getHessian.html" class="code" title="function [hess, storedb] = getHessian(problem, x, d, storedb)">getHessian</a>(problem, x, fgradx, storedb);
0415         g_Hg = problem.M.inner(x, fgradx, Hg);
0416         <span class="keyword">if</span> g_Hg &lt;= 0
0417             tau_c = 1;
0418         <span class="keyword">else</span>
0419             tau_c = min( norm_grad^3/(Delta*g_Hg) , 1);
0420         <span class="keyword">end</span>
0421         <span class="comment">% and generate the Cauchy point.</span>
0422         eta_c  = problem.M.lincomb(x, -tau_c * Delta / norm_grad, fgradx);
0423         Heta_c = problem.M.lincomb(x, -tau_c * Delta / norm_grad, Hg);
0424 
0425         <span class="comment">% Now that we have computed the Cauchy point in addition to the</span>
0426         <span class="comment">% returned eta, we might as well keep the best of them.</span>
0427         mdle  = fx + problem.M.inner(x, fgradx, eta) <span class="keyword">...</span>
0428                    + .5*problem.M.inner(x, Heta,   eta);
0429         mdlec = fx + problem.M.inner(x, fgradx, eta_c) <span class="keyword">...</span>
0430                    + .5*problem.M.inner(x, Heta_c, eta_c);
0431         <span class="keyword">if</span> mdle &gt; mdlec
0432             eta = eta_c;
0433             Heta = Heta_c; <span class="comment">% added April 11, 2012</span>
0434             used_cauchy = true;
0435         <span class="keyword">end</span>
0436     <span class="keyword">end</span> 
0437 
0438     <span class="comment">% Compute the retraction of the proposal</span>
0439     x_prop  = problem.M.retr(x, eta);
0440 
0441     <span class="comment">% Compute the function value of the proposal</span>
0442     [fx_prop storedb] = <a href="../../../manopt/privatetools/getCost.html" class="code" title="function [cost, storedb] = getCost(problem, x, storedb)">getCost</a>(problem, x_prop, storedb);
0443 
0444     <span class="comment">% Will we accept the proposed solution or not?</span>
0445     <span class="comment">% Check the performance of the quadratic model against the actual cost.</span>
0446     rhonum = fx - fx_prop;
0447     rhoden = -problem.M.inner(x, fgradx, eta) <span class="keyword">...</span>
0448              -.5*problem.M.inner(x, eta, Heta);
0449     
0450     <span class="comment">% Heuristic -- added Dec. 2, 2013 (NB) to replace the former heuristic.</span>
0451     <span class="comment">% This heuristic is documented in the book by Conn Gould and Toint on</span>
0452     <span class="comment">% trust-region methods, section 17.4.2.</span>
0453     <span class="comment">% rhonum measures the difference between two numbers. Close to</span>
0454     <span class="comment">% convergence, these two numbers are very close to each other, so</span>
0455     <span class="comment">% that computing their difference is numerically challenging: there may</span>
0456     <span class="comment">% be a significant loss in accuracy. Since the acceptance or rejection</span>
0457     <span class="comment">% of the step is conditioned on the ratio between rhonum and rhoden,</span>
0458     <span class="comment">% large errors in rhonum result in a large error in rho, hence in</span>
0459     <span class="comment">% erratic acceptance / rejection. Meanwhile, close to convergence,</span>
0460     <span class="comment">% steps are usually trustworthy and we should transition to a Newton-</span>
0461     <span class="comment">% like method, with rho=1 consistently. The heuristic thus shifts both</span>
0462     <span class="comment">% rhonum and rhoden by a small amount such that far from convergence,</span>
0463     <span class="comment">% the shift is irrelevant and close to convergence, the ratio rho goes</span>
0464     <span class="comment">% to 1, effectively promoting acceptance of the step.</span>
0465     <span class="comment">% The rationale is that close to convergence, both rhonum and rhoden</span>
0466     <span class="comment">% are quadratic in the distance between x and x_prop. Thus, when this</span>
0467     <span class="comment">% distance is on the order of sqrt(eps), the value of rhonum and rhoden</span>
0468     <span class="comment">% is on the order of eps, which is indistinguishable from the numerical</span>
0469     <span class="comment">% error, resulting in badly estimated rho's.</span>
0470     <span class="comment">% For abs(fx) &lt; 1, this heuristic is invariant under offsets of f but</span>
0471     <span class="comment">% not under scaling of f. For abs(fx) &gt; 1, the opposite holds. This</span>
0472     <span class="comment">% should not alarm us, as this heuristic only triggers at the very last</span>
0473     <span class="comment">% iterations if very fine convergence is demanded.</span>
0474     rho_reg = max(1, abs(fx)) * eps * options.rho_regularization;
0475     rhonum = rhonum + rho_reg;
0476     rhoden = rhoden + rho_reg;
0477    
0478     <span class="keyword">if</span> options.debug &gt; 0
0479         fprintf(<span class="string">'DBG:     rhonum : %e\n'</span>, rhonum);
0480         fprintf(<span class="string">'DBG:     rhoden : %e\n'</span>, rhoden);
0481     <span class="keyword">end</span>
0482     
0483     <span class="comment">% This is always true if a linear, symmetric operator is used for the</span>
0484     <span class="comment">% Hessian (approximation) and if we had infinite numerical precision.</span>
0485     <span class="comment">% In practice, nonlinear approximations of the Hessian such as the</span>
0486     <span class="comment">% built-in finite difference approximation and finite numerical</span>
0487     <span class="comment">% accuracy can cause the model to increase. In such scenarios, we</span>
0488     <span class="comment">% decide to force a rejection of the step and a reduction of the</span>
0489     <span class="comment">% trust-region radius. We test the sign of the regularized rhoden since</span>
0490     <span class="comment">% the regularization is supposed to capture the accuracy to which</span>
0491     <span class="comment">% rhoden is computed: if rhoden were negative before regularization but</span>
0492     <span class="comment">% not after, that should not be (and is not) detected as a failure.</span>
0493     model_decreased = (rhoden &gt;= 0);
0494     
0495     <span class="keyword">if</span> ~model_decreased 
0496         srstr = [srstr <span class="string">', model did not decrease'</span>]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0497     <span class="keyword">end</span>
0498     
0499     rho = rhonum / rhoden;
0500    
0501     <span class="keyword">if</span> options.debug &gt; 0
0502         m = @(x, eta) <span class="keyword">...</span>
0503           <a href="../../../manopt/privatetools/getCost.html" class="code" title="function [cost, storedb] = getCost(problem, x, storedb)">getCost</a>(problem, x, storedb) + <span class="keyword">...</span>
0504           <a href="../../../manopt/privatetools/getDirectionalDerivative.html" class="code" title="function [diff, storedb] = getDirectionalDerivative(problem, x, d, storedb)">getDirectionalDerivative</a>(problem, x, eta, storedb) + <span class="keyword">...</span>
0505           .5*problem.M.inner(x, <a href="../../../manopt/privatetools/getHessian.html" class="code" title="function [hess, storedb] = getHessian(problem, x, d, storedb)">getHessian</a>(problem, x, eta, storedb), eta);
0506         zerovec = problem.M.zerovec(x);
0507         actrho = (fx - fx_prop) / (m(x, zerovec) - m(x, eta));
0508         fprintf(<span class="string">'DBG:   new f(x) : %e\n'</span>, fx_prop);
0509         fprintf(<span class="string">'DBG: actual rho : %e\n'</span>, actrho);
0510         fprintf(<span class="string">'DBG:   used rho : %e\n'</span>, rho);
0511     <span class="keyword">end</span>
0512 
0513     <span class="comment">% Choose the new TR radius based on the model performance</span>
0514     trstr = <span class="string">'   '</span>;
0515     <span class="comment">% If the actual decrease is smaller than 1/4 of the predicted decrease,</span>
0516     <span class="comment">% then reduce the TR radius.</span>
0517     <span class="keyword">if</span> rho &lt; 1/4 || ~model_decreased
0518         trstr = <span class="string">'TR-'</span>;
0519         Delta = Delta/4;
0520     <span class="comment">% If the actual decrease is at least 3/4 of the precicted decrease and</span>
0521     <span class="comment">% the tCG (inner solve) hit the TR boundary, increase the TR radius.</span>
0522     <span class="keyword">elseif</span> rho &gt; 3/4 &amp;&amp; (stop_inner == 1 || stop_inner == 2)
0523         trstr = <span class="string">'TR+'</span>;
0524         Delta = min(2*Delta, options.Delta_bar);
0525     <span class="keyword">end</span>
0526     <span class="comment">% Otherwise, keep the TR radius constant.</span>
0527 
0528     <span class="comment">% Choose to accept or reject the proposed step based on the model</span>
0529     <span class="comment">% performance.</span>
0530     <span class="keyword">if</span> model_decreased &amp;&amp; rho &gt; options.rho_prime
0531         accept = true;
0532         accstr = <span class="string">'acc'</span>;
0533         x = x_prop;
0534         fx = fx_prop;
0535         [fgradx storedb] = <a href="../../../manopt/privatetools/getGradient.html" class="code" title="function [grad, storedb] = getGradient(problem, x, storedb)">getGradient</a>(problem, x, storedb);
0536         norm_grad = problem.M.norm(x, fgradx);
0537     <span class="keyword">else</span>
0538         accept = false;
0539         accstr = <span class="string">'REJ'</span>;
0540     <span class="keyword">end</span>
0541     
0542     
0543     <span class="comment">% Make sure we don't use too much memory for the store database</span>
0544     storedb = <a href="../../../manopt/privatetools/purgeStoredb.html" class="code" title="function storedb = purgeStoredb(storedb, storedepth)">purgeStoredb</a>(storedb, options.storedepth);
0545     
0546     <span class="comment">% k is the number of iterations we have accomplished.</span>
0547     k = k + 1;
0548 
0549     <span class="comment">% Log statistics for freshly executed iteration.</span>
0550     <span class="comment">% Everything after this in the loop is not accounted for in the timing.</span>
0551     stats = <a href="#_sub1" class="code" title="subfunction stats = savestats(problem, x, storedb, options, k, fx, ">savestats</a>(problem, x, storedb, options, k, fx, norm_grad, <span class="keyword">...</span>
0552                       Delta, info, rho, rhonum, rhoden, accept, numit, <span class="keyword">...</span>
0553                       norm_eta, used_cauchy);
0554     info(k+1) = stats; <span class="comment">%#ok&lt;AGROW&gt;</span>
0555 
0556     
0557     <span class="comment">% ** Display:</span>
0558     <span class="keyword">if</span> options.verbosity == 2,
0559         fprintf([<span class="string">'%3s %3s   k: %5d     num_inner: %5d     '</span>, <span class="keyword">...</span>
0560         <span class="string">'f: %e   |grad|: %e   %s\n'</span>], <span class="keyword">...</span>
0561         accstr,trstr,k,numit,fx,norm_grad,srstr);
0562     <span class="keyword">elseif</span> options.verbosity &gt; 2,
0563         <span class="keyword">if</span> options.useRand &amp;&amp; used_cauchy,
0564             fprintf(<span class="string">'USED CAUCHY POINT\n'</span>);
0565         <span class="keyword">end</span>
0566         fprintf(<span class="string">'%3s %3s    k: %5d     num_inner: %5d     %s\n'</span>, <span class="keyword">...</span>
0567                 accstr, trstr, k, numit, srstr);
0568         fprintf(<span class="string">'       f(x) : %e     |grad| : %e\n'</span>,fx,norm_grad);
0569         <span class="keyword">if</span> options.debug &gt; 0
0570             fprintf(<span class="string">'      Delta : %f          |eta| : %e\n'</span>,Delta,norm_eta);
0571         <span class="keyword">end</span>
0572         fprintf(<span class="string">'        rho : %e\n'</span>,rho);
0573     <span class="keyword">end</span>
0574     <span class="keyword">if</span> options.debug &gt; 0,
0575         fprintf(<span class="string">'DBG: cos ang(eta,gradf): %d\n'</span>,testangle);
0576         <span class="keyword">if</span> rho == 0
0577             fprintf(<span class="string">'DBG: rho = 0, this will likely hinder further convergence.\n'</span>);
0578         <span class="keyword">end</span>
0579     <span class="keyword">end</span>
0580 
0581 <span class="keyword">end</span>  <span class="comment">% of TR loop (counter: k)</span>
0582 
0583 <span class="comment">% Restrict info struct-array to useful part</span>
0584 info = info(1:k+1);
0585 
0586 
0587 <span class="keyword">if</span> (options.verbosity &gt; 2) || (options.debug &gt; 0),
0588    fprintf(<span class="string">'************************************************************************\n'</span>);
0589 <span class="keyword">end</span>
0590 <span class="keyword">if</span> (options.verbosity &gt; 0) || (options.debug &gt; 0)
0591     fprintf(<span class="string">'Total time is %f [s] (excludes statsfun)\n'</span>, info(end).time);
0592 <span class="keyword">end</span>
0593 
0594 <span class="comment">% Return the best cost reached</span>
0595 cost = fx;
0596 
0597 <span class="keyword">end</span>
0598 
0599 
0600 
0601     
0602 
0603 <span class="comment">% Routine in charge of collecting the current iteration stats</span>
0604 <a name="_sub1" href="#_subfunctions" class="code">function stats = savestats(problem, x, storedb, options, k, fx, </a><span class="keyword">...</span>
0605                            norm_grad, Delta, info, rho, rhonum, <span class="keyword">...</span>
0606                            rhoden, accept, numit, norm_eta, used_cauchy)
0607     stats.iter = k;
0608     stats.cost = fx;
0609     stats.gradnorm = norm_grad;
0610     stats.Delta = Delta;
0611     <span class="keyword">if</span> k == 0
0612         stats.time = toc();
0613         stats.rho = inf;
0614         stats.rhonum = NaN;
0615         stats.rhoden = NaN;
0616         stats.accepted = true;
0617         stats.numinner = NaN;
0618         stats.stepsize = NaN;
0619         <span class="keyword">if</span> options.useRand
0620             stats.cauchy = false;
0621         <span class="keyword">end</span>
0622     <span class="keyword">else</span>
0623         stats.time = info(k).time + toc();
0624         stats.rho = rho;
0625         stats.rhonum = rhonum;
0626         stats.rhoden = rhoden;
0627         stats.accepted = accept;
0628         stats.numinner = numit;
0629         stats.stepsize = norm_eta;
0630         <span class="keyword">if</span> options.useRand,
0631           stats.cauchy = used_cauchy;
0632         <span class="keyword">end</span>
0633     <span class="keyword">end</span>
0634     
0635     <span class="comment">% See comment about statsfun above: the x and store passed to statsfun</span>
0636     <span class="comment">% are that of the most recently accepted point after the iteration</span>
0637     <span class="comment">% fully executed.</span>
0638     stats = <a href="../../../manopt/privatetools/applyStatsfun.html" class="code" title="function stats = applyStatsfun(problem, x, storedb, options, stats)">applyStatsfun</a>(problem, x, storedb, options, stats);
0639     
0640 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 24-Jun-2014 22:57:43 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>