<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of steepestdescent</title>
  <meta name="keywords" content="steepestdescent">
  <meta name="description" content="Steepest descent (gradient descent) minimization algorithm for Manopt.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">solvers</a> &gt; <a href="index.html">steepestdescent</a> &gt; steepestdescent.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\solvers\steepestdescent&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>steepestdescent
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Steepest descent (gradient descent) minimization algorithm for Manopt.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [x, cost, info, options] = steepestdescent(problem, x, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Steepest descent (gradient descent) minimization algorithm for Manopt.

 function [x, cost, info, options] = steepestdescent(problem)
 function [x, cost, info, options] = steepestdescent(problem, x0)
 function [x, cost, info, options] = steepestdescent(problem, x0, options)
 function [x, cost, info, options] = steepestdescent(problem, [], options)

 Apply the steepest descent minimization algorithm to the problem defined
 in the problem structure, starting at x0 if it is provided (otherwise, at
 a random point on the manifold). To specify options whilst not specifying
 an initial guess, give x0 as [] (the empty matrix).

 In most of the examples bundled with the toolbox (see link below), the
 solver can be replaced by the present one if need be.

 The outputs x and cost are the best reached point on the manifold and its
 cost. The struct-array info contains information about the iterations:
   iter : the iteration number (0 for the initial guess)
   cost : cost value
   time : elapsed time in seconds
   gradnorm : Riemannian norm of the gradient
   stepsize : norm of the last tangent vector retracted
   linesearch : information logged by options.linesearch
   And possibly additional information logged by options.statsfun.
 For example, type [info.gradnorm] to obtain a vector of the successive
 gradient norms reached.

 The options structure is used to overwrite the default values. All
 options have a default value and are hence optional. To force an option
 value, pass an options structure with a field options.optionname, where
 optionname is one of the following and the default value is indicated
 between parentheses:

   tolgradnorm (1e-6)
       The algorithm terminates if the norm of the gradient drops below this.
   maxiter (1000)
       The algorithm terminates if maxiter iterations have been executed.
   maxtime (Inf)
       The algorithm terminates if maxtime seconds elapsed.
   minstepsize (1e-10)
       The algorithm terminates if the linesearch returns a displacement
       vector (to be retracted) smaller in norm than this value.
   linesearch (@linesearch or @linesearch_hint)
       Function handle to a line search function. The options structure is
       passed to the line search too, so you can pass it parameters. See
       each line search's documentation for info. Another available line
       search in manopt is @linesearch_adaptive, in
       /manopt/linesearch/linesearch_adaptive.m
       If the problem structure includes a line search hint, then the
       default line search used is @linesearch_hint.
   statsfun (none)
       Function handle to a function that will be called after each
       iteration to provide the opportunity to log additional statistics.
       They will be returned in the info struct. See the generic Manopt
       documentation about solvers for further information.
   stopfun (none)
       Function handle to a function that will be called at each iteration
       to provide the opportunity to specify additional stopping criteria.
       See the generic Manopt documentation about solvers for further
       information.
   verbosity (3)
       Integer number used to tune the amount of output the algorithm
       generates during execution (mostly as text in the command window).
       The higher, the more output. 0 means silent.
   storedepth (2)
       Maximum number of different points x of the manifold for which a
       store structure will be kept in memory in the storedb for caching.
       For the SD algorithm, a store depth of 2 should always be
       sufficient.
   hook (none)
       A function handle which allows the user to change the current point
       x at the beginning of each iteration, before the stopping criterion
       is evaluated. See applyHook for help on how to use this option.


 See also: conjugategradient trustregions manopt/solvers/linesearch manopt/examples</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="../../../manopt/core/applyHook.html" class="code" title="function [newx, newkey, info, hooked] = applyHook(problem, x, storedb, key, options, info, last)">applyHook</a>	Apply the hook function to possibly replace the current x (for solvers).</li><li><a href="../../../manopt/core/applyStatsfun.html" class="code" title="function stats = applyStatsfun(problem, x, storedb, key, options, stats)">applyStatsfun</a>	Apply the statsfun function to a stats structure (for solvers).</li><li><a href="../../../manopt/core/canGetApproxGradient.html" class="code" title="function candoit = canGetApproxGradient(problem)">canGetApproxGradient</a>	Checks whether an approximate gradient can be computed for this problem.</li><li><a href="../../../manopt/core/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>	Checks whether the cost function can be computed for a problem structure.</li><li><a href="../../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>	Checks whether the gradient can be computed for a problem structure.</li><li><a href="../../../manopt/core/canGetLinesearch.html" class="code" title="function candoit = canGetLinesearch(problem)">canGetLinesearch</a>	Checks whether the problem structure can give a line-search a hint.</li><li><a href="../../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>	Computes the cost function and the gradient at x in one call if possible.</li><li><a href="../../../manopt/core/getGlobalDefaults.html" class="code" title="function opts = getGlobalDefaults()">getGlobalDefaults</a>	Returns a structure with default option values for Manopt.</li><li><a href="../../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts_sub, opts_master)">mergeOptions</a>	Merges two options structures with one having precedence over the other.</li><li><a href="../../../manopt/core/stoppingcriterion.html" class="code" title="function [stop, reason] = stoppingcriterion(problem, x, options, info, last)">stoppingcriterion</a>	Checks for standard stopping criteria, as a helper to solvers.</li><li><a href="../../../manopt/solvers/gradientapproximations/approxgradientFD.html" class="code" title="function gradfun = approxgradientFD(problem, options)">approxgradientFD</a>	Gradient approx. fnctn handle based on finite differences of the cost.</li><li><a href="../../../manopt/solvers/linesearch/linesearch.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch(problem, x, d, f0, df0, options, storedb, key)">linesearch</a>	Standard line-search algorithm (step size selection) for descent methods.</li><li><a href="../../../manopt/solvers/linesearch/linesearch_hint.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_hint(problem, x, d, f0, df0, options, storedb, key)">linesearch_hint</a>	Armijo line-search based on the line-search hint in the problem structure.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function stats = savestats()</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [x, cost, info, options] = steepestdescent(problem, x, options)</a>
0002 <span class="comment">% Steepest descent (gradient descent) minimization algorithm for Manopt.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function [x, cost, info, options] = steepestdescent(problem)</span>
0005 <span class="comment">% function [x, cost, info, options] = steepestdescent(problem, x0)</span>
0006 <span class="comment">% function [x, cost, info, options] = steepestdescent(problem, x0, options)</span>
0007 <span class="comment">% function [x, cost, info, options] = steepestdescent(problem, [], options)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Apply the steepest descent minimization algorithm to the problem defined</span>
0010 <span class="comment">% in the problem structure, starting at x0 if it is provided (otherwise, at</span>
0011 <span class="comment">% a random point on the manifold). To specify options whilst not specifying</span>
0012 <span class="comment">% an initial guess, give x0 as [] (the empty matrix).</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% In most of the examples bundled with the toolbox (see link below), the</span>
0015 <span class="comment">% solver can be replaced by the present one if need be.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% The outputs x and cost are the best reached point on the manifold and its</span>
0018 <span class="comment">% cost. The struct-array info contains information about the iterations:</span>
0019 <span class="comment">%   iter : the iteration number (0 for the initial guess)</span>
0020 <span class="comment">%   cost : cost value</span>
0021 <span class="comment">%   time : elapsed time in seconds</span>
0022 <span class="comment">%   gradnorm : Riemannian norm of the gradient</span>
0023 <span class="comment">%   stepsize : norm of the last tangent vector retracted</span>
0024 <span class="comment">%   linesearch : information logged by options.linesearch</span>
0025 <span class="comment">%   And possibly additional information logged by options.statsfun.</span>
0026 <span class="comment">% For example, type [info.gradnorm] to obtain a vector of the successive</span>
0027 <span class="comment">% gradient norms reached.</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% The options structure is used to overwrite the default values. All</span>
0030 <span class="comment">% options have a default value and are hence optional. To force an option</span>
0031 <span class="comment">% value, pass an options structure with a field options.optionname, where</span>
0032 <span class="comment">% optionname is one of the following and the default value is indicated</span>
0033 <span class="comment">% between parentheses:</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%   tolgradnorm (1e-6)</span>
0036 <span class="comment">%       The algorithm terminates if the norm of the gradient drops below this.</span>
0037 <span class="comment">%   maxiter (1000)</span>
0038 <span class="comment">%       The algorithm terminates if maxiter iterations have been executed.</span>
0039 <span class="comment">%   maxtime (Inf)</span>
0040 <span class="comment">%       The algorithm terminates if maxtime seconds elapsed.</span>
0041 <span class="comment">%   minstepsize (1e-10)</span>
0042 <span class="comment">%       The algorithm terminates if the linesearch returns a displacement</span>
0043 <span class="comment">%       vector (to be retracted) smaller in norm than this value.</span>
0044 <span class="comment">%   linesearch (@linesearch or @linesearch_hint)</span>
0045 <span class="comment">%       Function handle to a line search function. The options structure is</span>
0046 <span class="comment">%       passed to the line search too, so you can pass it parameters. See</span>
0047 <span class="comment">%       each line search's documentation for info. Another available line</span>
0048 <span class="comment">%       search in manopt is @linesearch_adaptive, in</span>
0049 <span class="comment">%       /manopt/linesearch/linesearch_adaptive.m</span>
0050 <span class="comment">%       If the problem structure includes a line search hint, then the</span>
0051 <span class="comment">%       default line search used is @linesearch_hint.</span>
0052 <span class="comment">%   statsfun (none)</span>
0053 <span class="comment">%       Function handle to a function that will be called after each</span>
0054 <span class="comment">%       iteration to provide the opportunity to log additional statistics.</span>
0055 <span class="comment">%       They will be returned in the info struct. See the generic Manopt</span>
0056 <span class="comment">%       documentation about solvers for further information.</span>
0057 <span class="comment">%   stopfun (none)</span>
0058 <span class="comment">%       Function handle to a function that will be called at each iteration</span>
0059 <span class="comment">%       to provide the opportunity to specify additional stopping criteria.</span>
0060 <span class="comment">%       See the generic Manopt documentation about solvers for further</span>
0061 <span class="comment">%       information.</span>
0062 <span class="comment">%   verbosity (3)</span>
0063 <span class="comment">%       Integer number used to tune the amount of output the algorithm</span>
0064 <span class="comment">%       generates during execution (mostly as text in the command window).</span>
0065 <span class="comment">%       The higher, the more output. 0 means silent.</span>
0066 <span class="comment">%   storedepth (2)</span>
0067 <span class="comment">%       Maximum number of different points x of the manifold for which a</span>
0068 <span class="comment">%       store structure will be kept in memory in the storedb for caching.</span>
0069 <span class="comment">%       For the SD algorithm, a store depth of 2 should always be</span>
0070 <span class="comment">%       sufficient.</span>
0071 <span class="comment">%   hook (none)</span>
0072 <span class="comment">%       A function handle which allows the user to change the current point</span>
0073 <span class="comment">%       x at the beginning of each iteration, before the stopping criterion</span>
0074 <span class="comment">%       is evaluated. See applyHook for help on how to use this option.</span>
0075 <span class="comment">%</span>
0076 <span class="comment">%</span>
0077 <span class="comment">% See also: conjugategradient trustregions manopt/solvers/linesearch manopt/examples</span>
0078 
0079 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0080 <span class="comment">% Original author: Nicolas Boumal, Dec. 30, 2012.</span>
0081 <span class="comment">% Contributors:</span>
0082 <span class="comment">% Change log:</span>
0083 <span class="comment">%</span>
0084 <span class="comment">%   April 3, 2015 (NB):</span>
0085 <span class="comment">%       Works with the new StoreDB class system.</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%   Aug. 2, 2018 (NB):</span>
0088 <span class="comment">%       Now using storedb.remove() to keep the cache lean.</span>
0089 <span class="comment">%</span>
0090 <span class="comment">%   July 19, 2020 (NB):</span>
0091 <span class="comment">%       Added support for options.hook.</span>
0092 
0093     
0094     <span class="comment">% Verify that the problem description is sufficient for the solver.</span>
0095     <span class="keyword">if</span> ~<a href="../../../manopt/core/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>(problem)
0096         warning(<span class="string">'manopt:getCost'</span>, <span class="keyword">...</span>
0097                 <span class="string">'No cost provided. The algorithm will likely abort.'</span>);
0098     <span class="keyword">end</span>
0099     <span class="keyword">if</span> ~<a href="../../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>(problem) &amp;&amp; ~<a href="../../../manopt/core/canGetApproxGradient.html" class="code" title="function candoit = canGetApproxGradient(problem)">canGetApproxGradient</a>(problem)
0100         <span class="comment">% Note: we do not give a warning if an approximate gradient is</span>
0101         <span class="comment">% explicitly given in the problem description, as in that case the</span>
0102         <span class="comment">% user seems to be aware of the issue.</span>
0103         warning(<span class="string">'manopt:getGradient:approx'</span>, <span class="keyword">...</span>
0104                [<span class="string">'No gradient provided. Using an FD approximation instead (slow).\n'</span> <span class="keyword">...</span>
0105                 <span class="string">'It may be necessary to increase options.tolgradnorm.\n'</span> <span class="keyword">...</span>
0106                 <span class="string">'To disable this warning: warning(''off'', ''manopt:getGradient:approx'')'</span>]);
0107         problem.approxgrad = <a href="../../../manopt/solvers/gradientapproximations/approxgradientFD.html" class="code" title="function gradfun = approxgradientFD(problem, options)">approxgradientFD</a>(problem);
0108     <span class="keyword">end</span>
0109     
0110     <span class="comment">% Set local defaults here.</span>
0111     localdefaults.minstepsize = 1e-10;
0112     localdefaults.maxiter = 1000;
0113     localdefaults.tolgradnorm = 1e-6;
0114     
0115     <span class="comment">% Depending on whether the problem structure specifies a hint for</span>
0116     <span class="comment">% line-search algorithms, choose a default line-search that works on</span>
0117     <span class="comment">% its own (typical) or that uses the hint.</span>
0118     <span class="keyword">if</span> ~<a href="../../../manopt/core/canGetLinesearch.html" class="code" title="function candoit = canGetLinesearch(problem)">canGetLinesearch</a>(problem)
0119         localdefaults.linesearch = @<a href="../../../manopt/solvers/linesearch/linesearch.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch(problem, x, d, f0, df0, options, storedb, key)">linesearch</a>;
0120     <span class="keyword">else</span>
0121         localdefaults.linesearch = @<a href="../../../manopt/solvers/linesearch/linesearch_hint.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_hint(problem, x, d, f0, df0, options, storedb, key)">linesearch_hint</a>;
0122     <span class="keyword">end</span>
0123     
0124     <span class="comment">% Merge global and local defaults, then merge w/ user options, if any.</span>
0125     localdefaults = <a href="../../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts_sub, opts_master)">mergeOptions</a>(<a href="../../../manopt/core/getGlobalDefaults.html" class="code" title="function opts = getGlobalDefaults()">getGlobalDefaults</a>(), localdefaults);
0126     <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>) || isempty(options)
0127         options = struct();
0128     <span class="keyword">end</span>
0129     options = <a href="../../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts_sub, opts_master)">mergeOptions</a>(localdefaults, options);
0130     
0131     timetic = tic();
0132     
0133     <span class="comment">% If no initial point x is given by the user, generate one at random.</span>
0134     <span class="keyword">if</span> ~exist(<span class="string">'x'</span>, <span class="string">'var'</span>) || isempty(x)
0135         x = problem.M.rand();
0136     <span class="keyword">end</span>
0137     
0138     <span class="comment">% Create a store database and get a key for the current x.</span>
0139     storedb = <a href="../../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>(options.storedepth);
0140     key = storedb.getNewKey();
0141     
0142     <span class="comment">% Compute objective-related quantities for x.</span>
0143     [cost, grad] = <a href="../../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>(problem, x, storedb, key);
0144     gradnorm = problem.M.norm(x, grad);
0145     
0146     <span class="comment">% Iteration counter.</span>
0147     <span class="comment">% At any point, iter is the number of fully executed iterations so far.</span>
0148     iter = 0;
0149     
0150     <span class="comment">% Save stats in a struct array info, and preallocate.</span>
0151     stats = <a href="#_sub1" class="code" title="subfunction stats = savestats()">savestats</a>();
0152     info(1) = stats;
0153     info(min(10000, options.maxiter+1)).iter = [];
0154     
0155     <span class="keyword">if</span> options.verbosity &gt;= 2
0156         fprintf(<span class="string">' iter\t               cost val\t    grad. norm\n'</span>);
0157     <span class="keyword">end</span>
0158     
0159     <span class="comment">% Start iterating until stopping criterion triggers.</span>
0160     <span class="keyword">while</span> true
0161 
0162         <span class="comment">% Display iteration information.</span>
0163         <span class="keyword">if</span> options.verbosity &gt;= 2
0164             fprintf(<span class="string">'%5d\t%+.16e\t%.8e\n'</span>, iter, cost, gradnorm);
0165         <span class="keyword">end</span>
0166         
0167         <span class="comment">% Start timing this iteration.</span>
0168         timetic = tic();
0169 
0170         <span class="comment">% Apply the hook function if there is one: this allows external code to</span>
0171         <span class="comment">% move x to another point. If the point is changed (indicated by a true</span>
0172         <span class="comment">% value for the boolean 'hooked'), we update our knowledge about x.</span>
0173         [x, key, info, hooked] = <a href="../../../manopt/core/applyHook.html" class="code" title="function [newx, newkey, info, hooked] = applyHook(problem, x, storedb, key, options, info, last)">applyHook</a>(problem, x, storedb, key, <span class="keyword">...</span>
0174                                                     options, info, iter+1);
0175         <span class="keyword">if</span> hooked
0176             [cost, grad] = <a href="../../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>(problem, x, storedb, key);
0177             gradnorm = problem.M.norm(x, grad);
0178         <span class="keyword">end</span>
0179         
0180         <span class="comment">% Run standard stopping criterion checks.</span>
0181         [stop, reason] = <a href="../../../manopt/core/stoppingcriterion.html" class="code" title="function [stop, reason] = stoppingcriterion(problem, x, options, info, last)">stoppingcriterion</a>(problem, x, options, <span class="keyword">...</span>
0182                                                              info, iter+1);
0183         
0184         <span class="comment">% If none triggered, run specific stopping criterion check.</span>
0185         <span class="keyword">if</span> ~stop &amp;&amp; stats.stepsize &lt; options.minstepsize
0186             stop = true;
0187             reason = sprintf([<span class="string">'Last stepsize smaller than minimum '</span>  <span class="keyword">...</span>
0188                               <span class="string">'allowed; options.minstepsize = %g.'</span>], <span class="keyword">...</span>
0189                               options.minstepsize);
0190         <span class="keyword">end</span>
0191     
0192         <span class="keyword">if</span> stop
0193             <span class="keyword">if</span> options.verbosity &gt;= 1
0194                 fprintf([reason <span class="string">'\n'</span>]);
0195             <span class="keyword">end</span>
0196             <span class="keyword">break</span>;
0197         <span class="keyword">end</span>
0198 
0199         <span class="comment">% Pick the descent direction as minus the gradient.</span>
0200         desc_dir = problem.M.lincomb(x, -1, grad);
0201         
0202         <span class="comment">% Execute the line search.</span>
0203         [stepsize, newx, newkey, lsstats] = options.linesearch( <span class="keyword">...</span>
0204                              problem, x, desc_dir, cost, -gradnorm^2, <span class="keyword">...</span>
0205                              options, storedb, key);
0206         
0207         <span class="comment">% Compute the new cost-related quantities for x</span>
0208         [newcost, newgrad] = <a href="../../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>(problem, newx, storedb, newkey);
0209         newgradnorm = problem.M.norm(newx, newgrad);
0210         
0211         <span class="comment">% Transfer iterate info, remove cache from previous x.</span>
0212         storedb.removefirstifdifferent(key, newkey);
0213         x = newx;
0214         key = newkey;
0215         cost = newcost;
0216         grad = newgrad;
0217         gradnorm = newgradnorm;
0218         
0219         <span class="comment">% Make sure we don't use too much memory for the store database.</span>
0220         storedb.purge();
0221         
0222         <span class="comment">% iter is the number of iterations we have accomplished.</span>
0223         iter = iter + 1;
0224         
0225         <span class="comment">% Log statistics for freshly executed iteration.</span>
0226         stats = <a href="#_sub1" class="code" title="subfunction stats = savestats()">savestats</a>();
0227         info(iter+1) = stats;
0228         
0229     <span class="keyword">end</span>
0230     
0231     
0232     info = info(1:iter+1);
0233 
0234     <span class="keyword">if</span> options.verbosity &gt;= 1
0235         fprintf(<span class="string">'Total time is %f [s] (excludes statsfun)\n'</span>, <span class="keyword">...</span>
0236                 info(end).time);
0237     <span class="keyword">end</span>
0238     
0239     
0240     
0241     <span class="comment">% Routine in charge of collecting the current iteration stats.</span>
0242     <a name="_sub1" href="#_subfunctions" class="code">function stats = savestats()</a>
0243         stats.iter = iter;
0244         stats.cost = cost;
0245         stats.gradnorm = gradnorm;
0246         <span class="keyword">if</span> iter == 0
0247             stats.stepsize = NaN;
0248             stats.time = toc(timetic);
0249             stats.linesearch = [];
0250         <span class="keyword">else</span>
0251             stats.stepsize = stepsize;
0252             stats.time = info(iter).time + toc(timetic);
0253             stats.linesearch = lsstats;
0254         <span class="keyword">end</span>
0255         stats = <a href="../../../manopt/core/applyStatsfun.html" class="code" title="function stats = applyStatsfun(problem, x, storedb, key, options, stats)">applyStatsfun</a>(problem, x, storedb, key, options, stats);
0256     <span class="keyword">end</span>
0257     
0258 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 05-Sep-2021 17:57:00 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>