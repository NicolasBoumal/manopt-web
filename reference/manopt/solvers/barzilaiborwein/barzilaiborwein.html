<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of barzilaiborwein</title>
  <meta name="keywords" content="barzilaiborwein">
  <meta name="description" content="Riemannian Barzilai-Borwein solver with non-monotone line-search.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="#">solvers</a> &gt; <a href="index.html">barzilaiborwein</a> &gt; barzilaiborwein.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\solvers\barzilaiborwein&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>barzilaiborwein
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Riemannian Barzilai-Borwein solver with non-monotone line-search.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [x, cost, info, options] = barzilaiborwein(problem, x, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Riemannian Barzilai-Borwein solver with non-monotone line-search.

 function [x, cost, info, options] = barzilaiborwein(problem)
 function [x, cost, info, options] = barzilaiborwein(problem, x0)
 function [x, cost, info, options] = barzilaiborwein(problem, x0, options)
 function [x, cost, info, options] = barzilaiborwein(problem, [], options)

 Apply the Barzilai-Borwein minimization algorithm to the problem defined
 in the problem structure, starting at x0 if it is provided (otherwise, at
 a random point on the manifold). To specify options whilst not specifying
 an initial guess, give x0 as [] (the empty matrix).

 The algorithm uses its own special non-monotone line-search strategy.
 Therefore, no lin-search algorithm should be specified in the problem
 structure or in the options structure.

 In most of the examples bundled with the toolbox (see link below), the
 solver can be replaced by the present one if need be.

 The outputs x and cost are the last reached point on the manifold and its
 cost. This is not necessarily the best point generated since the method
 is not monotone. The struct-array info contains information about the
 iterations:
   iter : the iteration number (0 for the initial guess)
   cost : cost value
   time : elapsed time in seconds
   gradnorm : Riemannian norm of the gradient
   stepsize : norm of the last tangent vector retracted
   linesearch : information logged by the line-search algorithm
   And possibly additional information logged by options.statsfun.
 For example, type [info.gradnorm] to obtain a vector of the successive
 gradient norms reached.

 The options structure is used to overwrite the default values. All
 options have a default value and are hence optional. To force an option
 value, pass an options structure with a field options.optionname, where
 optionname is one of the following and the default value is indicated
 between parentheses:

   tolgradnorm (1e-6)
       The algorithm terminates if the norm of the gradient drops below this.
   maxiter (1000)
       The algorithm terminates if maxiter iterations have been executed.
   maxtime (Inf)
       The algorithm terminates if maxtime seconds elapsed.
   minstepsize (1e-10)
       The algorithm terminates if the linesearch returns a displacement
       vector (to be retracted) smaller in norm than this value.
   linesearch (@linesearch_hint)
       This option should not be changed, as the present solver has its
       own dedicated line-search strategy.
   strategy ('direct')
       The strategy used for the Barzilai-Borwein stepsize
       'direct', compute the direct step &lt;s_k,s_k&gt;/&lt;s_k,y_k&gt;
       'inverse', compute the inverse step &lt;s_k,y_k&gt;/&lt;y_k,y_k&gt;
       'alternate', alternates between direct and inverse step
   lambdamax (1e3)
       The maximum stepsize allowed by the Barzilai-Borwein method
   lambdamin (1e-3)
       The minimum stepsize allowed by the Barzilai-Borwein method
   lambda0 (1/10)
       The initial stepsize of the Barzilai-Borwein method
   ls_nmsteps (10)
       The non-monotone line-search checks a sufficient decrease with respect
       to the previous ls_nmsteps objective function values.
   statsfun (none)
       Function handle to a function that will be called after each
       iteration to provide the opportunity to log additional statistics.
       They will be returned in the info struct. See the generic Manopt
       documentation about solvers for further information.
   stopfun (none)
       Function handle to a function that will be called at each iteration
       to provide the opportunity to specify additional stopping criteria.
       See the generic Manopt documentation about solvers for further
       information.
   verbosity (3)
       Integer number used to tune the amount of output the algorithm
       generates during execution (mostly as text in the command window).
       The higher, the more output. 0 means silent.
   storedepth (2)
       Maximum number of different points x of the manifold for which a
       store structure will be kept in memory in the storedb. If the
       caching features of Manopt are not used, this is irrelevant. For
       this algorithm, a store depth of 2 should always be sufficient.
   

 The implementation of the Barzilai-Borwein method is based on the paper:

 B. Iannazzo, M. Porcelli, &quot;The Riemannian Barzilai-Borwein method with 
 nonmonotone line-search and the matrix geometric mean computation&quot;,
 IMA Journal of Numerical Analysis, to appear, https://doi.org/10.1093/imanum/drx015.

 See also: steepestdescent conjugategradient trustregions</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="../../../manopt/core/applyStatsfun.html" class="code" title="function stats = applyStatsfun(problem, x, storedb, key, options, stats)">applyStatsfun</a>	Apply the statsfun function to a stats structure (for solvers).</li><li><a href="../../../manopt/core/canGetApproxGradient.html" class="code" title="function candoit = canGetApproxGradient(problem)">canGetApproxGradient</a>	Checks whether an approximate gradient can be computed for this problem.</li><li><a href="../../../manopt/core/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>	Checks whether the cost function can be computed for a problem structure.</li><li><a href="../../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>	Checks whether the gradient can be computed for a problem structure.</li><li><a href="../../../manopt/core/canGetLinesearch.html" class="code" title="function candoit = canGetLinesearch(problem)">canGetLinesearch</a>	Checks whether the problem structure can give a line-search a hint.</li><li><a href="../../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>	Computes the cost function and the gradient at x in one call if possible.</li><li><a href="../../../manopt/core/getGlobalDefaults.html" class="code" title="function opts = getGlobalDefaults()">getGlobalDefaults</a>	Returns a structure with default option values for Manopt.</li><li><a href="../../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>	Merges two options structures with one having precedence over the other.</li><li><a href="../../../manopt/core/stoppingcriterion.html" class="code" title="function [stop, reason] = stoppingcriterion(problem, x, options, info, last)">stoppingcriterion</a>	Checks for standard stopping criteria, as a helper to solvers.</li><li><a href="../../../manopt/solvers/gradientapproximations/approxgradientFD.html" class="code" title="function gradfun = approxgradientFD(problem, options)">approxgradientFD</a>	Gradient approx. fnctn handle based on finite differences of the cost.</li><li><a href="../../../manopt/solvers/linesearch/linesearch_hint.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_hint(problem, x, d, f0, df0, options, storedb, key)">linesearch_hint</a>	Armijo line-search based on the line-search hint in the problem structure.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function stats = savestats()</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [x, cost, info, options] = barzilaiborwein(problem, x, options)</a>
0002 <span class="comment">% Riemannian Barzilai-Borwein solver with non-monotone line-search.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% function [x, cost, info, options] = barzilaiborwein(problem)</span>
0005 <span class="comment">% function [x, cost, info, options] = barzilaiborwein(problem, x0)</span>
0006 <span class="comment">% function [x, cost, info, options] = barzilaiborwein(problem, x0, options)</span>
0007 <span class="comment">% function [x, cost, info, options] = barzilaiborwein(problem, [], options)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Apply the Barzilai-Borwein minimization algorithm to the problem defined</span>
0010 <span class="comment">% in the problem structure, starting at x0 if it is provided (otherwise, at</span>
0011 <span class="comment">% a random point on the manifold). To specify options whilst not specifying</span>
0012 <span class="comment">% an initial guess, give x0 as [] (the empty matrix).</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% The algorithm uses its own special non-monotone line-search strategy.</span>
0015 <span class="comment">% Therefore, no lin-search algorithm should be specified in the problem</span>
0016 <span class="comment">% structure or in the options structure.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% In most of the examples bundled with the toolbox (see link below), the</span>
0019 <span class="comment">% solver can be replaced by the present one if need be.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% The outputs x and cost are the last reached point on the manifold and its</span>
0022 <span class="comment">% cost. This is not necessarily the best point generated since the method</span>
0023 <span class="comment">% is not monotone. The struct-array info contains information about the</span>
0024 <span class="comment">% iterations:</span>
0025 <span class="comment">%   iter : the iteration number (0 for the initial guess)</span>
0026 <span class="comment">%   cost : cost value</span>
0027 <span class="comment">%   time : elapsed time in seconds</span>
0028 <span class="comment">%   gradnorm : Riemannian norm of the gradient</span>
0029 <span class="comment">%   stepsize : norm of the last tangent vector retracted</span>
0030 <span class="comment">%   linesearch : information logged by the line-search algorithm</span>
0031 <span class="comment">%   And possibly additional information logged by options.statsfun.</span>
0032 <span class="comment">% For example, type [info.gradnorm] to obtain a vector of the successive</span>
0033 <span class="comment">% gradient norms reached.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% The options structure is used to overwrite the default values. All</span>
0036 <span class="comment">% options have a default value and are hence optional. To force an option</span>
0037 <span class="comment">% value, pass an options structure with a field options.optionname, where</span>
0038 <span class="comment">% optionname is one of the following and the default value is indicated</span>
0039 <span class="comment">% between parentheses:</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%   tolgradnorm (1e-6)</span>
0042 <span class="comment">%       The algorithm terminates if the norm of the gradient drops below this.</span>
0043 <span class="comment">%   maxiter (1000)</span>
0044 <span class="comment">%       The algorithm terminates if maxiter iterations have been executed.</span>
0045 <span class="comment">%   maxtime (Inf)</span>
0046 <span class="comment">%       The algorithm terminates if maxtime seconds elapsed.</span>
0047 <span class="comment">%   minstepsize (1e-10)</span>
0048 <span class="comment">%       The algorithm terminates if the linesearch returns a displacement</span>
0049 <span class="comment">%       vector (to be retracted) smaller in norm than this value.</span>
0050 <span class="comment">%   linesearch (@linesearch_hint)</span>
0051 <span class="comment">%       This option should not be changed, as the present solver has its</span>
0052 <span class="comment">%       own dedicated line-search strategy.</span>
0053 <span class="comment">%   strategy ('direct')</span>
0054 <span class="comment">%       The strategy used for the Barzilai-Borwein stepsize</span>
0055 <span class="comment">%       'direct', compute the direct step &lt;s_k,s_k&gt;/&lt;s_k,y_k&gt;</span>
0056 <span class="comment">%       'inverse', compute the inverse step &lt;s_k,y_k&gt;/&lt;y_k,y_k&gt;</span>
0057 <span class="comment">%       'alternate', alternates between direct and inverse step</span>
0058 <span class="comment">%   lambdamax (1e3)</span>
0059 <span class="comment">%       The maximum stepsize allowed by the Barzilai-Borwein method</span>
0060 <span class="comment">%   lambdamin (1e-3)</span>
0061 <span class="comment">%       The minimum stepsize allowed by the Barzilai-Borwein method</span>
0062 <span class="comment">%   lambda0 (1/10)</span>
0063 <span class="comment">%       The initial stepsize of the Barzilai-Borwein method</span>
0064 <span class="comment">%   ls_nmsteps (10)</span>
0065 <span class="comment">%       The non-monotone line-search checks a sufficient decrease with respect</span>
0066 <span class="comment">%       to the previous ls_nmsteps objective function values.</span>
0067 <span class="comment">%   statsfun (none)</span>
0068 <span class="comment">%       Function handle to a function that will be called after each</span>
0069 <span class="comment">%       iteration to provide the opportunity to log additional statistics.</span>
0070 <span class="comment">%       They will be returned in the info struct. See the generic Manopt</span>
0071 <span class="comment">%       documentation about solvers for further information.</span>
0072 <span class="comment">%   stopfun (none)</span>
0073 <span class="comment">%       Function handle to a function that will be called at each iteration</span>
0074 <span class="comment">%       to provide the opportunity to specify additional stopping criteria.</span>
0075 <span class="comment">%       See the generic Manopt documentation about solvers for further</span>
0076 <span class="comment">%       information.</span>
0077 <span class="comment">%   verbosity (3)</span>
0078 <span class="comment">%       Integer number used to tune the amount of output the algorithm</span>
0079 <span class="comment">%       generates during execution (mostly as text in the command window).</span>
0080 <span class="comment">%       The higher, the more output. 0 means silent.</span>
0081 <span class="comment">%   storedepth (2)</span>
0082 <span class="comment">%       Maximum number of different points x of the manifold for which a</span>
0083 <span class="comment">%       store structure will be kept in memory in the storedb. If the</span>
0084 <span class="comment">%       caching features of Manopt are not used, this is irrelevant. For</span>
0085 <span class="comment">%       this algorithm, a store depth of 2 should always be sufficient.</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%</span>
0088 <span class="comment">% The implementation of the Barzilai-Borwein method is based on the paper:</span>
0089 <span class="comment">%</span>
0090 <span class="comment">% B. Iannazzo, M. Porcelli, &quot;The Riemannian Barzilai-Borwein method with</span>
0091 <span class="comment">% nonmonotone line-search and the matrix geometric mean computation&quot;,</span>
0092 <span class="comment">% IMA Journal of Numerical Analysis, to appear, https://doi.org/10.1093/imanum/drx015.</span>
0093 <span class="comment">%</span>
0094 <span class="comment">% See also: steepestdescent conjugategradient trustregions</span>
0095 
0096 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0097 <span class="comment">% Original author: Margherita Porcelli, May 31, 2017</span>
0098 <span class="comment">% Contributors: Nicolas Boumal, Bruno Iannazzo</span>
0099 <span class="comment">% Change log:</span>
0100 
0101     
0102     <span class="comment">% Verify that the problem description is sufficient for the solver.</span>
0103     <span class="keyword">if</span> ~<a href="../../../manopt/core/canGetCost.html" class="code" title="function candoit = canGetCost(problem)">canGetCost</a>(problem)
0104         warning(<span class="string">'manopt:getCost'</span>, <span class="keyword">...</span>
0105                 <span class="string">'No cost provided. The algorithm will likely abort.'</span>);  
0106     <span class="keyword">end</span>
0107     <span class="keyword">if</span> ~<a href="../../../manopt/core/canGetGradient.html" class="code" title="function candoit = canGetGradient(problem)">canGetGradient</a>(problem) &amp;&amp; ~<a href="../../../manopt/core/canGetApproxGradient.html" class="code" title="function candoit = canGetApproxGradient(problem)">canGetApproxGradient</a>(problem)
0108         <span class="comment">% Note: we do not give a warning if an approximate gradient is</span>
0109         <span class="comment">% explicitly given in the problem description, as in that case the</span>
0110         <span class="comment">% user seems to be aware of the issue.</span>
0111         warning(<span class="string">'manopt:getGradient:approx'</span>, <span class="keyword">...</span>
0112                [<span class="string">'No gradient provided. Using an FD approximation instead (slow).\n'</span> <span class="keyword">...</span>
0113                 <span class="string">'It may be necessary to increase options.tolgradnorm.\n'</span> <span class="keyword">...</span>
0114                 <span class="string">'To disable this warning: warning(''off'', ''manopt:getGradient:approx'')'</span>]);
0115         problem.approxgrad = <a href="../../../manopt/solvers/gradientapproximations/approxgradientFD.html" class="code" title="function gradfun = approxgradientFD(problem, options)">approxgradientFD</a>(problem);
0116     <span class="keyword">end</span>
0117 
0118     <span class="comment">% Ensure options exists as a structure</span>
0119     <span class="keyword">if</span> ~exist(<span class="string">'options'</span>, <span class="string">'var'</span>) || isempty(options)
0120         options = struct();
0121     <span class="keyword">end</span>
0122     
0123     <span class="comment">% Set local defaults here</span>
0124     localdefaults.minstepsize = 1e-10;
0125     localdefaults.maxiter = 1000;
0126     localdefaults.tolgradnorm = 1e-6;
0127 
0128     <span class="comment">% Upper and lower bound for the Barzilai-Borwein stepsize</span>
0129     localdefaults.lambdamax = 1e3;
0130     localdefaults.lambdamin = 1e-3;
0131     <span class="comment">% Initial Barzilai-Borwein stepsize</span>
0132     localdefaults.lambda0 = 1/10;
0133 
0134     <span class="comment">% Barzilai-Borwein strategy (direct, inverse or alternate)</span>
0135     localdefaults.strategy = <span class="string">'direct'</span>;
0136 
0137     <span class="comment">% Line-search parameters</span>
0138     <span class="comment">% 1) Make sure the user didn't try to define a line search</span>
0139     <span class="keyword">if</span> <a href="../../../manopt/core/canGetLinesearch.html" class="code" title="function candoit = canGetLinesearch(problem)">canGetLinesearch</a>(problem) || isfield(options, <span class="string">'linesearch'</span>)
0140         error(<span class="string">'manopt:BB:ls'</span>, <span class="keyword">...</span>
0141               [<span class="string">'The problem structure may not specify a line-search '</span> <span class="keyword">...</span>
0142                <span class="string">'hint for the BB solver,\nand the options structure '</span> <span class="keyword">...</span>
0143                <span class="string">'may not specify a line-search algorithm for BB.'</span>]);
0144     <span class="keyword">end</span>
0145     <span class="comment">% 2) Define the line-search parameters</span>
0146     problem.linesearch = @(x, d, storedb, key) 1;
0147     options.linesearch = @<a href="../../../manopt/solvers/linesearch/linesearch_hint.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_hint(problem, x, d, f0, df0, options, storedb, key)">linesearch_hint</a>;
0148     <span class="comment">% The Armijo sufficient decrease parameter</span>
0149     localdefaults.ls_suff_decr = 1e-4;
0150     <span class="comment">% The previous steps checked in the non-monotone line-search strategy</span>
0151     localdefaults.ls_nmsteps = 10;
0152     
0153     
0154     <span class="comment">% Merge global and local defaults, then merge w/ user options, if any.</span>
0155     localdefaults = <a href="../../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>(<a href="../../../manopt/core/getGlobalDefaults.html" class="code" title="function opts = getGlobalDefaults()">getGlobalDefaults</a>(), localdefaults);
0156     options = <a href="../../../manopt/core/mergeOptions.html" class="code" title="function opts = mergeOptions(opts1, opts2)">mergeOptions</a>(localdefaults, options); 
0157 
0158     
0159     <span class="comment">% Shorthands for some parameters</span>
0160     strategy = options.strategy;
0161     lambdamax = options.lambdamax;
0162     lambdamin = options.lambdamin;
0163     lambda0 = options.lambda0;
0164     
0165     timetic = tic();
0166     
0167     
0168     <span class="comment">% If no initial point x is given by the user, generate one at random.</span>
0169     <span class="keyword">if</span> ~exist(<span class="string">'x'</span>, <span class="string">'var'</span>) || isempty(x)
0170         x = problem.M.rand();
0171     <span class="keyword">end</span>
0172 
0173     <span class="comment">% Create a store database and get a key for the current x</span>
0174     storedb = <a href="../../../manopt/core/StoreDB.html" class="code" title="">StoreDB</a>(options.storedepth);
0175     key = storedb.getNewKey();
0176     
0177     <span class="comment">% Compute objective-related quantities for x</span>
0178     [cost, grad] = <a href="../../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>(problem, x, storedb, key);
0179     gradnorm = problem.M.norm(x, grad);
0180 
0181     <span class="comment">% Some variables below need to store information about iterations. We</span>
0182     <span class="comment">% preallocate for a reasonable amount of intended iterations to avoid</span>
0183     <span class="comment">% memory re-allocations.</span>
0184     mem_init_size = min(10000, options.maxiter+1);
0185     
0186     <span class="comment">% Store the cost value</span>
0187     f = zeros(mem_init_size, 1);
0188     f(1) = cost;
0189     
0190     <span class="comment">% Iteration counter (at any point, iter is the number of fully executed</span>
0191     <span class="comment">% iterations so far)</span>
0192     iter = 0;
0193     
0194     <span class="comment">% Save stats in a struct array info, and preallocate.</span>
0195     stats = <a href="#_sub1" class="code" title="subfunction stats = savestats()">savestats</a>();
0196     info(1) = stats;
0197     info(mem_init_size).iter = [];
0198     
0199     <span class="keyword">if</span> options.verbosity &gt;= 2
0200         fprintf(<span class="string">' iter\t                cost val\t     grad. norm\n'</span>);
0201     <span class="keyword">end</span>
0202 
0203     <span class="comment">% Set the initial Barzilai-Borwein stepsize</span>
0204     lambda = lambda0;
0205 
0206     <span class="comment">% Start iterating until stopping criterion triggers</span>
0207     <span class="keyword">while</span> true
0208 
0209         <span class="comment">% Display iteration information</span>
0210         <span class="keyword">if</span> options.verbosity &gt;= 2
0211             fprintf(<span class="string">'%5d\t%+.16e\t%.8e\n'</span>, iter, cost, gradnorm);
0212         <span class="keyword">end</span>
0213         
0214         <span class="comment">% Start timing this iteration</span>
0215         timetic = tic();
0216         
0217         <span class="comment">% Run standard stopping criterion checks</span>
0218         [stop, reason] = <a href="../../../manopt/core/stoppingcriterion.html" class="code" title="function [stop, reason] = stoppingcriterion(problem, x, options, info, last)">stoppingcriterion</a>(problem, x, options, <span class="keyword">...</span>
0219                                                              info, iter+1);
0220         
0221         <span class="comment">% If none triggered, run specific stopping criterion check</span>
0222         <span class="keyword">if</span> ~stop &amp;&amp; stats.stepsize &lt; options.minstepsize
0223             stop = true;
0224             reason = sprintf([<span class="string">'Last stepsize smaller than minimum '</span>  <span class="keyword">...</span>
0225                               <span class="string">'allowed; options.minstepsize = %g.'</span>], <span class="keyword">...</span>
0226                               options.minstepsize);
0227         <span class="keyword">end</span>
0228     
0229         <span class="keyword">if</span> stop
0230             <span class="keyword">if</span> options.verbosity &gt;= 1
0231                 fprintf([reason <span class="string">'\n'</span>]);
0232             <span class="keyword">end</span>
0233             <span class="keyword">break</span>;
0234         <span class="keyword">end</span>
0235 
0236         <span class="comment">% Pick the descent direction as minus the gradient (scaled)</span>
0237         desc_dir = problem.M.lincomb(x, -lambda, grad);
0238 
0239         <span class="comment">% Execute the nonmonotone line search</span>
0240         k = iter + 1; 
0241         start = max(1, k - options.ls_nmsteps + 1);
0242         
0243         [stepsize, newx, newkey, lsstats] = <span class="keyword">...</span>
0244             options.linesearch(problem, x, desc_dir, max(f(start:k)), <span class="keyword">...</span>
0245                             -lambda * gradnorm^2, options, storedb, key);
0246 
0247         <span class="comment">% Updates the value of lambda</span>
0248         lambda = lambda * lsstats.alpha;
0249 
0250         <span class="comment">% Compute the new cost-related quantities for newx</span>
0251         [newcost, newgrad] = <a href="../../../manopt/core/getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>(problem, newx, storedb, newkey);
0252         newgradnorm = problem.M.norm(newx, newgrad);
0253 
0254         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0255         <span class="comment">% BARZILAI-BORWEIN STRATEGY</span>
0256 
0257         <span class="comment">% Store the cost value</span>
0258         f(iter+2) = newcost;
0259        
0260         <span class="comment">% Transport the old gradient to newx</span>
0261         grad_transp = problem.M.transp(x, newx, grad);
0262 
0263         <span class="comment">% Compute the difference between grandients</span>
0264         Y = problem.M.lincomb(newx, 1, newgrad, -1, grad_transp);
0265 
0266         <span class="comment">% Compute the transported step</span>
0267         Stransp =  problem.M.lincomb(x, -lambda, grad_transp); 
0268 
0269         <span class="comment">% Compute the new Barzilai-Borwein step following the strategy</span>
0270         <span class="comment">% direct strategy</span>
0271         <span class="keyword">if</span> strcmp(strategy, <span class="string">'direct'</span>)
0272           num = problem.M.norm(newx, Stransp)^2; 
0273           den = problem.M.inner(newx, Stransp, Y);
0274           <span class="keyword">if</span> den &gt; 0
0275             lambda = min( lambdamax, max(lambdamin, num/den) );
0276           <span class="keyword">else</span>
0277             lambda = lambdamax;
0278           <span class="keyword">end</span>
0279         <span class="keyword">end</span>
0280 
0281         <span class="comment">% inverse strategy</span>
0282         <span class="keyword">if</span> strcmp(strategy, <span class="string">'inverse'</span>)
0283           num = problem.M.inner(newx, Stransp, Y);
0284           den = problem.M.norm(newx, Y)^2;
0285 
0286           <span class="keyword">if</span> num &gt; 0  
0287             lambda = min( lambdamax, max(lambdamin, num/den) );
0288           <span class="keyword">else</span>
0289             lambda = lambdamax;
0290           <span class="keyword">end</span>
0291         <span class="keyword">end</span>
0292 
0293         <span class="comment">% alternate strategy</span>
0294         <span class="keyword">if</span> strcmp(strategy, <span class="string">'alternate'</span>)
0295           num = problem.M.norm(newx, Stransp)^2; 
0296           den = problem.M.inner(newx, Stransp, Y);
0297           den2 = problem.M.norm(newx, Y)^2;
0298           <span class="keyword">if</span> (den &gt; 0)  
0299             <span class="keyword">if</span> mod(iter,2)==0
0300                 lambda = min( lambdamax, max(lambdamin, num/den) );
0301         <span class="keyword">else</span>
0302                 lambda = min( lambdamax, max(lambdamin, den/den2) );
0303             <span class="keyword">end</span>
0304           <span class="keyword">else</span>
0305             lambda = lambdamax;
0306           <span class="keyword">end</span>
0307         <span class="keyword">end</span>
0308         
0309         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0310 
0311         <span class="comment">% Make sure we don't use too much memory for the store database</span>
0312         storedb.purge();
0313         
0314         <span class="comment">% Update iterate info</span>
0315         x = newx;
0316         key = newkey;
0317         cost = newcost;
0318         grad = newgrad;
0319         gradnorm = newgradnorm;
0320 
0321         <span class="comment">% iter is the number of iterations we have accomplished.</span>
0322         iter = iter + 1;
0323         
0324         <span class="comment">% Log statistics for freshly executed iteration</span>
0325         stats = <a href="#_sub1" class="code" title="subfunction stats = savestats()">savestats</a>();
0326         info(iter+1) = stats;
0327         
0328     <span class="keyword">end</span>
0329     
0330     info = info(1:iter+1);
0331 
0332     <span class="keyword">if</span> options.verbosity &gt;= 1
0333         fprintf(<span class="string">'Total time is %f [s] (excludes statsfun)\n'</span>, <span class="keyword">...</span>
0334                 info(end).time);
0335     <span class="keyword">end</span>
0336     
0337     
0338     
0339     <span class="comment">% Routine in charge of collecting the current iteration stats</span>
0340     <a name="_sub1" href="#_subfunctions" class="code">function stats = savestats()</a>
0341         stats.iter = iter;
0342         stats.cost = cost;
0343         stats.gradnorm = gradnorm;
0344         <span class="keyword">if</span> iter == 0
0345             stats.stepsize = NaN;
0346             stats.time = toc(timetic);
0347             stats.linesearch = [];
0348         <span class="keyword">else</span>
0349             stats.stepsize = stepsize;
0350             stats.time = info(iter).time + toc(timetic);
0351             stats.linesearch = lsstats;
0352         <span class="keyword">end</span>
0353         stats = <a href="../../../manopt/core/applyStatsfun.html" class="code" title="function stats = applyStatsfun(problem, x, storedb, key, options, stats)">applyStatsfun</a>(problem, x, storedb, key, options, stats);
0354     <span class="keyword">end</span>
0355     
0356 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 08-Sep-2017 12:43:19 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>