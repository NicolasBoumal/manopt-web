<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of StoreDB</title>
  <meta name="keywords" content="StoreDB">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="index.html">core</a> &gt; StoreDB.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\core&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>StoreDB
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="handle_light.html" class="code" title="">handle_light</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="getApproxGradient.html" class="code" title="function approxgrad = getApproxGradient(problem, x, storedb, key)">getApproxGradient</a>	Computes an approximation of the gradient of the cost function at x.</li><li><a href="getApproxHessian.html" class="code" title="function approxhess = getApproxHessian(problem, x, d, storedb, key)">getApproxHessian</a>	Computes an approximation of the Hessian of the cost fun. at x along d.</li><li><a href="getCost.html" class="code" title="function cost = getCost(problem, x, storedb, key)">getCost</a>	Computes the cost function at x.</li><li><a href="getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>	Computes the cost function and the gradient at x in one call if possible.</li><li><a href="getDirectionalDerivative.html" class="code" title="function diff = getDirectionalDerivative(problem, x, d, storedb, key)">getDirectionalDerivative</a>	Computes the directional derivative of the cost function at x along d.</li><li><a href="getEuclideanGradient.html" class="code" title="function egrad = getEuclideanGradient(problem, x, storedb, key)">getEuclideanGradient</a>	Computes the Euclidean gradient of the cost function at x.</li><li><a href="getGradient.html" class="code" title="function grad = getGradient(problem, x, storedb, key)">getGradient</a>	Computes the gradient of the cost function at x.</li><li><a href="getGradientFD.html" class="code" title="function gradfd = getGradientFD(problem, x, storedb, key)">getGradientFD</a>	Computes an approx. of the gradient w/ finite differences of the cost.</li><li><a href="getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>	Computes the Hessian of the cost function at x along d.</li><li><a href="getHessianFD.html" class="code" title="function hessfd = getHessianFD(problem, x, d, storedb, key)">getHessianFD</a>	Computes an approx. of the Hessian w/ finite differences of the gradient.</li><li><a href="getLinesearch.html" class="code" title="function t = getLinesearch(problem, x, d, storedb, key)">getLinesearch</a>	Returns a hint for line-search algorithms.</li><li><a href="getPartialEuclideanGradient.html" class="code" title="function egrad = getPartialEuclideanGradient(problem, x, I, storedb, key)">getPartialEuclideanGradient</a>	Computes the Euclidean gradient of a subset of terms in cost function.</li><li><a href="getPartialGradient.html" class="code" title="function grad = getPartialGradient(problem, x, I, storedb, key)">getPartialGradient</a>	Computes the gradient of a subset of terms in the cost function at x.</li><li><a href="getPrecon.html" class="code" title="function Pd = getPrecon(problem, x, d, storedb, key)">getPrecon</a>	Applies the preconditioner for the Hessian of the cost at x along d.</li><li><a href="getSqrtPrecon.html" class="code" title="function sqrtPd = getSqrtPrecon(problem, x, d, storedb, key)">getSqrtPrecon</a>	Applies the square root of the Hessian preconditioner at x along d.</li><li><a href="getSubgradient.html" class="code" title="function subgrad = getSubgradient(problem, x, tol, storedb, key)">getSubgradient</a>	Computes a subgradient of the cost function at x, up to a tolerance</li><li><a href="../../manopt/solvers/barzilaiborwein/barzilaiborwein.html" class="code" title="function [x, cost, info, options] = barzilaiborwein(problem, x, options)">barzilaiborwein</a>	Riemannian Barzilai-Borwein solver with non-monotone line-search.</li><li><a href="../../manopt/solvers/bfgs/rlbfgs.html" class="code" title="function [x, cost, info, options] = rlbfgs(problem, x0, options)">rlbfgs</a>	Riemannian limited memory BFGS solver for smooth objective functions.</li><li><a href="../../manopt/solvers/conjugategradient/conjugategradient.html" class="code" title="function [x, cost, info, options] = conjugategradient(problem, x, options)">conjugategradient</a>	Conjugate gradient minimization algorithm for Manopt.</li><li><a href="../../manopt/solvers/gradientapproximations/approxgradientFD.html" class="code" title="function gradfun = approxgradientFD(problem, options)">approxgradientFD</a>	Gradient approx. fnctn handle based on finite differences of the cost.</li><li><a href="../../manopt/solvers/hessianapproximations/approxhessianFD.html" class="code" title="function hessfun = approxhessianFD(problem, options)">approxhessianFD</a>	Hessian approx. fnctn handle based on finite differences of the gradient.</li><li><a href="../../manopt/solvers/linesearch/linesearch.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch(problem, x, d, f0, df0, options, storedb, key)">linesearch</a>	Standard line-search algorithm (step size selection) for descent methods.</li><li><a href="../../manopt/solvers/linesearch/linesearch_adaptive.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_adaptive(problem, x, d, f0, df0, options, storedb, key)">linesearch_adaptive</a>	Adaptive line search algorithm (step size selection) for descent methods.</li><li><a href="../../manopt/solvers/linesearch/linesearch_decrease.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_decrease(problem, x, d, f0, ~, options, storedb, key)">linesearch_decrease</a>	Backtracking line-search aiming merely for a decrease in cost value.</li><li><a href="../../manopt/solvers/linesearch/linesearch_hint.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_hint(problem, x, d, f0, df0, options, storedb, key)">linesearch_hint</a>	Armijo line-search based on the line-search hint in the problem structure.</li><li><a href="../../manopt/solvers/neldermead/neldermead.html" class="code" title="function [x, cost, info, options] = neldermead(problem, x, options)">neldermead</a>	Nelder Mead optimization algorithm for derivative-free minimization.</li><li><a href="../../manopt/solvers/preconditioners/preconhessiansolve.html" class="code" title="function preconfun = preconhessiansolve(problem, options)">preconhessiansolve</a>	Preconditioner based on the inverse Hessian, by solving linear systems.</li><li><a href="../../manopt/solvers/pso/pso.html" class="code" title="function [xbest, fbest, info, options] = pso(problem, x, options)">pso</a>	Particle swarm optimization (PSO) for derivative-free minimization.</li><li><a href="../../manopt/solvers/steepestdescent/steepestdescent.html" class="code" title="function [x, cost, info, options] = steepestdescent(problem, x, options)">steepestdescent</a>	Steepest descent (gradient descent) minimization algorithm for Manopt.</li><li><a href="../../manopt/solvers/stochasticgradient/stepsize_sg.html" class="code" title="function [stepsize, newx, newkey, ssstats] =stepsize_sg(problem, x, d, iter, options, storedb, key) %#ok<INUSD>">stepsize_sg</a>	Standard step size selection algorithm for the stochastic gradient method</li><li><a href="../../manopt/solvers/stochasticgradient/stochasticgradient.html" class="code" title="function [x, info, options] = stochasticgradient(problem, x, options)">stochasticgradient</a>	Stochastic gradient (SG) minimization algorithm for Manopt.</li><li><a href="../../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>	Riemannian trust-regions solver for optimization on manifolds.</li><li><a href="../../manopt/tools/checkdiff.html" class="code" title="function checkdiff(problem, x, d, force_gradient)">checkdiff</a>	Checks the consistency of the cost function and directional derivatives.</li><li><a href="../../manopt/tools/checkgradient.html" class="code" title="function checkgradient(problem, x, d)">checkgradient</a>	Checks the consistency of the cost function and the gradient.</li><li><a href="../../manopt/tools/checkhessian.html" class="code" title="function checkhessian(problem, x, d)">checkhessian</a>	Checks the consistency of the cost function and the Hessian.</li><li><a href="../../manopt/tools/hessianextreme.html" class="code" title="function [y, lambda, info] = hessianextreme(problem, x, side, y0, options, storedb, key)">hessianextreme</a>	Compute an extreme eigenvector / eigenvalue of the Hessian of a problem.</li><li><a href="../../manopt/tools/hessianmatrix.html" class="code" title="function [H, basis] = hessianmatrix(problem, x, basis)">hessianmatrix</a>	Computes a matrix which represents the Hessian in some tangent basis.</li><li><a href="../../manopt/tools/hessianspectrum.html" class="code" title="function lambdas = hessianspectrum(problem, x, usepreconstr, storedb, key)">hessianspectrum</a>	Returns the eigenvalues of the (preconditioned) Hessian at x.</li><li><a href="../../manopt/tools/plotprofile.html" class="code" title="function cost = plotprofile(problem, x, d, t)">plotprofile</a>	Plot the cost function along a geodesic or a retraction path.</li><li><a href="../../manopt/tools/surfprofile.html" class="code" title="function costs = surfprofile(problem, x, d1, d2, t1, t2)">surfprofile</a>	Plot the cost function as a surface over a 2-dimensional subspace.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function storedb = StoreDB(storedepth)</a></li><li><a href="#_sub2" class="code">function store = get(storedb, key)</a></li><li><a href="#_sub3" class="code">function store = getWithShared(storedb, key)</a></li><li><a href="#_sub4" class="code">function key = set(storedb, store, key)</a></li><li><a href="#_sub5" class="code">function key = setWithShared(storedb, store, key)</a></li><li><a href="#_sub6" class="code">function key = getNewKey(storedb)</a></li><li><a href="#_sub7" class="code">function purge(storedb)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="StoreDB.html" class="code" title="">StoreDB</a> &lt; <a href="handle_light.html" class="code" title="">handle_light</a>
0002 <span class="comment">% The StoreDB class is a handle class to manage caching in Manopt.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% To create an object, call: storedb = StoreDB();</span>
0005 <span class="comment">% Alternatively, call: storedb = StoreDB(storedepth); to instruct</span>
0006 <span class="comment">% the database to keep at most storedepth store's in its history.</span>
0007 <span class="comment">% (Note that clean up only happens when purge() is called).</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% The storedb object is passed by reference: when it is passed to a</span>
0010 <span class="comment">% function as an input, and that function modifies it, the original</span>
0011 <span class="comment">% object is modified.</span>
0012 
0013 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0014 <span class="comment">% Original author: Nicolas Boumal, April 3, 2015.</span>
0015 <span class="comment">% Contributors:</span>
0016 <span class="comment">% Change log:</span>
0017 
0018 <span class="comment">% TODO : protect get/setWithShared calls: limit to one, and forbid access</span>
0019 <span class="comment">%        to shared memory while it has not been returned.</span>
0020 <span class="comment">%        Do think of the applyStatsFun case : calls a getWithShared, does</span>
0021 <span class="comment">%        not need a setWithShared. I think for statsfun there should be a</span>
0022 <span class="comment">%        method &quot;forfeitWithShared&quot;.</span>
0023     
0024     properties(Access = public)
0025        
0026         <span class="comment">% This memory is meant to be shared at all times. Users can modify</span>
0027         <span class="comment">% this at will. It is the same for all points x.</span>
0028         shared = struct();
0029         
0030         <span class="comment">% This memory is used by the toolbox for, e.g., automatic caching</span>
0031         <span class="comment">% and book keeping. Users should not overwrite this. It is the</span>
0032         <span class="comment">% same for all points x.</span>
0033         internal = struct();
0034         
0035         <span class="comment">% When calling purge(), only a certain number of stores will be</span>
0036         <span class="comment">% kept in 'history'. This parameter fixes that number. The most</span>
0037         <span class="comment">% recently modified stores are kept. Set to inf to keep all stores.</span>
0038         storedepth = inf;
0039         
0040     <span class="keyword">end</span>
0041     
0042     properties(Access = private)
0043         
0044         <span class="comment">% This structure holds separate memories for individual points.</span>
0045         <span class="comment">% Use get and set to interact with this. The field name 'shared' is</span>
0046         <span class="comment">% reserved, for use with get/setWithShared.</span>
0047         history = struct();
0048         
0049         <span class="comment">% This internal counter is used to obtain unique key's for points.</span>
0050         counter = uint32(0);
0051         
0052         <span class="comment">% This internal counter is used to time calls to 'set', and hence</span>
0053         <span class="comment">% keep track of which stores in 'history' were last updated.</span>
0054         timer = uint32(0);
0055         
0056     <span class="keyword">end</span>
0057     
0058     
0059     methods(Access = public)
0060         
0061         <span class="comment">% Constructor</span>
0062         <a name="_sub0" href="#_subfunctions" class="code">function storedb = StoreDB(storedepth)</a>
0063             <span class="keyword">if</span> nargin &gt;= 1
0064                 storedb.storedepth = storedepth;
0065             <span class="keyword">end</span>
0066         <span class="keyword">end</span>
0067         
0068         <span class="comment">% Return the store associated to a given key.</span>
0069         <span class="comment">% If the key is unknown, returns an empty structure.</span>
0070         <a name="_sub1" href="#_subfunctions" class="code">function store = get(storedb, key)</a>
0071             <span class="keyword">if</span> isfield(storedb.history, key)
0072                 store = storedb.history.(key);
0073             <span class="keyword">else</span>
0074                 store = struct();
0075             <span class="keyword">end</span>
0076         <span class="keyword">end</span>
0077         
0078         <span class="comment">% Same as get, but adds the shared memory in store.shared.</span>
0079         <a name="_sub2" href="#_subfunctions" class="code">function store = getWithShared(storedb, key)</a>
0080             store = storedb.get(key);
0081             store.shared = storedb.shared;
0082         <span class="keyword">end</span>
0083         
0084         <span class="comment">% Save the given store at the given key. If no key is provided, a</span>
0085         <span class="comment">% new key is generated for this store (i.e., it is assumed this</span>
0086         <span class="comment">% store pertains to a new point). The key is returned in all cases.</span>
0087         <span class="comment">% A field 'lastset__' is added/updated in the store structure,</span>
0088         <span class="comment">% keeping track of the last time that store was modified.</span>
0089         <a name="_sub3" href="#_subfunctions" class="code">function key = set(storedb, store, key)</a>
0090             <span class="keyword">if</span> nargin &lt; 3
0091                 key = <a href="#_sub6" class="code" title="subfunction key = getNewKey(storedb)">getNewKey</a>(storedb);
0092             <span class="keyword">end</span>
0093             store.lastset__ = storedb.timer;
0094             storedb.timer = storedb.timer + 1;
0095             storedb.history.(key) = store;
0096         <span class="keyword">end</span>
0097         
0098         <span class="comment">% Same as set, but extracts the shared memory and saves it.</span>
0099         <span class="comment">% The stored store will still have a 'shared' field, but it will be</span>
0100         <span class="comment">% empty.</span>
0101         <a name="_sub4" href="#_subfunctions" class="code">function key = setWithShared(storedb, store, key)</a>
0102             storedb.shared = store.shared;
0103             store.shared = [];
0104             key = storedb.set(store, key);
0105         <span class="keyword">end</span>
0106         
0107         <span class="comment">% Generate a unique key and return it. This should be called</span>
0108         <span class="comment">% everytime a new point is generated / stored. Keys are valid field</span>
0109         <span class="comment">% names for structures.</span>
0110         <a name="_sub5" href="#_subfunctions" class="code">function key = getNewKey(storedb)</a>
0111             key = sprintf(<span class="string">'z%d'</span>, storedb.counter);
0112             storedb.counter = storedb.counter + 1;
0113         <span class="keyword">end</span>
0114         
0115         <span class="comment">% Clear entries in storedb.history to limit memory usage.</span>
0116         <a name="_sub6" href="#_subfunctions" class="code">function purge(storedb)</a>
0117             
0118             <span class="keyword">if</span> isinf(storedb.storedepth)
0119                 <span class="keyword">return</span>;
0120             <span class="keyword">end</span>
0121             
0122             <span class="keyword">if</span> storedb.storedepth &lt;= 0
0123                 storedb.history = struct();
0124                 <span class="keyword">return</span>;
0125             <span class="keyword">end</span>
0126 
0127             <span class="comment">% Get list of field names (keys).</span>
0128             keys = fieldnames(storedb.history);
0129             nkeys = length(keys);
0130 
0131             <span class="comment">% If we need to remove some of the elements in the database,</span>
0132             <span class="keyword">if</span> nkeys &gt; storedb.storedepth
0133 
0134                 <span class="comment">% Get the last-set counter of each element:</span>
0135                 <span class="comment">% a higher number means it was modified more recently.</span>
0136                 lastset = zeros(nkeys, 1, <span class="string">'uint32'</span>);
0137                 <span class="keyword">for</span> i = 1 : nkeys
0138                     lastset(i) = storedb.history.(keys{i}).lastset__;
0139                 <span class="keyword">end</span>
0140 
0141                 <span class="comment">% Sort the counters and determine the threshold above which</span>
0142                 <span class="comment">% the field needs to be removed.</span>
0143                 sortlastset = sort(lastset, 1, <span class="string">'descend'</span>);
0144                 minlastset = sortlastset(storedb.storedepth);
0145 
0146                 <span class="comment">% Remove all fields that are too old.</span>
0147                 storedb.history = rmfield(storedb.history, <span class="keyword">...</span>
0148                                                keys(lastset &lt; minlastset));
0149             <span class="keyword">end</span>
0150             
0151         <span class="keyword">end</span> <span class="comment">% end of purge()</span>
0152         
0153     <span class="keyword">end</span>
0154     
0155 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 08-Sep-2017 12:43:19 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>