---
title: "Lifts: parameterizations made easy"
subtitle: "Use lifts to compose an optimization problem with a parameterization"
toc: true
toc-depth: 3
toc-expand: 2
sidebar: tutorial
---

## General idea ![](images/icon_salute.gif)

At first sight, optimization on manifolds is restricted to optimization problems on smooth sets.
Notwithstanding, we can use smooth parameterizations of (possibly) nonsmooth sets to extend the realm of applications.

Consider the following commutative diagram.

<!--https://q.uiver.app/#q=WzAsNSxbNCwzLCJcXG1hdGhjYWx7Tn0iXSxbOCwzLCJcXG1hdGhiYntSfSJdLFs0LDIsIlxcbWF0aGNhbHtNfSJdLFs0LDEsIlxcbWF0aGNhbHtFfSIsWzMwMCw2MCw2MCwxXV0sWzAsMF0sWzAsMSwiZiIsMl0sWzIsMCwiXFx2YXJwaGkiXSxbMiwxLCJnPWZcXGNpcmMgXFx2YXJwaGkiXSxbMiwzLCIiLDIseyJjb2xvdXIiOlszMDAsNjAsNjBdLCJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJob29rIiwic2lkZSI6ImJvdHRvbSJ9fX1dLFszLDEsIlxcYmFye2d9IiwwLHsiY3VydmUiOi0yLCJjb2xvdXIiOlszMDAsNjAsNjBdfSxbMzAwLDYwLDYwLDFdXSxbMywwLCJcXGJhcntcXHZhcnBoaX0iLDIseyJjdXJ2ZSI6MywiY29sb3VyIjpbMzAwLDYwLDYwXX0sWzMwMCw2MCw2MCwxXV1d-->
![Commutative diagram on which lifts are based.](images/lift_diagram_EMN.png){#fig-diagramEMN width=25em}

The principal objects in this diagram are in black.
They are as follows:

* $\calM$ is a Riemannian manifold.
* $\calN$ is a Riemannian manifold too (often, it is a Euclidean space).
* $f \colon \calN \to \reals$ is the cost function we wish to minimize *on some subset*.
* $\varphi \colon \calM \to \calN$ is the *lift* or *parameterization*: its image $\calX = \varphi(\calM)$ is a subset of $\calN$.
* $g = f \circ \varphi \colon \calM \to \reals$ is the function we will actually minimize (without restriction on $\calM$).

Notice that by minimizing $g$ on $\calM$, we are effectively minimizing $f$ on $\calX$, because $g(y) = f(\varphi(y))$ so that we only ever evaluate $f$ at points of the form $x = \varphi(y)$ which, by definition, are in $\calX$.

Moreover, if $f$ and $\varphi$ are both smooth, then so is $f$ by composition.

This means that even if $\calX$ is a nonsmooth set, we can still use Manopt to (try to) minimize $f$ on $\calX \subset \calN$.

We can do this explicitly by constructing a `problem` structure for $g$ on $\calM$.
Alternatively, we can construct a problem structure for $f$ on $\calN$ and compose it with $\varphi$ by using `manoptlift`.
To do so, this tool requires some information about $\varphi$ and its derivatives: this is all stored in a `lift` structure.
Manopt comes with some built-in lifts (see below), and users can create their own.


## Available lifts

The following lifts are available in Manopt:

* 
* 
* 

They can be used to optimize over several nonsmooth sets, as listed in the next few sections with further explanations.

## Hadamard (entrywise product)

## Burer-Monteiro for smooth SDP

## Burer-Monteiro for general bounded-rank

## Boxes

## Balls


## Lift structures: what's in them?

The `lift` structure must provide enough information about $\varphi$ (in the form of function handles) so that Manopt can automatically deduce how to compute $g = f \circ \varphi$, its gradient and (ideally) its Hessian, based on the corresponding information about $f$.

Let $y \in \calM$ and $x = \varphi(y) \in \calN$.
By the chain rule, for all $v \in \T_y\calM$ we have
$$
    \D g(y)[v] = \D(f \circ \varphi)(y)[v] = \D f(x)[\D\varphi(y)[v]].
$$
By definition of the Riemannian gradient, then by definition of the adjoint of a linear map, this yields
$$
    \inner{\grad g(y)}{v}_y = \inner{\grad f(x)}{\D\varphi(y)[v]}_x = \inner{\D\varphi(y)^*[\grad f(x)]}{v}_y.
$$
This holds for all $v$.
Thus,
$$
    \grad g(y) = \D\varphi(y)^*[\grad f(x)].
$$
This illustrates how we can get the gradient of $g$ from that of $f$ provided the lift gives us access to $\D\varphi(y)^*$.
(We might call this map `fgrad2ggrad` to echo the similar role it plays when compared to `egrad2rgrad`, where $\varphi$ is the inclusion map from the manifold into its embedding space.)
For the Hessian, additional computations shown later on this page tell us what else needs to be included: see @eq-hessgtotal.


| Name  | Field usage  | Functionality  |
|-|--|---|
| $\calM$ | `lift.M` | Manifold structure from a factory ("upstairs") |
| $\calN$ | `lift.N` | Manifold structure from a factory ("downstairs") |
| $\varphi$ | `x = lift.phi(y)` | Computes the image of $y \in \calM$ through $\varphi \colon \calM \to \calN$ |
| $\D\varphi(y)$ | `u = lift.Dphi(y, v)` | Differential of $\varphi$ at $y \in \calM$ along $v \in \T_y\calM$. The output is $u = \D\varphi(y)[v]$ in $\T_x\calN$ where $x = \varphi(y)$. |
| $\D\varphi(y)^*$ | `v = lift.Dphit(y, u)` | Adjoint of $\D\varphi(y)$ with respect ot the inner products on $\T_y\calM$ and $\T_x\calN$, where $x = \varphi(y)$. Thus, $$\inner{\D\varphi(y)[v]}{u}_x = \inner{v}{\D\varphi(y)^*[u]}_y.$$ |
| $\Hess h_w(y)$ | `s = lift.hesshw(y, v, w)` | Given $y \in \calM$ and $w \in \T_x\calN$ where $x = \varphi(y)$, choose $q_w \colon \calN \to \reals$ such that $\grad q_w(x) = w$ (for the specified $x$). Let $h_w = q_w \circ \varphi \colon \calM \to \reals$. Then $s = \Hess h_w(y)[v]$. If $\calN$ is Euclidean, a typical choice is $q_w = \inner{\cdot}{w}_\calN$.  |
| $\Hess q_w(x)$ | `s = lift.hessqw(x, u, w)` | Given $x \in \calN$ and $w \in \T_x\calN$, choose $q_w \colon \calN \to \reals$ such that $\grad q_w(x) = w$ (for the specified $x$). Then $s = \Hess q_w(x)[u]$. If $\calN$ is Euclidean, a typical choice is $q_w = \inner{\cdot}{w}_\calN$, in which case $\Hess q_w = 0$. If the field is omitted, it is assumed that the Hessian is zero.  |
| $\varphi$ or $\bar{\varphi}$? | `lift.embedded` | Boolean flag set to `false` (by default) if all of the above indeed pertains to $\varphi$, and set to `true` if the above instead describes $\bar{\varphi} \colon \calE \to \calN$, where $\calE$ is the embedding space for $\calM$ (as specified in the documentation for the corresponding factory), as a smooth extension such that $\bar{\varphi}|_\calM = \varphi$. See @fig-diagramEMN. In that case, the lift enables computation of $\grad \bar{g}$ and $\Hess \bar{g}$, which $\calM$ can then convert to $\grad g$ and $\hess g$ using `egrad2rgrad` and `ehess2rhess`. |
: Fields in a `lift` structure.


## How are the landscapes related?



## Side comments

The `desingularizationfactory` encode the geometry of a Riemannian manifold, but `egrad2rgrad` and `ehess2rhess` in that factory actually correspond to a lift, as described in the documentation of the factory.


## The Hessian of $g$

To obtain the Hessian of $g = f \circ \varphi$, it is convenient to go through curves.
Let $c \colon \reals \to \calM$ be a smooth curve satisfying $c(0) = y$, $c'(0) = v$ and $c''(0) = 0$ (zero initial intrinsic acceleration).

Push it to a curve downstairs as $\gamma = \varphi \circ c$.
It satisfies $\gamma(0) = \varphi(y) = x$.
Let $u = \gamma'(0) = \D\varphi(c(0))[c'(0)] = \D\varphi(y)[v]$.

The cost function along these curves satisfies
$$
    g \circ c = f \circ \varphi \circ c = f \circ \gamma.
$$
Thus, the derivatives of $g \circ c$ and $f \circ \gamma$ (two functions from $\reals$ to $\reals$) are identical.
On the one hand, we compute
$$
    (g \circ c)'(t) = \D g(c(t))[c'(t)] = \inner{\grad g(c(t))}{c'(t)}_{c(t)}
$$
and
$$
    (g \circ c)''(t) = \inner{\Hess g(c(t))[c'(t)]}{c'(t)}_{c(t)} + \inner{\grad g(c(t))}{c''(t)}_{c(t)}.
$$
At $t = 0$, these yield
$$
    (g \circ c)'(0) = \inner{\grad g(y)}{v}_{y}
$$
and
$$
    (g \circ c)''(0) = \inner{\Hess g(y)[v]}{v}_{y} + \inner{\grad g(y)}{c''(0)}_{y}.
$$
On the other hand, applying the same computations to $f \circ \gamma$ instead of $g \circ c$ yields
$$
    (f \circ \gamma)'(0) = \inner{\grad f(x)}{u}_{x}
$$
and
$$
    (f \circ \gamma)''(0) = \inner{\Hess f(x)[u]}{u}_{x} + \inner{\grad f(x)}{\gamma''(0)}_{x}.
$$
We know that $(g \circ c)'(0) = (f \circ \gamma)'(0)$ and also that $(g \circ c)''(0) = (f \circ \gamma)''(0)$.
We could use the first-order derivatives to recover the identity
$$
    \grad g(y) = \D\varphi(y)^*[\grad f(x)].
$$
Focusing on second-order derivatives, we have found that
$$
    \inner{\Hess g(y)[v]}{v}_{y} = \inner{\Hess f(x)[u]}{u}_{x} + \inner{\grad f(x)}{\gamma''(0)}_{x} - \inner{\grad g(y)}{c''(0)}_{y}.
$$ {#eq-hessgfoo}
Recall that we assume $c''(0) = 0$.
To handle $\gamma''(0)$, we proceed as follows.

Fix an arbitrary $w \in \T_x\calN$ and let $q_w \colon \calN \to \reals$ satisfy $\grad q_w(x) = w$ (that is, at the specific $x$ under consideration, the gradient of $q_w$ is $w$).
For example, if $\calN$ is a Euclidean space, then a convenient choice is $q_w = \inner{\cdot}{w}_\calN$ (a linear function whose gradient at *all* points is $w$: it's more than we need).

Let $h_w = q_w \circ \varphi$.
This is a real function on $\calM$.
Plug $h_w$ and $q_w$ in place of $g$ and $f$ in @eq-hessgfoo.
This reveals
$$
    \inner{\Hess h_w(y)[v]}{v}_{y} = \inner{\Hess q_w(x)[u]}{u}_{x} + \inner{\grad q_w(x)}{\gamma''(0)}_{x}.
$$
Since $\grad q_w(x) = w$, we have found that
$$
    \inner{w}{\gamma''(0)}_{x} = \inner{\Hess h_w(y)[v]}{v}_{y} - \inner{\Hess q_w(x)[u]}{u}_{x}.
$$
Now let $w = \grad f(x)$ and plug this into @eq-hessgfoo in order to get rid of $\gamma''(0)$, as follows:
$$
    \inner{\Hess g(y)[v]}{v}_{y} = \inner{\Hess f(x)[u]}{u}_{x} + \inner{\Hess h_w(y)[v]}{v}_{y} - \inner{\Hess q_w(x)[u]}{u}_{x}.
$$
Recall that $u = \D\varphi(y)[v]$.
Then, all in all, we have the following formula for the Riemannian Hessian of $g$ at $y$:
$$
    \Hess g(y) = \D\varphi(y)^* \circ \left( \Hess f(x) - \Hess q_w(x) \right) \circ \D\varphi(y) + \Hess h_w(y),
$$ {#eq-hessgtotal}
where

* $x = \varphi(y)$,
* $w = \grad f(x)$,
* $q_w \colon \calN \to \reals$ is any smooth function which satisfies $\grad q_w(x) = w$, and
* $h_w = q_w \circ \varphi \colon \calM \to \reals$.

(The choice of curve $c$ no longer plays a role.)

The final formula @eq-hessgtotal tells us exactly what information we need about $\varphi$ in order to be able to compute the Hessian of $g$ based on the gradient and Hessian of $f$.
The fields `lift.Dphi` and `lift.Dphit` encode the maps $\D\varphi(y)$ and $\D\varphi(y)^*$, while the field `lift.hesshw` encodes the map $\Hess h_w(y)$.
If $\calN$ is a Euclidean space (which is typical), then we always choose $q_w = \inner{\cdot}{w}_\calN$ so that $\Hess q_w(x) = 0$.
Otherwise, we need to provide that map too, in `lift.hessqw`.
